// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flightplan/flightplan.proto

#ifndef PROTOBUF_INCLUDED_flightplan_2fflightplan_2eproto
#define PROTOBUF_INCLUDED_flightplan_2fflightplan_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "flightplan/validation_type.pb.h"
#include "flightplan/viewmode_yaw.pb.h"
#include "flightplan/viewmode_pitch.pb.h"
#include "flightplan/viewmode_roll.pb.h"
#include "flightplan/viewmode_zoom.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flightplan_2fflightplan_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_flightplan_2fflightplan_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_flightplan_2fflightplan_2eproto();
namespace Flightplan {
namespace Messages {
class GeoCoordinates;
class GeoCoordinatesDefaultTypeInternal;
extern GeoCoordinatesDefaultTypeInternal _GeoCoordinates_default_instance_;
class NedCoordinates;
class NedCoordinatesDefaultTypeInternal;
extern NedCoordinatesDefaultTypeInternal _NedCoordinates_default_instance_;
class Orientation;
class OrientationDefaultTypeInternal;
extern OrientationDefaultTypeInternal _Orientation_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class View;
class ViewDefaultTypeInternal;
extern ViewDefaultTypeInternal _View_default_instance_;
class ViewMode;
class ViewModeDefaultTypeInternal;
extern ViewModeDefaultTypeInternal _ViewMode_default_instance_;
class Waypoint;
class WaypointDefaultTypeInternal;
extern WaypointDefaultTypeInternal _Waypoint_default_instance_;
class WaypointPath;
class WaypointPathDefaultTypeInternal;
extern WaypointPathDefaultTypeInternal _WaypointPath_default_instance_;
}  // namespace Messages
}  // namespace Flightplan
namespace google {
namespace protobuf {
template<> ::Flightplan::Messages::GeoCoordinates* Arena::CreateMaybeMessage<::Flightplan::Messages::GeoCoordinates>(Arena*);
template<> ::Flightplan::Messages::NedCoordinates* Arena::CreateMaybeMessage<::Flightplan::Messages::NedCoordinates>(Arena*);
template<> ::Flightplan::Messages::Orientation* Arena::CreateMaybeMessage<::Flightplan::Messages::Orientation>(Arena*);
template<> ::Flightplan::Messages::Position* Arena::CreateMaybeMessage<::Flightplan::Messages::Position>(Arena*);
template<> ::Flightplan::Messages::View* Arena::CreateMaybeMessage<::Flightplan::Messages::View>(Arena*);
template<> ::Flightplan::Messages::ViewMode* Arena::CreateMaybeMessage<::Flightplan::Messages::ViewMode>(Arena*);
template<> ::Flightplan::Messages::Waypoint* Arena::CreateMaybeMessage<::Flightplan::Messages::Waypoint>(Arena*);
template<> ::Flightplan::Messages::WaypointPath* Arena::CreateMaybeMessage<::Flightplan::Messages::WaypointPath>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Flightplan {
namespace Messages {

// ===================================================================

class GeoCoordinates :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Flightplan.Messages.GeoCoordinates) */ {
 public:
  GeoCoordinates();
  virtual ~GeoCoordinates();

  GeoCoordinates(const GeoCoordinates& from);

  inline GeoCoordinates& operator=(const GeoCoordinates& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GeoCoordinates(GeoCoordinates&& from) noexcept
    : GeoCoordinates() {
    *this = ::std::move(from);
  }

  inline GeoCoordinates& operator=(GeoCoordinates&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GeoCoordinates& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoCoordinates* internal_default_instance() {
    return reinterpret_cast<const GeoCoordinates*>(
               &_GeoCoordinates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(GeoCoordinates* other);
  friend void swap(GeoCoordinates& a, GeoCoordinates& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GeoCoordinates* New() const final {
    return CreateMaybeMessage<GeoCoordinates>(nullptr);
  }

  GeoCoordinates* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GeoCoordinates>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GeoCoordinates& from);
  void MergeFrom(const GeoCoordinates& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoCoordinates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double latitude = 1;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  double latitude() const;
  void set_latitude(double value);

  // double longitude = 2;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  double longitude() const;
  void set_longitude(double value);

  // double altitude = 3;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  double altitude() const;
  void set_altitude(double value);

  // @@protoc_insertion_point(class_scope:Flightplan.Messages.GeoCoordinates)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double latitude_;
  double longitude_;
  double altitude_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flightplan_2fflightplan_2eproto;
};
// -------------------------------------------------------------------

class NedCoordinates :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Flightplan.Messages.NedCoordinates) */ {
 public:
  NedCoordinates();
  virtual ~NedCoordinates();

  NedCoordinates(const NedCoordinates& from);

  inline NedCoordinates& operator=(const NedCoordinates& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NedCoordinates(NedCoordinates&& from) noexcept
    : NedCoordinates() {
    *this = ::std::move(from);
  }

  inline NedCoordinates& operator=(NedCoordinates&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NedCoordinates& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NedCoordinates* internal_default_instance() {
    return reinterpret_cast<const NedCoordinates*>(
               &_NedCoordinates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(NedCoordinates* other);
  friend void swap(NedCoordinates& a, NedCoordinates& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NedCoordinates* New() const final {
    return CreateMaybeMessage<NedCoordinates>(nullptr);
  }

  NedCoordinates* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NedCoordinates>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NedCoordinates& from);
  void MergeFrom(const NedCoordinates& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NedCoordinates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float north = 1;
  void clear_north();
  static const int kNorthFieldNumber = 1;
  float north() const;
  void set_north(float value);

  // float east = 2;
  void clear_east();
  static const int kEastFieldNumber = 2;
  float east() const;
  void set_east(float value);

  // float down = 3;
  void clear_down();
  static const int kDownFieldNumber = 3;
  float down() const;
  void set_down(float value);

  // @@protoc_insertion_point(class_scope:Flightplan.Messages.NedCoordinates)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float north_;
  float east_;
  float down_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flightplan_2fflightplan_2eproto;
};
// -------------------------------------------------------------------

class Orientation :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Flightplan.Messages.Orientation) */ {
 public:
  Orientation();
  virtual ~Orientation();

  Orientation(const Orientation& from);

  inline Orientation& operator=(const Orientation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Orientation(Orientation&& from) noexcept
    : Orientation() {
    *this = ::std::move(from);
  }

  inline Orientation& operator=(Orientation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Orientation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Orientation* internal_default_instance() {
    return reinterpret_cast<const Orientation*>(
               &_Orientation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Orientation* other);
  friend void swap(Orientation& a, Orientation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Orientation* New() const final {
    return CreateMaybeMessage<Orientation>(nullptr);
  }

  Orientation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Orientation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Orientation& from);
  void MergeFrom(const Orientation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Orientation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float roll = 1;
  void clear_roll();
  static const int kRollFieldNumber = 1;
  float roll() const;
  void set_roll(float value);

  // float pitch = 2;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  float pitch() const;
  void set_pitch(float value);

  // float yaw = 3;
  void clear_yaw();
  static const int kYawFieldNumber = 3;
  float yaw() const;
  void set_yaw(float value);

  // @@protoc_insertion_point(class_scope:Flightplan.Messages.Orientation)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float roll_;
  float pitch_;
  float yaw_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flightplan_2fflightplan_2eproto;
};
// -------------------------------------------------------------------

class Position :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Flightplan.Messages.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Position& default_instance();

  enum CoordTypeCase {
    kGeo = 1,
    kNed = 2,
    COORDTYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Position* other);
  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const final {
    return CreateMaybeMessage<Position>(nullptr);
  }

  Position* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Flightplan.Messages.GeoCoordinates geo = 1;
  bool has_geo() const;
  void clear_geo();
  static const int kGeoFieldNumber = 1;
  const ::Flightplan::Messages::GeoCoordinates& geo() const;
  ::Flightplan::Messages::GeoCoordinates* release_geo();
  ::Flightplan::Messages::GeoCoordinates* mutable_geo();
  void set_allocated_geo(::Flightplan::Messages::GeoCoordinates* geo);

  // .Flightplan.Messages.NedCoordinates ned = 2;
  bool has_ned() const;
  void clear_ned();
  static const int kNedFieldNumber = 2;
  const ::Flightplan::Messages::NedCoordinates& ned() const;
  ::Flightplan::Messages::NedCoordinates* release_ned();
  ::Flightplan::Messages::NedCoordinates* mutable_ned();
  void set_allocated_ned(::Flightplan::Messages::NedCoordinates* ned);

  void clear_CoordType();
  CoordTypeCase CoordType_case() const;
  // @@protoc_insertion_point(class_scope:Flightplan.Messages.Position)
 private:
  class HasBitSetters;
  void set_has_geo();
  void set_has_ned();

  inline bool has_CoordType() const;
  inline void clear_has_CoordType();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union CoordTypeUnion {
    CoordTypeUnion() {}
    ::Flightplan::Messages::GeoCoordinates* geo_;
    ::Flightplan::Messages::NedCoordinates* ned_;
  } CoordType_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flightplan_2fflightplan_2eproto;
};
// -------------------------------------------------------------------

class View :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Flightplan.Messages.View) */ {
 public:
  View();
  virtual ~View();

  View(const View& from);

  inline View& operator=(const View& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  View(View&& from) noexcept
    : View() {
    *this = ::std::move(from);
  }

  inline View& operator=(View&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const View& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const View* internal_default_instance() {
    return reinterpret_cast<const View*>(
               &_View_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(View* other);
  friend void swap(View& a, View& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline View* New() const final {
    return CreateMaybeMessage<View>(nullptr);
  }

  View* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<View>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const View& from);
  void MergeFrom(const View& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(View* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Flightplan.Messages.Position position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::Flightplan::Messages::Position& position() const;
  ::Flightplan::Messages::Position* release_position();
  ::Flightplan::Messages::Position* mutable_position();
  void set_allocated_position(::Flightplan::Messages::Position* position);

  // .Flightplan.Messages.Orientation orientation = 2;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  const ::Flightplan::Messages::Orientation& orientation() const;
  ::Flightplan::Messages::Orientation* release_orientation();
  ::Flightplan::Messages::Orientation* mutable_orientation();
  void set_allocated_orientation(::Flightplan::Messages::Orientation* orientation);

  // float zoom_factor = 3;
  void clear_zoom_factor();
  static const int kZoomFactorFieldNumber = 3;
  float zoom_factor() const;
  void set_zoom_factor(float value);

  // @@protoc_insertion_point(class_scope:Flightplan.Messages.View)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Flightplan::Messages::Position* position_;
  ::Flightplan::Messages::Orientation* orientation_;
  float zoom_factor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flightplan_2fflightplan_2eproto;
};
// -------------------------------------------------------------------

class ViewMode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Flightplan.Messages.ViewMode) */ {
 public:
  ViewMode();
  virtual ~ViewMode();

  ViewMode(const ViewMode& from);

  inline ViewMode& operator=(const ViewMode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ViewMode(ViewMode&& from) noexcept
    : ViewMode() {
    *this = ::std::move(from);
  }

  inline ViewMode& operator=(ViewMode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ViewMode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ViewMode* internal_default_instance() {
    return reinterpret_cast<const ViewMode*>(
               &_ViewMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ViewMode* other);
  friend void swap(ViewMode& a, ViewMode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ViewMode* New() const final {
    return CreateMaybeMessage<ViewMode>(nullptr);
  }

  ViewMode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ViewMode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ViewMode& from);
  void MergeFrom(const ViewMode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ViewMode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Flightplan.Messages.Position poi_position = 5;
  bool has_poi_position() const;
  void clear_poi_position();
  static const int kPoiPositionFieldNumber = 5;
  const ::Flightplan::Messages::Position& poi_position() const;
  ::Flightplan::Messages::Position* release_poi_position();
  ::Flightplan::Messages::Position* mutable_poi_position();
  void set_allocated_poi_position(::Flightplan::Messages::Position* poi_position);

  // .Flightplan.Enums.ViewMode.Yaw.Enum yaw = 1;
  void clear_yaw();
  static const int kYawFieldNumber = 1;
  ::Flightplan::Enums::ViewMode::Yaw::Enum yaw() const;
  void set_yaw(::Flightplan::Enums::ViewMode::Yaw::Enum value);

  // .Flightplan.Enums.ViewMode.Pitch.Enum pitch = 2;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  ::Flightplan::Enums::ViewMode::Pitch::Enum pitch() const;
  void set_pitch(::Flightplan::Enums::ViewMode::Pitch::Enum value);

  // .Flightplan.Enums.ViewMode.Roll.Enum roll = 3;
  void clear_roll();
  static const int kRollFieldNumber = 3;
  ::Flightplan::Enums::ViewMode::Roll::Enum roll() const;
  void set_roll(::Flightplan::Enums::ViewMode::Roll::Enum value);

  // .Flightplan.Enums.ViewMode.Zoom.Enum zoom = 4;
  void clear_zoom();
  static const int kZoomFieldNumber = 4;
  ::Flightplan::Enums::ViewMode::Zoom::Enum zoom() const;
  void set_zoom(::Flightplan::Enums::ViewMode::Zoom::Enum value);

  // @@protoc_insertion_point(class_scope:Flightplan.Messages.ViewMode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Flightplan::Messages::Position* poi_position_;
  int yaw_;
  int pitch_;
  int roll_;
  int zoom_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flightplan_2fflightplan_2eproto;
};
// -------------------------------------------------------------------

class Waypoint :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Flightplan.Messages.Waypoint) */ {
 public:
  Waypoint();
  virtual ~Waypoint();

  Waypoint(const Waypoint& from);

  inline Waypoint& operator=(const Waypoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Waypoint(Waypoint&& from) noexcept
    : Waypoint() {
    *this = ::std::move(from);
  }

  inline Waypoint& operator=(Waypoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Waypoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Waypoint* internal_default_instance() {
    return reinterpret_cast<const Waypoint*>(
               &_Waypoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Waypoint* other);
  friend void swap(Waypoint& a, Waypoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Waypoint* New() const final {
    return CreateMaybeMessage<Waypoint>(nullptr);
  }

  Waypoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Waypoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Waypoint& from);
  void MergeFrom(const Waypoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Waypoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Flightplan.Messages.View view = 1;
  bool has_view() const;
  void clear_view();
  static const int kViewFieldNumber = 1;
  const ::Flightplan::Messages::View& view() const;
  ::Flightplan::Messages::View* release_view();
  ::Flightplan::Messages::View* mutable_view();
  void set_allocated_view(::Flightplan::Messages::View* view);

  // .Flightplan.Messages.ViewMode view_mode = 2;
  bool has_view_mode() const;
  void clear_view_mode();
  static const int kViewModeFieldNumber = 2;
  const ::Flightplan::Messages::ViewMode& view_mode() const;
  ::Flightplan::Messages::ViewMode* release_view_mode();
  ::Flightplan::Messages::ViewMode* mutable_view_mode();
  void set_allocated_view_mode(::Flightplan::Messages::ViewMode* view_mode);

  // .Flightplan.Enums.ValidationType.Enum validation_type = 3;
  void clear_validation_type();
  static const int kValidationTypeFieldNumber = 3;
  ::Flightplan::Enums::ValidationType::Enum validation_type() const;
  void set_validation_type(::Flightplan::Enums::ValidationType::Enum value);

  // float validation_radius = 4;
  void clear_validation_radius();
  static const int kValidationRadiusFieldNumber = 4;
  float validation_radius() const;
  void set_validation_radius(float value);

  // float speed = 5;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  float speed() const;
  void set_speed(float value);

  // int32 original_id = 6;
  void clear_original_id();
  static const int kOriginalIdFieldNumber = 6;
  ::google::protobuf::int32 original_id() const;
  void set_original_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Flightplan.Messages.Waypoint)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Flightplan::Messages::View* view_;
  ::Flightplan::Messages::ViewMode* view_mode_;
  int validation_type_;
  float validation_radius_;
  float speed_;
  ::google::protobuf::int32 original_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flightplan_2fflightplan_2eproto;
};
// -------------------------------------------------------------------

class WaypointPath :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Flightplan.Messages.WaypointPath) */ {
 public:
  WaypointPath();
  virtual ~WaypointPath();

  WaypointPath(const WaypointPath& from);

  inline WaypointPath& operator=(const WaypointPath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaypointPath(WaypointPath&& from) noexcept
    : WaypointPath() {
    *this = ::std::move(from);
  }

  inline WaypointPath& operator=(WaypointPath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WaypointPath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaypointPath* internal_default_instance() {
    return reinterpret_cast<const WaypointPath*>(
               &_WaypointPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(WaypointPath* other);
  friend void swap(WaypointPath& a, WaypointPath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaypointPath* New() const final {
    return CreateMaybeMessage<WaypointPath>(nullptr);
  }

  WaypointPath* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaypointPath>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaypointPath& from);
  void MergeFrom(const WaypointPath& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaypointPath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Flightplan.Messages.Waypoint waypoints = 1;
  int waypoints_size() const;
  void clear_waypoints();
  static const int kWaypointsFieldNumber = 1;
  ::Flightplan::Messages::Waypoint* mutable_waypoints(int index);
  ::google::protobuf::RepeatedPtrField< ::Flightplan::Messages::Waypoint >*
      mutable_waypoints();
  const ::Flightplan::Messages::Waypoint& waypoints(int index) const;
  ::Flightplan::Messages::Waypoint* add_waypoints();
  const ::google::protobuf::RepeatedPtrField< ::Flightplan::Messages::Waypoint >&
      waypoints() const;

  // uint32 start_at_index = 2;
  void clear_start_at_index();
  static const int kStartAtIndexFieldNumber = 2;
  ::google::protobuf::uint32 start_at_index() const;
  void set_start_at_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Flightplan.Messages.WaypointPath)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Flightplan::Messages::Waypoint > waypoints_;
  ::google::protobuf::uint32 start_at_index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flightplan_2fflightplan_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GeoCoordinates

// double latitude = 1;
inline void GeoCoordinates::clear_latitude() {
  latitude_ = 0;
}
inline double GeoCoordinates::latitude() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.GeoCoordinates.latitude)
  return latitude_;
}
inline void GeoCoordinates::set_latitude(double value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.GeoCoordinates.latitude)
}

// double longitude = 2;
inline void GeoCoordinates::clear_longitude() {
  longitude_ = 0;
}
inline double GeoCoordinates::longitude() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.GeoCoordinates.longitude)
  return longitude_;
}
inline void GeoCoordinates::set_longitude(double value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.GeoCoordinates.longitude)
}

// double altitude = 3;
inline void GeoCoordinates::clear_altitude() {
  altitude_ = 0;
}
inline double GeoCoordinates::altitude() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.GeoCoordinates.altitude)
  return altitude_;
}
inline void GeoCoordinates::set_altitude(double value) {
  
  altitude_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.GeoCoordinates.altitude)
}

// -------------------------------------------------------------------

// NedCoordinates

// float north = 1;
inline void NedCoordinates::clear_north() {
  north_ = 0;
}
inline float NedCoordinates::north() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.NedCoordinates.north)
  return north_;
}
inline void NedCoordinates::set_north(float value) {
  
  north_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.NedCoordinates.north)
}

// float east = 2;
inline void NedCoordinates::clear_east() {
  east_ = 0;
}
inline float NedCoordinates::east() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.NedCoordinates.east)
  return east_;
}
inline void NedCoordinates::set_east(float value) {
  
  east_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.NedCoordinates.east)
}

// float down = 3;
inline void NedCoordinates::clear_down() {
  down_ = 0;
}
inline float NedCoordinates::down() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.NedCoordinates.down)
  return down_;
}
inline void NedCoordinates::set_down(float value) {
  
  down_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.NedCoordinates.down)
}

// -------------------------------------------------------------------

// Orientation

// float roll = 1;
inline void Orientation::clear_roll() {
  roll_ = 0;
}
inline float Orientation::roll() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.Orientation.roll)
  return roll_;
}
inline void Orientation::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.Orientation.roll)
}

// float pitch = 2;
inline void Orientation::clear_pitch() {
  pitch_ = 0;
}
inline float Orientation::pitch() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.Orientation.pitch)
  return pitch_;
}
inline void Orientation::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.Orientation.pitch)
}

// float yaw = 3;
inline void Orientation::clear_yaw() {
  yaw_ = 0;
}
inline float Orientation::yaw() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.Orientation.yaw)
  return yaw_;
}
inline void Orientation::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.Orientation.yaw)
}

// -------------------------------------------------------------------

// Position

// .Flightplan.Messages.GeoCoordinates geo = 1;
inline bool Position::has_geo() const {
  return CoordType_case() == kGeo;
}
inline void Position::set_has_geo() {
  _oneof_case_[0] = kGeo;
}
inline void Position::clear_geo() {
  if (has_geo()) {
    delete CoordType_.geo_;
    clear_has_CoordType();
  }
}
inline ::Flightplan::Messages::GeoCoordinates* Position::release_geo() {
  // @@protoc_insertion_point(field_release:Flightplan.Messages.Position.geo)
  if (has_geo()) {
    clear_has_CoordType();
      ::Flightplan::Messages::GeoCoordinates* temp = CoordType_.geo_;
    CoordType_.geo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Flightplan::Messages::GeoCoordinates& Position::geo() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.Position.geo)
  return has_geo()
      ? *CoordType_.geo_
      : *reinterpret_cast< ::Flightplan::Messages::GeoCoordinates*>(&::Flightplan::Messages::_GeoCoordinates_default_instance_);
}
inline ::Flightplan::Messages::GeoCoordinates* Position::mutable_geo() {
  if (!has_geo()) {
    clear_CoordType();
    set_has_geo();
    CoordType_.geo_ = CreateMaybeMessage< ::Flightplan::Messages::GeoCoordinates >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Flightplan.Messages.Position.geo)
  return CoordType_.geo_;
}

// .Flightplan.Messages.NedCoordinates ned = 2;
inline bool Position::has_ned() const {
  return CoordType_case() == kNed;
}
inline void Position::set_has_ned() {
  _oneof_case_[0] = kNed;
}
inline void Position::clear_ned() {
  if (has_ned()) {
    delete CoordType_.ned_;
    clear_has_CoordType();
  }
}
inline ::Flightplan::Messages::NedCoordinates* Position::release_ned() {
  // @@protoc_insertion_point(field_release:Flightplan.Messages.Position.ned)
  if (has_ned()) {
    clear_has_CoordType();
      ::Flightplan::Messages::NedCoordinates* temp = CoordType_.ned_;
    CoordType_.ned_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Flightplan::Messages::NedCoordinates& Position::ned() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.Position.ned)
  return has_ned()
      ? *CoordType_.ned_
      : *reinterpret_cast< ::Flightplan::Messages::NedCoordinates*>(&::Flightplan::Messages::_NedCoordinates_default_instance_);
}
inline ::Flightplan::Messages::NedCoordinates* Position::mutable_ned() {
  if (!has_ned()) {
    clear_CoordType();
    set_has_ned();
    CoordType_.ned_ = CreateMaybeMessage< ::Flightplan::Messages::NedCoordinates >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Flightplan.Messages.Position.ned)
  return CoordType_.ned_;
}

inline bool Position::has_CoordType() const {
  return CoordType_case() != COORDTYPE_NOT_SET;
}
inline void Position::clear_has_CoordType() {
  _oneof_case_[0] = COORDTYPE_NOT_SET;
}
inline Position::CoordTypeCase Position::CoordType_case() const {
  return Position::CoordTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// View

// .Flightplan.Messages.Position position = 1;
inline bool View::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline void View::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::Flightplan::Messages::Position& View::position() const {
  const ::Flightplan::Messages::Position* p = position_;
  // @@protoc_insertion_point(field_get:Flightplan.Messages.View.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::Flightplan::Messages::Position*>(
      &::Flightplan::Messages::_Position_default_instance_);
}
inline ::Flightplan::Messages::Position* View::release_position() {
  // @@protoc_insertion_point(field_release:Flightplan.Messages.View.position)
  
  ::Flightplan::Messages::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Flightplan::Messages::Position* View::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Flightplan::Messages::Position>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Flightplan.Messages.View.position)
  return position_;
}
inline void View::set_allocated_position(::Flightplan::Messages::Position* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Flightplan.Messages.View.position)
}

// .Flightplan.Messages.Orientation orientation = 2;
inline bool View::has_orientation() const {
  return this != internal_default_instance() && orientation_ != nullptr;
}
inline void View::clear_orientation() {
  if (GetArenaNoVirtual() == nullptr && orientation_ != nullptr) {
    delete orientation_;
  }
  orientation_ = nullptr;
}
inline const ::Flightplan::Messages::Orientation& View::orientation() const {
  const ::Flightplan::Messages::Orientation* p = orientation_;
  // @@protoc_insertion_point(field_get:Flightplan.Messages.View.orientation)
  return p != nullptr ? *p : *reinterpret_cast<const ::Flightplan::Messages::Orientation*>(
      &::Flightplan::Messages::_Orientation_default_instance_);
}
inline ::Flightplan::Messages::Orientation* View::release_orientation() {
  // @@protoc_insertion_point(field_release:Flightplan.Messages.View.orientation)
  
  ::Flightplan::Messages::Orientation* temp = orientation_;
  orientation_ = nullptr;
  return temp;
}
inline ::Flightplan::Messages::Orientation* View::mutable_orientation() {
  
  if (orientation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Flightplan::Messages::Orientation>(GetArenaNoVirtual());
    orientation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Flightplan.Messages.View.orientation)
  return orientation_;
}
inline void View::set_allocated_orientation(::Flightplan::Messages::Orientation* orientation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete orientation_;
  }
  if (orientation) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      orientation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    
  } else {
    
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:Flightplan.Messages.View.orientation)
}

// float zoom_factor = 3;
inline void View::clear_zoom_factor() {
  zoom_factor_ = 0;
}
inline float View::zoom_factor() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.View.zoom_factor)
  return zoom_factor_;
}
inline void View::set_zoom_factor(float value) {
  
  zoom_factor_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.View.zoom_factor)
}

// -------------------------------------------------------------------

// ViewMode

// .Flightplan.Enums.ViewMode.Yaw.Enum yaw = 1;
inline void ViewMode::clear_yaw() {
  yaw_ = 0;
}
inline ::Flightplan::Enums::ViewMode::Yaw::Enum ViewMode::yaw() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.ViewMode.yaw)
  return static_cast< ::Flightplan::Enums::ViewMode::Yaw::Enum >(yaw_);
}
inline void ViewMode::set_yaw(::Flightplan::Enums::ViewMode::Yaw::Enum value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.ViewMode.yaw)
}

// .Flightplan.Enums.ViewMode.Pitch.Enum pitch = 2;
inline void ViewMode::clear_pitch() {
  pitch_ = 0;
}
inline ::Flightplan::Enums::ViewMode::Pitch::Enum ViewMode::pitch() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.ViewMode.pitch)
  return static_cast< ::Flightplan::Enums::ViewMode::Pitch::Enum >(pitch_);
}
inline void ViewMode::set_pitch(::Flightplan::Enums::ViewMode::Pitch::Enum value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.ViewMode.pitch)
}

// .Flightplan.Enums.ViewMode.Roll.Enum roll = 3;
inline void ViewMode::clear_roll() {
  roll_ = 0;
}
inline ::Flightplan::Enums::ViewMode::Roll::Enum ViewMode::roll() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.ViewMode.roll)
  return static_cast< ::Flightplan::Enums::ViewMode::Roll::Enum >(roll_);
}
inline void ViewMode::set_roll(::Flightplan::Enums::ViewMode::Roll::Enum value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.ViewMode.roll)
}

// .Flightplan.Enums.ViewMode.Zoom.Enum zoom = 4;
inline void ViewMode::clear_zoom() {
  zoom_ = 0;
}
inline ::Flightplan::Enums::ViewMode::Zoom::Enum ViewMode::zoom() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.ViewMode.zoom)
  return static_cast< ::Flightplan::Enums::ViewMode::Zoom::Enum >(zoom_);
}
inline void ViewMode::set_zoom(::Flightplan::Enums::ViewMode::Zoom::Enum value) {
  
  zoom_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.ViewMode.zoom)
}

// .Flightplan.Messages.Position poi_position = 5;
inline bool ViewMode::has_poi_position() const {
  return this != internal_default_instance() && poi_position_ != nullptr;
}
inline void ViewMode::clear_poi_position() {
  if (GetArenaNoVirtual() == nullptr && poi_position_ != nullptr) {
    delete poi_position_;
  }
  poi_position_ = nullptr;
}
inline const ::Flightplan::Messages::Position& ViewMode::poi_position() const {
  const ::Flightplan::Messages::Position* p = poi_position_;
  // @@protoc_insertion_point(field_get:Flightplan.Messages.ViewMode.poi_position)
  return p != nullptr ? *p : *reinterpret_cast<const ::Flightplan::Messages::Position*>(
      &::Flightplan::Messages::_Position_default_instance_);
}
inline ::Flightplan::Messages::Position* ViewMode::release_poi_position() {
  // @@protoc_insertion_point(field_release:Flightplan.Messages.ViewMode.poi_position)
  
  ::Flightplan::Messages::Position* temp = poi_position_;
  poi_position_ = nullptr;
  return temp;
}
inline ::Flightplan::Messages::Position* ViewMode::mutable_poi_position() {
  
  if (poi_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Flightplan::Messages::Position>(GetArenaNoVirtual());
    poi_position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Flightplan.Messages.ViewMode.poi_position)
  return poi_position_;
}
inline void ViewMode::set_allocated_poi_position(::Flightplan::Messages::Position* poi_position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete poi_position_;
  }
  if (poi_position) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      poi_position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, poi_position, submessage_arena);
    }
    
  } else {
    
  }
  poi_position_ = poi_position;
  // @@protoc_insertion_point(field_set_allocated:Flightplan.Messages.ViewMode.poi_position)
}

// -------------------------------------------------------------------

// Waypoint

// .Flightplan.Messages.View view = 1;
inline bool Waypoint::has_view() const {
  return this != internal_default_instance() && view_ != nullptr;
}
inline void Waypoint::clear_view() {
  if (GetArenaNoVirtual() == nullptr && view_ != nullptr) {
    delete view_;
  }
  view_ = nullptr;
}
inline const ::Flightplan::Messages::View& Waypoint::view() const {
  const ::Flightplan::Messages::View* p = view_;
  // @@protoc_insertion_point(field_get:Flightplan.Messages.Waypoint.view)
  return p != nullptr ? *p : *reinterpret_cast<const ::Flightplan::Messages::View*>(
      &::Flightplan::Messages::_View_default_instance_);
}
inline ::Flightplan::Messages::View* Waypoint::release_view() {
  // @@protoc_insertion_point(field_release:Flightplan.Messages.Waypoint.view)
  
  ::Flightplan::Messages::View* temp = view_;
  view_ = nullptr;
  return temp;
}
inline ::Flightplan::Messages::View* Waypoint::mutable_view() {
  
  if (view_ == nullptr) {
    auto* p = CreateMaybeMessage<::Flightplan::Messages::View>(GetArenaNoVirtual());
    view_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Flightplan.Messages.Waypoint.view)
  return view_;
}
inline void Waypoint::set_allocated_view(::Flightplan::Messages::View* view) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete view_;
  }
  if (view) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      view = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, view, submessage_arena);
    }
    
  } else {
    
  }
  view_ = view;
  // @@protoc_insertion_point(field_set_allocated:Flightplan.Messages.Waypoint.view)
}

// .Flightplan.Messages.ViewMode view_mode = 2;
inline bool Waypoint::has_view_mode() const {
  return this != internal_default_instance() && view_mode_ != nullptr;
}
inline void Waypoint::clear_view_mode() {
  if (GetArenaNoVirtual() == nullptr && view_mode_ != nullptr) {
    delete view_mode_;
  }
  view_mode_ = nullptr;
}
inline const ::Flightplan::Messages::ViewMode& Waypoint::view_mode() const {
  const ::Flightplan::Messages::ViewMode* p = view_mode_;
  // @@protoc_insertion_point(field_get:Flightplan.Messages.Waypoint.view_mode)
  return p != nullptr ? *p : *reinterpret_cast<const ::Flightplan::Messages::ViewMode*>(
      &::Flightplan::Messages::_ViewMode_default_instance_);
}
inline ::Flightplan::Messages::ViewMode* Waypoint::release_view_mode() {
  // @@protoc_insertion_point(field_release:Flightplan.Messages.Waypoint.view_mode)
  
  ::Flightplan::Messages::ViewMode* temp = view_mode_;
  view_mode_ = nullptr;
  return temp;
}
inline ::Flightplan::Messages::ViewMode* Waypoint::mutable_view_mode() {
  
  if (view_mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::Flightplan::Messages::ViewMode>(GetArenaNoVirtual());
    view_mode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Flightplan.Messages.Waypoint.view_mode)
  return view_mode_;
}
inline void Waypoint::set_allocated_view_mode(::Flightplan::Messages::ViewMode* view_mode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete view_mode_;
  }
  if (view_mode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      view_mode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, view_mode, submessage_arena);
    }
    
  } else {
    
  }
  view_mode_ = view_mode;
  // @@protoc_insertion_point(field_set_allocated:Flightplan.Messages.Waypoint.view_mode)
}

// .Flightplan.Enums.ValidationType.Enum validation_type = 3;
inline void Waypoint::clear_validation_type() {
  validation_type_ = 0;
}
inline ::Flightplan::Enums::ValidationType::Enum Waypoint::validation_type() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.Waypoint.validation_type)
  return static_cast< ::Flightplan::Enums::ValidationType::Enum >(validation_type_);
}
inline void Waypoint::set_validation_type(::Flightplan::Enums::ValidationType::Enum value) {
  
  validation_type_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.Waypoint.validation_type)
}

// float validation_radius = 4;
inline void Waypoint::clear_validation_radius() {
  validation_radius_ = 0;
}
inline float Waypoint::validation_radius() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.Waypoint.validation_radius)
  return validation_radius_;
}
inline void Waypoint::set_validation_radius(float value) {
  
  validation_radius_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.Waypoint.validation_radius)
}

// float speed = 5;
inline void Waypoint::clear_speed() {
  speed_ = 0;
}
inline float Waypoint::speed() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.Waypoint.speed)
  return speed_;
}
inline void Waypoint::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.Waypoint.speed)
}

// int32 original_id = 6;
inline void Waypoint::clear_original_id() {
  original_id_ = 0;
}
inline ::google::protobuf::int32 Waypoint::original_id() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.Waypoint.original_id)
  return original_id_;
}
inline void Waypoint::set_original_id(::google::protobuf::int32 value) {
  
  original_id_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.Waypoint.original_id)
}

// -------------------------------------------------------------------

// WaypointPath

// repeated .Flightplan.Messages.Waypoint waypoints = 1;
inline int WaypointPath::waypoints_size() const {
  return waypoints_.size();
}
inline void WaypointPath::clear_waypoints() {
  waypoints_.Clear();
}
inline ::Flightplan::Messages::Waypoint* WaypointPath::mutable_waypoints(int index) {
  // @@protoc_insertion_point(field_mutable:Flightplan.Messages.WaypointPath.waypoints)
  return waypoints_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Flightplan::Messages::Waypoint >*
WaypointPath::mutable_waypoints() {
  // @@protoc_insertion_point(field_mutable_list:Flightplan.Messages.WaypointPath.waypoints)
  return &waypoints_;
}
inline const ::Flightplan::Messages::Waypoint& WaypointPath::waypoints(int index) const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.WaypointPath.waypoints)
  return waypoints_.Get(index);
}
inline ::Flightplan::Messages::Waypoint* WaypointPath::add_waypoints() {
  // @@protoc_insertion_point(field_add:Flightplan.Messages.WaypointPath.waypoints)
  return waypoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Flightplan::Messages::Waypoint >&
WaypointPath::waypoints() const {
  // @@protoc_insertion_point(field_list:Flightplan.Messages.WaypointPath.waypoints)
  return waypoints_;
}

// uint32 start_at_index = 2;
inline void WaypointPath::clear_start_at_index() {
  start_at_index_ = 0u;
}
inline ::google::protobuf::uint32 WaypointPath::start_at_index() const {
  // @@protoc_insertion_point(field_get:Flightplan.Messages.WaypointPath.start_at_index)
  return start_at_index_;
}
inline void WaypointPath::set_start_at_index(::google::protobuf::uint32 value) {
  
  start_at_index_ = value;
  // @@protoc_insertion_point(field_set:Flightplan.Messages.WaypointPath.start_at_index)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Messages
}  // namespace Flightplan

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_flightplan_2fflightplan_2eproto
