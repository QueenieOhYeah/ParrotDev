// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: guidance/flightplan.proto

#ifndef PROTOBUF_INCLUDED_guidance_2fflightplan_2eproto
#define PROTOBUF_INCLUDED_guidance_2fflightplan_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "flightplan/flightplan.pb.h"
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_guidance_2fflightplan_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_guidance_2fflightplan_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_guidance_2fflightplan_2eproto();
namespace Guidance {
namespace Flightplan {
namespace Messages {
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Index;
class IndexDefaultTypeInternal;
extern IndexDefaultTypeInternal _Index_default_instance_;
class InsertWaypoint;
class InsertWaypointDefaultTypeInternal;
extern InsertWaypointDefaultTypeInternal _InsertWaypoint_default_instance_;
class ReplaceWaypoint;
class ReplaceWaypointDefaultTypeInternal;
extern ReplaceWaypointDefaultTypeInternal _ReplaceWaypoint_default_instance_;
class WaypointSkipped;
class WaypointSkippedDefaultTypeInternal;
extern WaypointSkippedDefaultTypeInternal _WaypointSkipped_default_instance_;
class WaypointValidated;
class WaypointValidatedDefaultTypeInternal;
extern WaypointValidatedDefaultTypeInternal _WaypointValidated_default_instance_;
}  // namespace Messages
}  // namespace Flightplan
}  // namespace Guidance
namespace google {
namespace protobuf {
template<> ::Guidance::Flightplan::Messages::Command* Arena::CreateMaybeMessage<::Guidance::Flightplan::Messages::Command>(Arena*);
template<> ::Guidance::Flightplan::Messages::Config* Arena::CreateMaybeMessage<::Guidance::Flightplan::Messages::Config>(Arena*);
template<> ::Guidance::Flightplan::Messages::Event* Arena::CreateMaybeMessage<::Guidance::Flightplan::Messages::Event>(Arena*);
template<> ::Guidance::Flightplan::Messages::Index* Arena::CreateMaybeMessage<::Guidance::Flightplan::Messages::Index>(Arena*);
template<> ::Guidance::Flightplan::Messages::InsertWaypoint* Arena::CreateMaybeMessage<::Guidance::Flightplan::Messages::InsertWaypoint>(Arena*);
template<> ::Guidance::Flightplan::Messages::ReplaceWaypoint* Arena::CreateMaybeMessage<::Guidance::Flightplan::Messages::ReplaceWaypoint>(Arena*);
template<> ::Guidance::Flightplan::Messages::WaypointSkipped* Arena::CreateMaybeMessage<::Guidance::Flightplan::Messages::WaypointSkipped>(Arena*);
template<> ::Guidance::Flightplan::Messages::WaypointValidated* Arena::CreateMaybeMessage<::Guidance::Flightplan::Messages::WaypointValidated>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Guidance {
namespace Flightplan {
namespace Messages {

// ===================================================================

class InsertWaypoint :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Flightplan.Messages.InsertWaypoint) */ {
 public:
  InsertWaypoint();
  virtual ~InsertWaypoint();

  InsertWaypoint(const InsertWaypoint& from);

  inline InsertWaypoint& operator=(const InsertWaypoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InsertWaypoint(InsertWaypoint&& from) noexcept
    : InsertWaypoint() {
    *this = ::std::move(from);
  }

  inline InsertWaypoint& operator=(InsertWaypoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const InsertWaypoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InsertWaypoint* internal_default_instance() {
    return reinterpret_cast<const InsertWaypoint*>(
               &_InsertWaypoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(InsertWaypoint* other);
  friend void swap(InsertWaypoint& a, InsertWaypoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InsertWaypoint* New() const final {
    return CreateMaybeMessage<InsertWaypoint>(nullptr);
  }

  InsertWaypoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InsertWaypoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InsertWaypoint& from);
  void MergeFrom(const InsertWaypoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertWaypoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Flightplan.Messages.Waypoint waypoint = 1;
  bool has_waypoint() const;
  void clear_waypoint();
  static const int kWaypointFieldNumber = 1;
  const ::Flightplan::Messages::Waypoint& waypoint() const;
  ::Flightplan::Messages::Waypoint* release_waypoint();
  ::Flightplan::Messages::Waypoint* mutable_waypoint();
  void set_allocated_waypoint(::Flightplan::Messages::Waypoint* waypoint);

  // int32 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Guidance.Flightplan.Messages.InsertWaypoint)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Flightplan::Messages::Waypoint* waypoint_;
  ::google::protobuf::int32 index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2fflightplan_2eproto;
};
// -------------------------------------------------------------------

class ReplaceWaypoint :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Flightplan.Messages.ReplaceWaypoint) */ {
 public:
  ReplaceWaypoint();
  virtual ~ReplaceWaypoint();

  ReplaceWaypoint(const ReplaceWaypoint& from);

  inline ReplaceWaypoint& operator=(const ReplaceWaypoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReplaceWaypoint(ReplaceWaypoint&& from) noexcept
    : ReplaceWaypoint() {
    *this = ::std::move(from);
  }

  inline ReplaceWaypoint& operator=(ReplaceWaypoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ReplaceWaypoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplaceWaypoint* internal_default_instance() {
    return reinterpret_cast<const ReplaceWaypoint*>(
               &_ReplaceWaypoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ReplaceWaypoint* other);
  friend void swap(ReplaceWaypoint& a, ReplaceWaypoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReplaceWaypoint* New() const final {
    return CreateMaybeMessage<ReplaceWaypoint>(nullptr);
  }

  ReplaceWaypoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReplaceWaypoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReplaceWaypoint& from);
  void MergeFrom(const ReplaceWaypoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplaceWaypoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Flightplan.Messages.Waypoint waypoint = 1;
  bool has_waypoint() const;
  void clear_waypoint();
  static const int kWaypointFieldNumber = 1;
  const ::Flightplan::Messages::Waypoint& waypoint() const;
  ::Flightplan::Messages::Waypoint* release_waypoint();
  ::Flightplan::Messages::Waypoint* mutable_waypoint();
  void set_allocated_waypoint(::Flightplan::Messages::Waypoint* waypoint);

  // int32 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // bool keep_original_id = 3;
  void clear_keep_original_id();
  static const int kKeepOriginalIdFieldNumber = 3;
  bool keep_original_id() const;
  void set_keep_original_id(bool value);

  // @@protoc_insertion_point(class_scope:Guidance.Flightplan.Messages.ReplaceWaypoint)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Flightplan::Messages::Waypoint* waypoint_;
  ::google::protobuf::int32 index_;
  bool keep_original_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2fflightplan_2eproto;
};
// -------------------------------------------------------------------

class Index :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Flightplan.Messages.Index) */ {
 public:
  Index();
  virtual ~Index();

  Index(const Index& from);

  inline Index& operator=(const Index& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Index(Index&& from) noexcept
    : Index() {
    *this = ::std::move(from);
  }

  inline Index& operator=(Index&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Index& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Index* internal_default_instance() {
    return reinterpret_cast<const Index*>(
               &_Index_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Index* other);
  friend void swap(Index& a, Index& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Index* New() const final {
    return CreateMaybeMessage<Index>(nullptr);
  }

  Index* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Index>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Index& from);
  void MergeFrom(const Index& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Index* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Guidance.Flightplan.Messages.Index)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2fflightplan_2eproto;
};
// -------------------------------------------------------------------

class WaypointValidated :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Flightplan.Messages.WaypointValidated) */ {
 public:
  WaypointValidated();
  virtual ~WaypointValidated();

  WaypointValidated(const WaypointValidated& from);

  inline WaypointValidated& operator=(const WaypointValidated& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaypointValidated(WaypointValidated&& from) noexcept
    : WaypointValidated() {
    *this = ::std::move(from);
  }

  inline WaypointValidated& operator=(WaypointValidated&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WaypointValidated& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaypointValidated* internal_default_instance() {
    return reinterpret_cast<const WaypointValidated*>(
               &_WaypointValidated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(WaypointValidated* other);
  friend void swap(WaypointValidated& a, WaypointValidated& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaypointValidated* New() const final {
    return CreateMaybeMessage<WaypointValidated>(nullptr);
  }

  WaypointValidated* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaypointValidated>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaypointValidated& from);
  void MergeFrom(const WaypointValidated& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaypointValidated* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 current_waypoint_id = 1;
  void clear_current_waypoint_id();
  static const int kCurrentWaypointIdFieldNumber = 1;
  ::google::protobuf::int32 current_waypoint_id() const;
  void set_current_waypoint_id(::google::protobuf::int32 value);

  // int32 waypoint_id = 2;
  void clear_waypoint_id();
  static const int kWaypointIdFieldNumber = 2;
  ::google::protobuf::int32 waypoint_id() const;
  void set_waypoint_id(::google::protobuf::int32 value);

  // int32 original_id = 3;
  void clear_original_id();
  static const int kOriginalIdFieldNumber = 3;
  ::google::protobuf::int32 original_id() const;
  void set_original_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Guidance.Flightplan.Messages.WaypointValidated)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 current_waypoint_id_;
  ::google::protobuf::int32 waypoint_id_;
  ::google::protobuf::int32 original_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2fflightplan_2eproto;
};
// -------------------------------------------------------------------

class WaypointSkipped :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Flightplan.Messages.WaypointSkipped) */ {
 public:
  WaypointSkipped();
  virtual ~WaypointSkipped();

  WaypointSkipped(const WaypointSkipped& from);

  inline WaypointSkipped& operator=(const WaypointSkipped& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaypointSkipped(WaypointSkipped&& from) noexcept
    : WaypointSkipped() {
    *this = ::std::move(from);
  }

  inline WaypointSkipped& operator=(WaypointSkipped&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WaypointSkipped& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaypointSkipped* internal_default_instance() {
    return reinterpret_cast<const WaypointSkipped*>(
               &_WaypointSkipped_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(WaypointSkipped* other);
  friend void swap(WaypointSkipped& a, WaypointSkipped& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaypointSkipped* New() const final {
    return CreateMaybeMessage<WaypointSkipped>(nullptr);
  }

  WaypointSkipped* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaypointSkipped>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaypointSkipped& from);
  void MergeFrom(const WaypointSkipped& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaypointSkipped* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 current_waypoint_id = 1;
  void clear_current_waypoint_id();
  static const int kCurrentWaypointIdFieldNumber = 1;
  ::google::protobuf::int32 current_waypoint_id() const;
  void set_current_waypoint_id(::google::protobuf::int32 value);

  // int32 skipped_waypoint_id = 2;
  void clear_skipped_waypoint_id();
  static const int kSkippedWaypointIdFieldNumber = 2;
  ::google::protobuf::int32 skipped_waypoint_id() const;
  void set_skipped_waypoint_id(::google::protobuf::int32 value);

  // int32 original_id = 3;
  void clear_original_id();
  static const int kOriginalIdFieldNumber = 3;
  ::google::protobuf::int32 original_id() const;
  void set_original_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Guidance.Flightplan.Messages.WaypointSkipped)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 current_waypoint_id_;
  ::google::protobuf::int32 skipped_waypoint_id_;
  ::google::protobuf::int32 original_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2fflightplan_2eproto;
};
// -------------------------------------------------------------------

class Config :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Flightplan.Messages.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Config& default_instance();

  enum OptionalMaxHorizontalSpeedCase {
    kMaxHorizontalSpeed = 2,
    OPTIONAL_MAX_HORIZONTAL_SPEED_NOT_SET = 0,
  };

  enum OptionalMaxVerticalSpeedCase {
    kMaxVerticalSpeed = 3,
    OPTIONAL_MAX_VERTICAL_SPEED_NOT_SET = 0,
  };

  enum OptionalMaxYawSpeedCase {
    kMaxYawSpeed = 4,
    OPTIONAL_MAX_YAW_SPEED_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Config* other);
  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const final {
    return CreateMaybeMessage<Config>(nullptr);
  }

  Config* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Flightplan.Messages.WaypointPath waypoint_path = 1;
  bool has_waypoint_path() const;
  void clear_waypoint_path();
  static const int kWaypointPathFieldNumber = 1;
  const ::Flightplan::Messages::WaypointPath& waypoint_path() const;
  ::Flightplan::Messages::WaypointPath* release_waypoint_path();
  ::Flightplan::Messages::WaypointPath* mutable_waypoint_path();
  void set_allocated_waypoint_path(::Flightplan::Messages::WaypointPath* waypoint_path);

  // float max_horizontal_speed = 2;
  private:
  bool has_max_horizontal_speed() const;
  public:
  void clear_max_horizontal_speed();
  static const int kMaxHorizontalSpeedFieldNumber = 2;
  float max_horizontal_speed() const;
  void set_max_horizontal_speed(float value);

  // float max_vertical_speed = 3;
  private:
  bool has_max_vertical_speed() const;
  public:
  void clear_max_vertical_speed();
  static const int kMaxVerticalSpeedFieldNumber = 3;
  float max_vertical_speed() const;
  void set_max_vertical_speed(float value);

  // float max_yaw_speed = 4;
  private:
  bool has_max_yaw_speed() const;
  public:
  void clear_max_yaw_speed();
  static const int kMaxYawSpeedFieldNumber = 4;
  float max_yaw_speed() const;
  void set_max_yaw_speed(float value);

  void clear_optional_max_horizontal_speed();
  OptionalMaxHorizontalSpeedCase optional_max_horizontal_speed_case() const;
  void clear_optional_max_vertical_speed();
  OptionalMaxVerticalSpeedCase optional_max_vertical_speed_case() const;
  void clear_optional_max_yaw_speed();
  OptionalMaxYawSpeedCase optional_max_yaw_speed_case() const;
  // @@protoc_insertion_point(class_scope:Guidance.Flightplan.Messages.Config)
 private:
  class HasBitSetters;
  void set_has_max_horizontal_speed();
  void set_has_max_vertical_speed();
  void set_has_max_yaw_speed();

  inline bool has_optional_max_horizontal_speed() const;
  inline void clear_has_optional_max_horizontal_speed();

  inline bool has_optional_max_vertical_speed() const;
  inline void clear_has_optional_max_vertical_speed();

  inline bool has_optional_max_yaw_speed() const;
  inline void clear_has_optional_max_yaw_speed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Flightplan::Messages::WaypointPath* waypoint_path_;
  union OptionalMaxHorizontalSpeedUnion {
    OptionalMaxHorizontalSpeedUnion() {}
    float max_horizontal_speed_;
  } optional_max_horizontal_speed_;
  union OptionalMaxVerticalSpeedUnion {
    OptionalMaxVerticalSpeedUnion() {}
    float max_vertical_speed_;
  } optional_max_vertical_speed_;
  union OptionalMaxYawSpeedUnion {
    OptionalMaxYawSpeedUnion() {}
    float max_yaw_speed_;
  } optional_max_yaw_speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[3];

  friend struct ::TableStruct_guidance_2fflightplan_2eproto;
};
// -------------------------------------------------------------------

class Command :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Flightplan.Messages.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command& default_instance();

  enum IdCase {
    kPause = 1,
    kResume = 2,
    kInsertWaypoint = 3,
    kRemoveWaypoint = 4,
    kReplaceWaypoint = 5,
    kSetCurrentIndex = 6,
    ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Empty pause = 1;
  bool has_pause() const;
  void clear_pause();
  static const int kPauseFieldNumber = 1;
  const ::google::protobuf::Empty& pause() const;
  ::google::protobuf::Empty* release_pause();
  ::google::protobuf::Empty* mutable_pause();
  void set_allocated_pause(::google::protobuf::Empty* pause);

  // .google.protobuf.Empty resume = 2;
  bool has_resume() const;
  void clear_resume();
  static const int kResumeFieldNumber = 2;
  const ::google::protobuf::Empty& resume() const;
  ::google::protobuf::Empty* release_resume();
  ::google::protobuf::Empty* mutable_resume();
  void set_allocated_resume(::google::protobuf::Empty* resume);

  // .Guidance.Flightplan.Messages.InsertWaypoint insert_waypoint = 3;
  bool has_insert_waypoint() const;
  void clear_insert_waypoint();
  static const int kInsertWaypointFieldNumber = 3;
  const ::Guidance::Flightplan::Messages::InsertWaypoint& insert_waypoint() const;
  ::Guidance::Flightplan::Messages::InsertWaypoint* release_insert_waypoint();
  ::Guidance::Flightplan::Messages::InsertWaypoint* mutable_insert_waypoint();
  void set_allocated_insert_waypoint(::Guidance::Flightplan::Messages::InsertWaypoint* insert_waypoint);

  // int32 remove_waypoint = 4;
  private:
  bool has_remove_waypoint() const;
  public:
  void clear_remove_waypoint();
  static const int kRemoveWaypointFieldNumber = 4;
  ::google::protobuf::int32 remove_waypoint() const;
  void set_remove_waypoint(::google::protobuf::int32 value);

  // .Guidance.Flightplan.Messages.ReplaceWaypoint replace_waypoint = 5;
  bool has_replace_waypoint() const;
  void clear_replace_waypoint();
  static const int kReplaceWaypointFieldNumber = 5;
  const ::Guidance::Flightplan::Messages::ReplaceWaypoint& replace_waypoint() const;
  ::Guidance::Flightplan::Messages::ReplaceWaypoint* release_replace_waypoint();
  ::Guidance::Flightplan::Messages::ReplaceWaypoint* mutable_replace_waypoint();
  void set_allocated_replace_waypoint(::Guidance::Flightplan::Messages::ReplaceWaypoint* replace_waypoint);

  // uint32 set_current_index = 6;
  private:
  bool has_set_current_index() const;
  public:
  void clear_set_current_index();
  static const int kSetCurrentIndexFieldNumber = 6;
  ::google::protobuf::uint32 set_current_index() const;
  void set_set_current_index(::google::protobuf::uint32 value);

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:Guidance.Flightplan.Messages.Command)
 private:
  class HasBitSetters;
  void set_has_pause();
  void set_has_resume();
  void set_has_insert_waypoint();
  void set_has_remove_waypoint();
  void set_has_replace_waypoint();
  void set_has_set_current_index();

  inline bool has_id() const;
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    ::google::protobuf::Empty* pause_;
    ::google::protobuf::Empty* resume_;
    ::Guidance::Flightplan::Messages::InsertWaypoint* insert_waypoint_;
    ::google::protobuf::int32 remove_waypoint_;
    ::Guidance::Flightplan::Messages::ReplaceWaypoint* replace_waypoint_;
    ::google::protobuf::uint32 set_current_index_;
  } id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_guidance_2fflightplan_2eproto;
};
// -------------------------------------------------------------------

class Event :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Flightplan.Messages.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Event& default_instance();

  enum IdCase {
    kDone = 1,
    kWaypointValidated = 2,
    kWaypointSkipped = 3,
    kChanged = 4,
    kRejected = 5,
    kBlockageDetected = 6,
    ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(nullptr);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Empty done = 1;
  bool has_done() const;
  void clear_done();
  static const int kDoneFieldNumber = 1;
  const ::google::protobuf::Empty& done() const;
  ::google::protobuf::Empty* release_done();
  ::google::protobuf::Empty* mutable_done();
  void set_allocated_done(::google::protobuf::Empty* done);

  // .Guidance.Flightplan.Messages.WaypointValidated waypoint_validated = 2;
  bool has_waypoint_validated() const;
  void clear_waypoint_validated();
  static const int kWaypointValidatedFieldNumber = 2;
  const ::Guidance::Flightplan::Messages::WaypointValidated& waypoint_validated() const;
  ::Guidance::Flightplan::Messages::WaypointValidated* release_waypoint_validated();
  ::Guidance::Flightplan::Messages::WaypointValidated* mutable_waypoint_validated();
  void set_allocated_waypoint_validated(::Guidance::Flightplan::Messages::WaypointValidated* waypoint_validated);

  // .Guidance.Flightplan.Messages.WaypointSkipped waypoint_skipped = 3;
  bool has_waypoint_skipped() const;
  void clear_waypoint_skipped();
  static const int kWaypointSkippedFieldNumber = 3;
  const ::Guidance::Flightplan::Messages::WaypointSkipped& waypoint_skipped() const;
  ::Guidance::Flightplan::Messages::WaypointSkipped* release_waypoint_skipped();
  ::Guidance::Flightplan::Messages::WaypointSkipped* mutable_waypoint_skipped();
  void set_allocated_waypoint_skipped(::Guidance::Flightplan::Messages::WaypointSkipped* waypoint_skipped);

  // .Flightplan.Messages.WaypointPath changed = 4;
  bool has_changed() const;
  void clear_changed();
  static const int kChangedFieldNumber = 4;
  const ::Flightplan::Messages::WaypointPath& changed() const;
  ::Flightplan::Messages::WaypointPath* release_changed();
  ::Flightplan::Messages::WaypointPath* mutable_changed();
  void set_allocated_changed(::Flightplan::Messages::WaypointPath* changed);

  // .google.protobuf.Empty rejected = 5;
  bool has_rejected() const;
  void clear_rejected();
  static const int kRejectedFieldNumber = 5;
  const ::google::protobuf::Empty& rejected() const;
  ::google::protobuf::Empty* release_rejected();
  ::google::protobuf::Empty* mutable_rejected();
  void set_allocated_rejected(::google::protobuf::Empty* rejected);

  // .google.protobuf.Empty blockage_detected = 6;
  bool has_blockage_detected() const;
  void clear_blockage_detected();
  static const int kBlockageDetectedFieldNumber = 6;
  const ::google::protobuf::Empty& blockage_detected() const;
  ::google::protobuf::Empty* release_blockage_detected();
  ::google::protobuf::Empty* mutable_blockage_detected();
  void set_allocated_blockage_detected(::google::protobuf::Empty* blockage_detected);

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:Guidance.Flightplan.Messages.Event)
 private:
  class HasBitSetters;
  void set_has_done();
  void set_has_waypoint_validated();
  void set_has_waypoint_skipped();
  void set_has_changed();
  void set_has_rejected();
  void set_has_blockage_detected();

  inline bool has_id() const;
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    ::google::protobuf::Empty* done_;
    ::Guidance::Flightplan::Messages::WaypointValidated* waypoint_validated_;
    ::Guidance::Flightplan::Messages::WaypointSkipped* waypoint_skipped_;
    ::Flightplan::Messages::WaypointPath* changed_;
    ::google::protobuf::Empty* rejected_;
    ::google::protobuf::Empty* blockage_detected_;
  } id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_guidance_2fflightplan_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InsertWaypoint

// .Flightplan.Messages.Waypoint waypoint = 1;
inline bool InsertWaypoint::has_waypoint() const {
  return this != internal_default_instance() && waypoint_ != nullptr;
}
inline const ::Flightplan::Messages::Waypoint& InsertWaypoint::waypoint() const {
  const ::Flightplan::Messages::Waypoint* p = waypoint_;
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.InsertWaypoint.waypoint)
  return p != nullptr ? *p : *reinterpret_cast<const ::Flightplan::Messages::Waypoint*>(
      &::Flightplan::Messages::_Waypoint_default_instance_);
}
inline ::Flightplan::Messages::Waypoint* InsertWaypoint::release_waypoint() {
  // @@protoc_insertion_point(field_release:Guidance.Flightplan.Messages.InsertWaypoint.waypoint)
  
  ::Flightplan::Messages::Waypoint* temp = waypoint_;
  waypoint_ = nullptr;
  return temp;
}
inline ::Flightplan::Messages::Waypoint* InsertWaypoint::mutable_waypoint() {
  
  if (waypoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::Flightplan::Messages::Waypoint>(GetArenaNoVirtual());
    waypoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Flightplan.Messages.InsertWaypoint.waypoint)
  return waypoint_;
}
inline void InsertWaypoint::set_allocated_waypoint(::Flightplan::Messages::Waypoint* waypoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(waypoint_);
  }
  if (waypoint) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      waypoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, waypoint, submessage_arena);
    }
    
  } else {
    
  }
  waypoint_ = waypoint;
  // @@protoc_insertion_point(field_set_allocated:Guidance.Flightplan.Messages.InsertWaypoint.waypoint)
}

// int32 index = 2;
inline void InsertWaypoint::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 InsertWaypoint::index() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.InsertWaypoint.index)
  return index_;
}
inline void InsertWaypoint::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.InsertWaypoint.index)
}

// -------------------------------------------------------------------

// ReplaceWaypoint

// .Flightplan.Messages.Waypoint waypoint = 1;
inline bool ReplaceWaypoint::has_waypoint() const {
  return this != internal_default_instance() && waypoint_ != nullptr;
}
inline const ::Flightplan::Messages::Waypoint& ReplaceWaypoint::waypoint() const {
  const ::Flightplan::Messages::Waypoint* p = waypoint_;
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.ReplaceWaypoint.waypoint)
  return p != nullptr ? *p : *reinterpret_cast<const ::Flightplan::Messages::Waypoint*>(
      &::Flightplan::Messages::_Waypoint_default_instance_);
}
inline ::Flightplan::Messages::Waypoint* ReplaceWaypoint::release_waypoint() {
  // @@protoc_insertion_point(field_release:Guidance.Flightplan.Messages.ReplaceWaypoint.waypoint)
  
  ::Flightplan::Messages::Waypoint* temp = waypoint_;
  waypoint_ = nullptr;
  return temp;
}
inline ::Flightplan::Messages::Waypoint* ReplaceWaypoint::mutable_waypoint() {
  
  if (waypoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::Flightplan::Messages::Waypoint>(GetArenaNoVirtual());
    waypoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Flightplan.Messages.ReplaceWaypoint.waypoint)
  return waypoint_;
}
inline void ReplaceWaypoint::set_allocated_waypoint(::Flightplan::Messages::Waypoint* waypoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(waypoint_);
  }
  if (waypoint) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      waypoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, waypoint, submessage_arena);
    }
    
  } else {
    
  }
  waypoint_ = waypoint;
  // @@protoc_insertion_point(field_set_allocated:Guidance.Flightplan.Messages.ReplaceWaypoint.waypoint)
}

// int32 index = 2;
inline void ReplaceWaypoint::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 ReplaceWaypoint::index() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.ReplaceWaypoint.index)
  return index_;
}
inline void ReplaceWaypoint::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.ReplaceWaypoint.index)
}

// bool keep_original_id = 3;
inline void ReplaceWaypoint::clear_keep_original_id() {
  keep_original_id_ = false;
}
inline bool ReplaceWaypoint::keep_original_id() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.ReplaceWaypoint.keep_original_id)
  return keep_original_id_;
}
inline void ReplaceWaypoint::set_keep_original_id(bool value) {
  
  keep_original_id_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.ReplaceWaypoint.keep_original_id)
}

// -------------------------------------------------------------------

// Index

// int32 value = 1;
inline void Index::clear_value() {
  value_ = 0;
}
inline ::google::protobuf::int32 Index::value() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Index.value)
  return value_;
}
inline void Index::set_value(::google::protobuf::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.Index.value)
}

// -------------------------------------------------------------------

// WaypointValidated

// int32 current_waypoint_id = 1;
inline void WaypointValidated::clear_current_waypoint_id() {
  current_waypoint_id_ = 0;
}
inline ::google::protobuf::int32 WaypointValidated::current_waypoint_id() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.WaypointValidated.current_waypoint_id)
  return current_waypoint_id_;
}
inline void WaypointValidated::set_current_waypoint_id(::google::protobuf::int32 value) {
  
  current_waypoint_id_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.WaypointValidated.current_waypoint_id)
}

// int32 waypoint_id = 2;
inline void WaypointValidated::clear_waypoint_id() {
  waypoint_id_ = 0;
}
inline ::google::protobuf::int32 WaypointValidated::waypoint_id() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.WaypointValidated.waypoint_id)
  return waypoint_id_;
}
inline void WaypointValidated::set_waypoint_id(::google::protobuf::int32 value) {
  
  waypoint_id_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.WaypointValidated.waypoint_id)
}

// int32 original_id = 3;
inline void WaypointValidated::clear_original_id() {
  original_id_ = 0;
}
inline ::google::protobuf::int32 WaypointValidated::original_id() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.WaypointValidated.original_id)
  return original_id_;
}
inline void WaypointValidated::set_original_id(::google::protobuf::int32 value) {
  
  original_id_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.WaypointValidated.original_id)
}

// -------------------------------------------------------------------

// WaypointSkipped

// int32 current_waypoint_id = 1;
inline void WaypointSkipped::clear_current_waypoint_id() {
  current_waypoint_id_ = 0;
}
inline ::google::protobuf::int32 WaypointSkipped::current_waypoint_id() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.WaypointSkipped.current_waypoint_id)
  return current_waypoint_id_;
}
inline void WaypointSkipped::set_current_waypoint_id(::google::protobuf::int32 value) {
  
  current_waypoint_id_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.WaypointSkipped.current_waypoint_id)
}

// int32 skipped_waypoint_id = 2;
inline void WaypointSkipped::clear_skipped_waypoint_id() {
  skipped_waypoint_id_ = 0;
}
inline ::google::protobuf::int32 WaypointSkipped::skipped_waypoint_id() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.WaypointSkipped.skipped_waypoint_id)
  return skipped_waypoint_id_;
}
inline void WaypointSkipped::set_skipped_waypoint_id(::google::protobuf::int32 value) {
  
  skipped_waypoint_id_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.WaypointSkipped.skipped_waypoint_id)
}

// int32 original_id = 3;
inline void WaypointSkipped::clear_original_id() {
  original_id_ = 0;
}
inline ::google::protobuf::int32 WaypointSkipped::original_id() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.WaypointSkipped.original_id)
  return original_id_;
}
inline void WaypointSkipped::set_original_id(::google::protobuf::int32 value) {
  
  original_id_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.WaypointSkipped.original_id)
}

// -------------------------------------------------------------------

// Config

// .Flightplan.Messages.WaypointPath waypoint_path = 1;
inline bool Config::has_waypoint_path() const {
  return this != internal_default_instance() && waypoint_path_ != nullptr;
}
inline const ::Flightplan::Messages::WaypointPath& Config::waypoint_path() const {
  const ::Flightplan::Messages::WaypointPath* p = waypoint_path_;
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Config.waypoint_path)
  return p != nullptr ? *p : *reinterpret_cast<const ::Flightplan::Messages::WaypointPath*>(
      &::Flightplan::Messages::_WaypointPath_default_instance_);
}
inline ::Flightplan::Messages::WaypointPath* Config::release_waypoint_path() {
  // @@protoc_insertion_point(field_release:Guidance.Flightplan.Messages.Config.waypoint_path)
  
  ::Flightplan::Messages::WaypointPath* temp = waypoint_path_;
  waypoint_path_ = nullptr;
  return temp;
}
inline ::Flightplan::Messages::WaypointPath* Config::mutable_waypoint_path() {
  
  if (waypoint_path_ == nullptr) {
    auto* p = CreateMaybeMessage<::Flightplan::Messages::WaypointPath>(GetArenaNoVirtual());
    waypoint_path_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Flightplan.Messages.Config.waypoint_path)
  return waypoint_path_;
}
inline void Config::set_allocated_waypoint_path(::Flightplan::Messages::WaypointPath* waypoint_path) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(waypoint_path_);
  }
  if (waypoint_path) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      waypoint_path = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, waypoint_path, submessage_arena);
    }
    
  } else {
    
  }
  waypoint_path_ = waypoint_path;
  // @@protoc_insertion_point(field_set_allocated:Guidance.Flightplan.Messages.Config.waypoint_path)
}

// float max_horizontal_speed = 2;
inline bool Config::has_max_horizontal_speed() const {
  return optional_max_horizontal_speed_case() == kMaxHorizontalSpeed;
}
inline void Config::set_has_max_horizontal_speed() {
  _oneof_case_[0] = kMaxHorizontalSpeed;
}
inline void Config::clear_max_horizontal_speed() {
  if (has_max_horizontal_speed()) {
    optional_max_horizontal_speed_.max_horizontal_speed_ = 0;
    clear_has_optional_max_horizontal_speed();
  }
}
inline float Config::max_horizontal_speed() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Config.max_horizontal_speed)
  if (has_max_horizontal_speed()) {
    return optional_max_horizontal_speed_.max_horizontal_speed_;
  }
  return 0;
}
inline void Config::set_max_horizontal_speed(float value) {
  if (!has_max_horizontal_speed()) {
    clear_optional_max_horizontal_speed();
    set_has_max_horizontal_speed();
  }
  optional_max_horizontal_speed_.max_horizontal_speed_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.Config.max_horizontal_speed)
}

// float max_vertical_speed = 3;
inline bool Config::has_max_vertical_speed() const {
  return optional_max_vertical_speed_case() == kMaxVerticalSpeed;
}
inline void Config::set_has_max_vertical_speed() {
  _oneof_case_[1] = kMaxVerticalSpeed;
}
inline void Config::clear_max_vertical_speed() {
  if (has_max_vertical_speed()) {
    optional_max_vertical_speed_.max_vertical_speed_ = 0;
    clear_has_optional_max_vertical_speed();
  }
}
inline float Config::max_vertical_speed() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Config.max_vertical_speed)
  if (has_max_vertical_speed()) {
    return optional_max_vertical_speed_.max_vertical_speed_;
  }
  return 0;
}
inline void Config::set_max_vertical_speed(float value) {
  if (!has_max_vertical_speed()) {
    clear_optional_max_vertical_speed();
    set_has_max_vertical_speed();
  }
  optional_max_vertical_speed_.max_vertical_speed_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.Config.max_vertical_speed)
}

// float max_yaw_speed = 4;
inline bool Config::has_max_yaw_speed() const {
  return optional_max_yaw_speed_case() == kMaxYawSpeed;
}
inline void Config::set_has_max_yaw_speed() {
  _oneof_case_[2] = kMaxYawSpeed;
}
inline void Config::clear_max_yaw_speed() {
  if (has_max_yaw_speed()) {
    optional_max_yaw_speed_.max_yaw_speed_ = 0;
    clear_has_optional_max_yaw_speed();
  }
}
inline float Config::max_yaw_speed() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Config.max_yaw_speed)
  if (has_max_yaw_speed()) {
    return optional_max_yaw_speed_.max_yaw_speed_;
  }
  return 0;
}
inline void Config::set_max_yaw_speed(float value) {
  if (!has_max_yaw_speed()) {
    clear_optional_max_yaw_speed();
    set_has_max_yaw_speed();
  }
  optional_max_yaw_speed_.max_yaw_speed_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.Config.max_yaw_speed)
}

inline bool Config::has_optional_max_horizontal_speed() const {
  return optional_max_horizontal_speed_case() != OPTIONAL_MAX_HORIZONTAL_SPEED_NOT_SET;
}
inline void Config::clear_has_optional_max_horizontal_speed() {
  _oneof_case_[0] = OPTIONAL_MAX_HORIZONTAL_SPEED_NOT_SET;
}
inline bool Config::has_optional_max_vertical_speed() const {
  return optional_max_vertical_speed_case() != OPTIONAL_MAX_VERTICAL_SPEED_NOT_SET;
}
inline void Config::clear_has_optional_max_vertical_speed() {
  _oneof_case_[1] = OPTIONAL_MAX_VERTICAL_SPEED_NOT_SET;
}
inline bool Config::has_optional_max_yaw_speed() const {
  return optional_max_yaw_speed_case() != OPTIONAL_MAX_YAW_SPEED_NOT_SET;
}
inline void Config::clear_has_optional_max_yaw_speed() {
  _oneof_case_[2] = OPTIONAL_MAX_YAW_SPEED_NOT_SET;
}
inline Config::OptionalMaxHorizontalSpeedCase Config::optional_max_horizontal_speed_case() const {
  return Config::OptionalMaxHorizontalSpeedCase(_oneof_case_[0]);
}
inline Config::OptionalMaxVerticalSpeedCase Config::optional_max_vertical_speed_case() const {
  return Config::OptionalMaxVerticalSpeedCase(_oneof_case_[1]);
}
inline Config::OptionalMaxYawSpeedCase Config::optional_max_yaw_speed_case() const {
  return Config::OptionalMaxYawSpeedCase(_oneof_case_[2]);
}
// -------------------------------------------------------------------

// Command

// .google.protobuf.Empty pause = 1;
inline bool Command::has_pause() const {
  return id_case() == kPause;
}
inline void Command::set_has_pause() {
  _oneof_case_[0] = kPause;
}
inline ::google::protobuf::Empty* Command::release_pause() {
  // @@protoc_insertion_point(field_release:Guidance.Flightplan.Messages.Command.pause)
  if (has_pause()) {
    clear_has_id();
      ::google::protobuf::Empty* temp = id_.pause_;
    id_.pause_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Empty& Command::pause() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Command.pause)
  return has_pause()
      ? *id_.pause_
      : *reinterpret_cast< ::google::protobuf::Empty*>(&::google::protobuf::_Empty_default_instance_);
}
inline ::google::protobuf::Empty* Command::mutable_pause() {
  if (!has_pause()) {
    clear_id();
    set_has_pause();
    id_.pause_ = CreateMaybeMessage< ::google::protobuf::Empty >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Flightplan.Messages.Command.pause)
  return id_.pause_;
}

// .google.protobuf.Empty resume = 2;
inline bool Command::has_resume() const {
  return id_case() == kResume;
}
inline void Command::set_has_resume() {
  _oneof_case_[0] = kResume;
}
inline ::google::protobuf::Empty* Command::release_resume() {
  // @@protoc_insertion_point(field_release:Guidance.Flightplan.Messages.Command.resume)
  if (has_resume()) {
    clear_has_id();
      ::google::protobuf::Empty* temp = id_.resume_;
    id_.resume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Empty& Command::resume() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Command.resume)
  return has_resume()
      ? *id_.resume_
      : *reinterpret_cast< ::google::protobuf::Empty*>(&::google::protobuf::_Empty_default_instance_);
}
inline ::google::protobuf::Empty* Command::mutable_resume() {
  if (!has_resume()) {
    clear_id();
    set_has_resume();
    id_.resume_ = CreateMaybeMessage< ::google::protobuf::Empty >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Flightplan.Messages.Command.resume)
  return id_.resume_;
}

// .Guidance.Flightplan.Messages.InsertWaypoint insert_waypoint = 3;
inline bool Command::has_insert_waypoint() const {
  return id_case() == kInsertWaypoint;
}
inline void Command::set_has_insert_waypoint() {
  _oneof_case_[0] = kInsertWaypoint;
}
inline void Command::clear_insert_waypoint() {
  if (has_insert_waypoint()) {
    delete id_.insert_waypoint_;
    clear_has_id();
  }
}
inline ::Guidance::Flightplan::Messages::InsertWaypoint* Command::release_insert_waypoint() {
  // @@protoc_insertion_point(field_release:Guidance.Flightplan.Messages.Command.insert_waypoint)
  if (has_insert_waypoint()) {
    clear_has_id();
      ::Guidance::Flightplan::Messages::InsertWaypoint* temp = id_.insert_waypoint_;
    id_.insert_waypoint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::Flightplan::Messages::InsertWaypoint& Command::insert_waypoint() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Command.insert_waypoint)
  return has_insert_waypoint()
      ? *id_.insert_waypoint_
      : *reinterpret_cast< ::Guidance::Flightplan::Messages::InsertWaypoint*>(&::Guidance::Flightplan::Messages::_InsertWaypoint_default_instance_);
}
inline ::Guidance::Flightplan::Messages::InsertWaypoint* Command::mutable_insert_waypoint() {
  if (!has_insert_waypoint()) {
    clear_id();
    set_has_insert_waypoint();
    id_.insert_waypoint_ = CreateMaybeMessage< ::Guidance::Flightplan::Messages::InsertWaypoint >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Flightplan.Messages.Command.insert_waypoint)
  return id_.insert_waypoint_;
}

// int32 remove_waypoint = 4;
inline bool Command::has_remove_waypoint() const {
  return id_case() == kRemoveWaypoint;
}
inline void Command::set_has_remove_waypoint() {
  _oneof_case_[0] = kRemoveWaypoint;
}
inline void Command::clear_remove_waypoint() {
  if (has_remove_waypoint()) {
    id_.remove_waypoint_ = 0;
    clear_has_id();
  }
}
inline ::google::protobuf::int32 Command::remove_waypoint() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Command.remove_waypoint)
  if (has_remove_waypoint()) {
    return id_.remove_waypoint_;
  }
  return 0;
}
inline void Command::set_remove_waypoint(::google::protobuf::int32 value) {
  if (!has_remove_waypoint()) {
    clear_id();
    set_has_remove_waypoint();
  }
  id_.remove_waypoint_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.Command.remove_waypoint)
}

// .Guidance.Flightplan.Messages.ReplaceWaypoint replace_waypoint = 5;
inline bool Command::has_replace_waypoint() const {
  return id_case() == kReplaceWaypoint;
}
inline void Command::set_has_replace_waypoint() {
  _oneof_case_[0] = kReplaceWaypoint;
}
inline void Command::clear_replace_waypoint() {
  if (has_replace_waypoint()) {
    delete id_.replace_waypoint_;
    clear_has_id();
  }
}
inline ::Guidance::Flightplan::Messages::ReplaceWaypoint* Command::release_replace_waypoint() {
  // @@protoc_insertion_point(field_release:Guidance.Flightplan.Messages.Command.replace_waypoint)
  if (has_replace_waypoint()) {
    clear_has_id();
      ::Guidance::Flightplan::Messages::ReplaceWaypoint* temp = id_.replace_waypoint_;
    id_.replace_waypoint_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::Flightplan::Messages::ReplaceWaypoint& Command::replace_waypoint() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Command.replace_waypoint)
  return has_replace_waypoint()
      ? *id_.replace_waypoint_
      : *reinterpret_cast< ::Guidance::Flightplan::Messages::ReplaceWaypoint*>(&::Guidance::Flightplan::Messages::_ReplaceWaypoint_default_instance_);
}
inline ::Guidance::Flightplan::Messages::ReplaceWaypoint* Command::mutable_replace_waypoint() {
  if (!has_replace_waypoint()) {
    clear_id();
    set_has_replace_waypoint();
    id_.replace_waypoint_ = CreateMaybeMessage< ::Guidance::Flightplan::Messages::ReplaceWaypoint >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Flightplan.Messages.Command.replace_waypoint)
  return id_.replace_waypoint_;
}

// uint32 set_current_index = 6;
inline bool Command::has_set_current_index() const {
  return id_case() == kSetCurrentIndex;
}
inline void Command::set_has_set_current_index() {
  _oneof_case_[0] = kSetCurrentIndex;
}
inline void Command::clear_set_current_index() {
  if (has_set_current_index()) {
    id_.set_current_index_ = 0u;
    clear_has_id();
  }
}
inline ::google::protobuf::uint32 Command::set_current_index() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Command.set_current_index)
  if (has_set_current_index()) {
    return id_.set_current_index_;
  }
  return 0u;
}
inline void Command::set_set_current_index(::google::protobuf::uint32 value) {
  if (!has_set_current_index()) {
    clear_id();
    set_has_set_current_index();
  }
  id_.set_current_index_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Flightplan.Messages.Command.set_current_index)
}

inline bool Command::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void Command::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline Command::IdCase Command::id_case() const {
  return Command::IdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event

// .google.protobuf.Empty done = 1;
inline bool Event::has_done() const {
  return id_case() == kDone;
}
inline void Event::set_has_done() {
  _oneof_case_[0] = kDone;
}
inline ::google::protobuf::Empty* Event::release_done() {
  // @@protoc_insertion_point(field_release:Guidance.Flightplan.Messages.Event.done)
  if (has_done()) {
    clear_has_id();
      ::google::protobuf::Empty* temp = id_.done_;
    id_.done_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Empty& Event::done() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Event.done)
  return has_done()
      ? *id_.done_
      : *reinterpret_cast< ::google::protobuf::Empty*>(&::google::protobuf::_Empty_default_instance_);
}
inline ::google::protobuf::Empty* Event::mutable_done() {
  if (!has_done()) {
    clear_id();
    set_has_done();
    id_.done_ = CreateMaybeMessage< ::google::protobuf::Empty >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Flightplan.Messages.Event.done)
  return id_.done_;
}

// .Guidance.Flightplan.Messages.WaypointValidated waypoint_validated = 2;
inline bool Event::has_waypoint_validated() const {
  return id_case() == kWaypointValidated;
}
inline void Event::set_has_waypoint_validated() {
  _oneof_case_[0] = kWaypointValidated;
}
inline void Event::clear_waypoint_validated() {
  if (has_waypoint_validated()) {
    delete id_.waypoint_validated_;
    clear_has_id();
  }
}
inline ::Guidance::Flightplan::Messages::WaypointValidated* Event::release_waypoint_validated() {
  // @@protoc_insertion_point(field_release:Guidance.Flightplan.Messages.Event.waypoint_validated)
  if (has_waypoint_validated()) {
    clear_has_id();
      ::Guidance::Flightplan::Messages::WaypointValidated* temp = id_.waypoint_validated_;
    id_.waypoint_validated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::Flightplan::Messages::WaypointValidated& Event::waypoint_validated() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Event.waypoint_validated)
  return has_waypoint_validated()
      ? *id_.waypoint_validated_
      : *reinterpret_cast< ::Guidance::Flightplan::Messages::WaypointValidated*>(&::Guidance::Flightplan::Messages::_WaypointValidated_default_instance_);
}
inline ::Guidance::Flightplan::Messages::WaypointValidated* Event::mutable_waypoint_validated() {
  if (!has_waypoint_validated()) {
    clear_id();
    set_has_waypoint_validated();
    id_.waypoint_validated_ = CreateMaybeMessage< ::Guidance::Flightplan::Messages::WaypointValidated >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Flightplan.Messages.Event.waypoint_validated)
  return id_.waypoint_validated_;
}

// .Guidance.Flightplan.Messages.WaypointSkipped waypoint_skipped = 3;
inline bool Event::has_waypoint_skipped() const {
  return id_case() == kWaypointSkipped;
}
inline void Event::set_has_waypoint_skipped() {
  _oneof_case_[0] = kWaypointSkipped;
}
inline void Event::clear_waypoint_skipped() {
  if (has_waypoint_skipped()) {
    delete id_.waypoint_skipped_;
    clear_has_id();
  }
}
inline ::Guidance::Flightplan::Messages::WaypointSkipped* Event::release_waypoint_skipped() {
  // @@protoc_insertion_point(field_release:Guidance.Flightplan.Messages.Event.waypoint_skipped)
  if (has_waypoint_skipped()) {
    clear_has_id();
      ::Guidance::Flightplan::Messages::WaypointSkipped* temp = id_.waypoint_skipped_;
    id_.waypoint_skipped_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::Flightplan::Messages::WaypointSkipped& Event::waypoint_skipped() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Event.waypoint_skipped)
  return has_waypoint_skipped()
      ? *id_.waypoint_skipped_
      : *reinterpret_cast< ::Guidance::Flightplan::Messages::WaypointSkipped*>(&::Guidance::Flightplan::Messages::_WaypointSkipped_default_instance_);
}
inline ::Guidance::Flightplan::Messages::WaypointSkipped* Event::mutable_waypoint_skipped() {
  if (!has_waypoint_skipped()) {
    clear_id();
    set_has_waypoint_skipped();
    id_.waypoint_skipped_ = CreateMaybeMessage< ::Guidance::Flightplan::Messages::WaypointSkipped >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Flightplan.Messages.Event.waypoint_skipped)
  return id_.waypoint_skipped_;
}

// .Flightplan.Messages.WaypointPath changed = 4;
inline bool Event::has_changed() const {
  return id_case() == kChanged;
}
inline void Event::set_has_changed() {
  _oneof_case_[0] = kChanged;
}
inline ::Flightplan::Messages::WaypointPath* Event::release_changed() {
  // @@protoc_insertion_point(field_release:Guidance.Flightplan.Messages.Event.changed)
  if (has_changed()) {
    clear_has_id();
      ::Flightplan::Messages::WaypointPath* temp = id_.changed_;
    id_.changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Flightplan::Messages::WaypointPath& Event::changed() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Event.changed)
  return has_changed()
      ? *id_.changed_
      : *reinterpret_cast< ::Flightplan::Messages::WaypointPath*>(&::Flightplan::Messages::_WaypointPath_default_instance_);
}
inline ::Flightplan::Messages::WaypointPath* Event::mutable_changed() {
  if (!has_changed()) {
    clear_id();
    set_has_changed();
    id_.changed_ = CreateMaybeMessage< ::Flightplan::Messages::WaypointPath >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Flightplan.Messages.Event.changed)
  return id_.changed_;
}

// .google.protobuf.Empty rejected = 5;
inline bool Event::has_rejected() const {
  return id_case() == kRejected;
}
inline void Event::set_has_rejected() {
  _oneof_case_[0] = kRejected;
}
inline ::google::protobuf::Empty* Event::release_rejected() {
  // @@protoc_insertion_point(field_release:Guidance.Flightplan.Messages.Event.rejected)
  if (has_rejected()) {
    clear_has_id();
      ::google::protobuf::Empty* temp = id_.rejected_;
    id_.rejected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Empty& Event::rejected() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Event.rejected)
  return has_rejected()
      ? *id_.rejected_
      : *reinterpret_cast< ::google::protobuf::Empty*>(&::google::protobuf::_Empty_default_instance_);
}
inline ::google::protobuf::Empty* Event::mutable_rejected() {
  if (!has_rejected()) {
    clear_id();
    set_has_rejected();
    id_.rejected_ = CreateMaybeMessage< ::google::protobuf::Empty >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Flightplan.Messages.Event.rejected)
  return id_.rejected_;
}

// .google.protobuf.Empty blockage_detected = 6;
inline bool Event::has_blockage_detected() const {
  return id_case() == kBlockageDetected;
}
inline void Event::set_has_blockage_detected() {
  _oneof_case_[0] = kBlockageDetected;
}
inline ::google::protobuf::Empty* Event::release_blockage_detected() {
  // @@protoc_insertion_point(field_release:Guidance.Flightplan.Messages.Event.blockage_detected)
  if (has_blockage_detected()) {
    clear_has_id();
      ::google::protobuf::Empty* temp = id_.blockage_detected_;
    id_.blockage_detected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Empty& Event::blockage_detected() const {
  // @@protoc_insertion_point(field_get:Guidance.Flightplan.Messages.Event.blockage_detected)
  return has_blockage_detected()
      ? *id_.blockage_detected_
      : *reinterpret_cast< ::google::protobuf::Empty*>(&::google::protobuf::_Empty_default_instance_);
}
inline ::google::protobuf::Empty* Event::mutable_blockage_detected() {
  if (!has_blockage_detected()) {
    clear_id();
    set_has_blockage_detected();
    id_.blockage_detected_ = CreateMaybeMessage< ::google::protobuf::Empty >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Flightplan.Messages.Event.blockage_detected)
  return id_.blockage_detected_;
}

inline bool Event::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void Event::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline Event::IdCase Event::id_case() const {
  return Event::IdCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Messages
}  // namespace Flightplan
}  // namespace Guidance

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_guidance_2fflightplan_2eproto
