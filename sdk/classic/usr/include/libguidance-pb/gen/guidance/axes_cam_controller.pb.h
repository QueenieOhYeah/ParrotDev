// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: guidance/axes_cam_controller.proto

#ifndef PROTOBUF_INCLUDED_guidance_2faxes_5fcam_5fcontroller_2eproto
#define PROTOBUF_INCLUDED_guidance_2faxes_5fcam_5fcontroller_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "cam_controller/cam_controller.pb.h"
#include "axes_cam_controller/axes_cam_controller.pb.h"
#include "guidance/camera.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_guidance_2faxes_5fcam_5fcontroller_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_guidance_2faxes_5fcam_5fcontroller_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_guidance_2faxes_5fcam_5fcontroller_2eproto();
namespace Guidance {
namespace AxesCamController {
namespace Messages {
class Capabilities;
class CapabilitiesDefaultTypeInternal;
extern CapabilitiesDefaultTypeInternal _Capabilities_default_instance_;
class Capabilities_Bounds;
class Capabilities_BoundsDefaultTypeInternal;
extern Capabilities_BoundsDefaultTypeInternal _Capabilities_Bounds_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Reference;
class ReferenceDefaultTypeInternal;
extern ReferenceDefaultTypeInternal _Reference_default_instance_;
class ReferenceStatus;
class ReferenceStatusDefaultTypeInternal;
extern ReferenceStatusDefaultTypeInternal _ReferenceStatus_default_instance_;
class Reset;
class ResetDefaultTypeInternal;
extern ResetDefaultTypeInternal _Reset_default_instance_;
}  // namespace Messages
}  // namespace AxesCamController
}  // namespace Guidance
namespace google {
namespace protobuf {
template<> ::Guidance::AxesCamController::Messages::Capabilities* Arena::CreateMaybeMessage<::Guidance::AxesCamController::Messages::Capabilities>(Arena*);
template<> ::Guidance::AxesCamController::Messages::Capabilities_Bounds* Arena::CreateMaybeMessage<::Guidance::AxesCamController::Messages::Capabilities_Bounds>(Arena*);
template<> ::Guidance::AxesCamController::Messages::Command* Arena::CreateMaybeMessage<::Guidance::AxesCamController::Messages::Command>(Arena*);
template<> ::Guidance::AxesCamController::Messages::Config* Arena::CreateMaybeMessage<::Guidance::AxesCamController::Messages::Config>(Arena*);
template<> ::Guidance::AxesCamController::Messages::Event* Arena::CreateMaybeMessage<::Guidance::AxesCamController::Messages::Event>(Arena*);
template<> ::Guidance::AxesCamController::Messages::Reference* Arena::CreateMaybeMessage<::Guidance::AxesCamController::Messages::Reference>(Arena*);
template<> ::Guidance::AxesCamController::Messages::ReferenceStatus* Arena::CreateMaybeMessage<::Guidance::AxesCamController::Messages::ReferenceStatus>(Arena*);
template<> ::Guidance::AxesCamController::Messages::Reset* Arena::CreateMaybeMessage<::Guidance::AxesCamController::Messages::Reset>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Guidance {
namespace AxesCamController {
namespace Messages {

// ===================================================================

class Reset :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.AxesCamController.Messages.Reset) */ {
 public:
  Reset();
  virtual ~Reset();

  Reset(const Reset& from);

  inline Reset& operator=(const Reset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Reset(Reset&& from) noexcept
    : Reset() {
    *this = ::std::move(from);
  }

  inline Reset& operator=(Reset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Reset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reset* internal_default_instance() {
    return reinterpret_cast<const Reset*>(
               &_Reset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Reset* other);
  friend void swap(Reset& a, Reset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Reset* New() const final {
    return CreateMaybeMessage<Reset>(nullptr);
  }

  Reset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Reset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Reset& from);
  void MergeFrom(const Reset& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Guidance.Camera.Messages.Enum cam = 1;
  void clear_cam();
  static const int kCamFieldNumber = 1;
  ::Guidance::Camera::Messages::Enum cam() const;
  void set_cam(::Guidance::Camera::Messages::Enum value);

  // @@protoc_insertion_point(class_scope:Guidance.AxesCamController.Messages.Reset)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int cam_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2faxes_5fcam_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class Reference :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.AxesCamController.Messages.Reference) */ {
 public:
  Reference();
  virtual ~Reference();

  Reference(const Reference& from);

  inline Reference& operator=(const Reference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Reference(Reference&& from) noexcept
    : Reference() {
    *this = ::std::move(from);
  }

  inline Reference& operator=(Reference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Reference& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reference* internal_default_instance() {
    return reinterpret_cast<const Reference*>(
               &_Reference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Reference* other);
  friend void swap(Reference& a, Reference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Reference* New() const final {
    return CreateMaybeMessage<Reference>(nullptr);
  }

  Reference* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Reference>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Reference& from);
  void MergeFrom(const Reference& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .AxesCamController.Messages.Reference reference = 2;
  bool has_reference() const;
  void clear_reference();
  static const int kReferenceFieldNumber = 2;
  const ::AxesCamController::Messages::Reference& reference() const;
  ::AxesCamController::Messages::Reference* release_reference();
  ::AxesCamController::Messages::Reference* mutable_reference();
  void set_allocated_reference(::AxesCamController::Messages::Reference* reference);

  // .Guidance.Camera.Messages.Enum cam = 1;
  void clear_cam();
  static const int kCamFieldNumber = 1;
  ::Guidance::Camera::Messages::Enum cam() const;
  void set_cam(::Guidance::Camera::Messages::Enum value);

  // @@protoc_insertion_point(class_scope:Guidance.AxesCamController.Messages.Reference)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::AxesCamController::Messages::Reference* reference_;
  int cam_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2faxes_5fcam_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class Config :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.AxesCamController.Messages.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Config* other);
  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const final {
    return CreateMaybeMessage<Config>(nullptr);
  }

  Config* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .AxesCamController.Messages.Config config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::AxesCamController::Messages::Config& config() const;
  ::AxesCamController::Messages::Config* release_config();
  ::AxesCamController::Messages::Config* mutable_config();
  void set_allocated_config(::AxesCamController::Messages::Config* config);

  // .Guidance.Camera.Messages.Enum cam = 1;
  void clear_cam();
  static const int kCamFieldNumber = 1;
  ::Guidance::Camera::Messages::Enum cam() const;
  void set_cam(::Guidance::Camera::Messages::Enum value);

  // @@protoc_insertion_point(class_scope:Guidance.AxesCamController.Messages.Config)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::AxesCamController::Messages::Config* config_;
  int cam_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2faxes_5fcam_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class ReferenceStatus :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.AxesCamController.Messages.ReferenceStatus) */ {
 public:
  ReferenceStatus();
  virtual ~ReferenceStatus();

  ReferenceStatus(const ReferenceStatus& from);

  inline ReferenceStatus& operator=(const ReferenceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReferenceStatus(ReferenceStatus&& from) noexcept
    : ReferenceStatus() {
    *this = ::std::move(from);
  }

  inline ReferenceStatus& operator=(ReferenceStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ReferenceStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReferenceStatus* internal_default_instance() {
    return reinterpret_cast<const ReferenceStatus*>(
               &_ReferenceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ReferenceStatus* other);
  friend void swap(ReferenceStatus& a, ReferenceStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReferenceStatus* New() const final {
    return CreateMaybeMessage<ReferenceStatus>(nullptr);
  }

  ReferenceStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReferenceStatus& from);
  void MergeFrom(const ReferenceStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .AxesCamController.Messages.ReferenceStatus status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::AxesCamController::Messages::ReferenceStatus& status() const;
  ::AxesCamController::Messages::ReferenceStatus* release_status();
  ::AxesCamController::Messages::ReferenceStatus* mutable_status();
  void set_allocated_status(::AxesCamController::Messages::ReferenceStatus* status);

  // .Guidance.Camera.Messages.Enum cam = 1;
  void clear_cam();
  static const int kCamFieldNumber = 1;
  ::Guidance::Camera::Messages::Enum cam() const;
  void set_cam(::Guidance::Camera::Messages::Enum value);

  // @@protoc_insertion_point(class_scope:Guidance.AxesCamController.Messages.ReferenceStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::AxesCamController::Messages::ReferenceStatus* status_;
  int cam_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2faxes_5fcam_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class Capabilities_Bounds :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.AxesCamController.Messages.Capabilities.Bounds) */ {
 public:
  Capabilities_Bounds();
  virtual ~Capabilities_Bounds();

  Capabilities_Bounds(const Capabilities_Bounds& from);

  inline Capabilities_Bounds& operator=(const Capabilities_Bounds& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Capabilities_Bounds(Capabilities_Bounds&& from) noexcept
    : Capabilities_Bounds() {
    *this = ::std::move(from);
  }

  inline Capabilities_Bounds& operator=(Capabilities_Bounds&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Capabilities_Bounds& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Capabilities_Bounds* internal_default_instance() {
    return reinterpret_cast<const Capabilities_Bounds*>(
               &_Capabilities_Bounds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Capabilities_Bounds* other);
  friend void swap(Capabilities_Bounds& a, Capabilities_Bounds& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Capabilities_Bounds* New() const final {
    return CreateMaybeMessage<Capabilities_Bounds>(nullptr);
  }

  Capabilities_Bounds* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Capabilities_Bounds>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Capabilities_Bounds& from);
  void MergeFrom(const Capabilities_Bounds& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Capabilities_Bounds* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float min = 1;
  void clear_min();
  static const int kMinFieldNumber = 1;
  float min() const;
  void set_min(float value);

  // float max = 2;
  void clear_max();
  static const int kMaxFieldNumber = 2;
  float max() const;
  void set_max(float value);

  // @@protoc_insertion_point(class_scope:Guidance.AxesCamController.Messages.Capabilities.Bounds)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float min_;
  float max_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2faxes_5fcam_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class Capabilities :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.AxesCamController.Messages.Capabilities) */ {
 public:
  Capabilities();
  virtual ~Capabilities();

  Capabilities(const Capabilities& from);

  inline Capabilities& operator=(const Capabilities& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Capabilities(Capabilities&& from) noexcept
    : Capabilities() {
    *this = ::std::move(from);
  }

  inline Capabilities& operator=(Capabilities&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Capabilities& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Capabilities* internal_default_instance() {
    return reinterpret_cast<const Capabilities*>(
               &_Capabilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Capabilities* other);
  friend void swap(Capabilities& a, Capabilities& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Capabilities* New() const final {
    return CreateMaybeMessage<Capabilities>(nullptr);
  }

  Capabilities* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Capabilities>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Capabilities& from);
  void MergeFrom(const Capabilities& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Capabilities* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Capabilities_Bounds Bounds;

  // accessors -------------------------------------------------------

  // .Guidance.AxesCamController.Messages.Capabilities.Bounds yaw_bounds = 5;
  bool has_yaw_bounds() const;
  void clear_yaw_bounds();
  static const int kYawBoundsFieldNumber = 5;
  const ::Guidance::AxesCamController::Messages::Capabilities_Bounds& yaw_bounds() const;
  ::Guidance::AxesCamController::Messages::Capabilities_Bounds* release_yaw_bounds();
  ::Guidance::AxesCamController::Messages::Capabilities_Bounds* mutable_yaw_bounds();
  void set_allocated_yaw_bounds(::Guidance::AxesCamController::Messages::Capabilities_Bounds* yaw_bounds);

  // .Guidance.AxesCamController.Messages.Capabilities.Bounds pitch_bounds = 6;
  bool has_pitch_bounds() const;
  void clear_pitch_bounds();
  static const int kPitchBoundsFieldNumber = 6;
  const ::Guidance::AxesCamController::Messages::Capabilities_Bounds& pitch_bounds() const;
  ::Guidance::AxesCamController::Messages::Capabilities_Bounds* release_pitch_bounds();
  ::Guidance::AxesCamController::Messages::Capabilities_Bounds* mutable_pitch_bounds();
  void set_allocated_pitch_bounds(::Guidance::AxesCamController::Messages::Capabilities_Bounds* pitch_bounds);

  // .Guidance.AxesCamController.Messages.Capabilities.Bounds roll_bounds = 7;
  bool has_roll_bounds() const;
  void clear_roll_bounds();
  static const int kRollBoundsFieldNumber = 7;
  const ::Guidance::AxesCamController::Messages::Capabilities_Bounds& roll_bounds() const;
  ::Guidance::AxesCamController::Messages::Capabilities_Bounds* release_roll_bounds();
  ::Guidance::AxesCamController::Messages::Capabilities_Bounds* mutable_roll_bounds();
  void set_allocated_roll_bounds(::Guidance::AxesCamController::Messages::Capabilities_Bounds* roll_bounds);

  // .Guidance.Camera.Messages.Enum cam = 1;
  void clear_cam();
  static const int kCamFieldNumber = 1;
  ::Guidance::Camera::Messages::Enum cam() const;
  void set_cam(::Guidance::Camera::Messages::Enum value);

  // bool yaw_drivable = 2;
  void clear_yaw_drivable();
  static const int kYawDrivableFieldNumber = 2;
  bool yaw_drivable() const;
  void set_yaw_drivable(bool value);

  // bool pitch_drivable = 3;
  void clear_pitch_drivable();
  static const int kPitchDrivableFieldNumber = 3;
  bool pitch_drivable() const;
  void set_pitch_drivable(bool value);

  // bool roll_drivable = 4;
  void clear_roll_drivable();
  static const int kRollDrivableFieldNumber = 4;
  bool roll_drivable() const;
  void set_roll_drivable(bool value);

  // @@protoc_insertion_point(class_scope:Guidance.AxesCamController.Messages.Capabilities)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Guidance::AxesCamController::Messages::Capabilities_Bounds* yaw_bounds_;
  ::Guidance::AxesCamController::Messages::Capabilities_Bounds* pitch_bounds_;
  ::Guidance::AxesCamController::Messages::Capabilities_Bounds* roll_bounds_;
  int cam_;
  bool yaw_drivable_;
  bool pitch_drivable_;
  bool roll_drivable_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2faxes_5fcam_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class Command :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.AxesCamController.Messages.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command& default_instance();

  enum IdCase {
    kReset = 1,
    kSetReference = 2,
    kSetConfig = 3,
    ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Guidance.AxesCamController.Messages.Reset reset = 1;
  bool has_reset() const;
  void clear_reset();
  static const int kResetFieldNumber = 1;
  const ::Guidance::AxesCamController::Messages::Reset& reset() const;
  ::Guidance::AxesCamController::Messages::Reset* release_reset();
  ::Guidance::AxesCamController::Messages::Reset* mutable_reset();
  void set_allocated_reset(::Guidance::AxesCamController::Messages::Reset* reset);

  // .Guidance.AxesCamController.Messages.Reference set_reference = 2;
  bool has_set_reference() const;
  void clear_set_reference();
  static const int kSetReferenceFieldNumber = 2;
  const ::Guidance::AxesCamController::Messages::Reference& set_reference() const;
  ::Guidance::AxesCamController::Messages::Reference* release_set_reference();
  ::Guidance::AxesCamController::Messages::Reference* mutable_set_reference();
  void set_allocated_set_reference(::Guidance::AxesCamController::Messages::Reference* set_reference);

  // .Guidance.AxesCamController.Messages.Config set_config = 3;
  bool has_set_config() const;
  void clear_set_config();
  static const int kSetConfigFieldNumber = 3;
  const ::Guidance::AxesCamController::Messages::Config& set_config() const;
  ::Guidance::AxesCamController::Messages::Config* release_set_config();
  ::Guidance::AxesCamController::Messages::Config* mutable_set_config();
  void set_allocated_set_config(::Guidance::AxesCamController::Messages::Config* set_config);

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:Guidance.AxesCamController.Messages.Command)
 private:
  class HasBitSetters;
  void set_has_reset();
  void set_has_set_reference();
  void set_has_set_config();

  inline bool has_id() const;
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    ::Guidance::AxesCamController::Messages::Reset* reset_;
    ::Guidance::AxesCamController::Messages::Reference* set_reference_;
    ::Guidance::AxesCamController::Messages::Config* set_config_;
  } id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_guidance_2faxes_5fcam_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class Event :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.AxesCamController.Messages.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Event& default_instance();

  enum IdCase {
    kConfig = 1,
    kReferenceStatus = 2,
    kCapabilities = 3,
    ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(nullptr);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Guidance.AxesCamController.Messages.Config config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::Guidance::AxesCamController::Messages::Config& config() const;
  ::Guidance::AxesCamController::Messages::Config* release_config();
  ::Guidance::AxesCamController::Messages::Config* mutable_config();
  void set_allocated_config(::Guidance::AxesCamController::Messages::Config* config);

  // .Guidance.AxesCamController.Messages.ReferenceStatus reference_status = 2;
  bool has_reference_status() const;
  void clear_reference_status();
  static const int kReferenceStatusFieldNumber = 2;
  const ::Guidance::AxesCamController::Messages::ReferenceStatus& reference_status() const;
  ::Guidance::AxesCamController::Messages::ReferenceStatus* release_reference_status();
  ::Guidance::AxesCamController::Messages::ReferenceStatus* mutable_reference_status();
  void set_allocated_reference_status(::Guidance::AxesCamController::Messages::ReferenceStatus* reference_status);

  // .Guidance.AxesCamController.Messages.Capabilities capabilities = 3;
  bool has_capabilities() const;
  void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 3;
  const ::Guidance::AxesCamController::Messages::Capabilities& capabilities() const;
  ::Guidance::AxesCamController::Messages::Capabilities* release_capabilities();
  ::Guidance::AxesCamController::Messages::Capabilities* mutable_capabilities();
  void set_allocated_capabilities(::Guidance::AxesCamController::Messages::Capabilities* capabilities);

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:Guidance.AxesCamController.Messages.Event)
 private:
  class HasBitSetters;
  void set_has_config();
  void set_has_reference_status();
  void set_has_capabilities();

  inline bool has_id() const;
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    ::Guidance::AxesCamController::Messages::Config* config_;
    ::Guidance::AxesCamController::Messages::ReferenceStatus* reference_status_;
    ::Guidance::AxesCamController::Messages::Capabilities* capabilities_;
  } id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_guidance_2faxes_5fcam_5fcontroller_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Reset

// .Guidance.Camera.Messages.Enum cam = 1;
inline void Reset::clear_cam() {
  cam_ = 0;
}
inline ::Guidance::Camera::Messages::Enum Reset::cam() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Reset.cam)
  return static_cast< ::Guidance::Camera::Messages::Enum >(cam_);
}
inline void Reset::set_cam(::Guidance::Camera::Messages::Enum value) {
  
  cam_ = value;
  // @@protoc_insertion_point(field_set:Guidance.AxesCamController.Messages.Reset.cam)
}

// -------------------------------------------------------------------

// Reference

// .Guidance.Camera.Messages.Enum cam = 1;
inline void Reference::clear_cam() {
  cam_ = 0;
}
inline ::Guidance::Camera::Messages::Enum Reference::cam() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Reference.cam)
  return static_cast< ::Guidance::Camera::Messages::Enum >(cam_);
}
inline void Reference::set_cam(::Guidance::Camera::Messages::Enum value) {
  
  cam_ = value;
  // @@protoc_insertion_point(field_set:Guidance.AxesCamController.Messages.Reference.cam)
}

// .AxesCamController.Messages.Reference reference = 2;
inline bool Reference::has_reference() const {
  return this != internal_default_instance() && reference_ != nullptr;
}
inline const ::AxesCamController::Messages::Reference& Reference::reference() const {
  const ::AxesCamController::Messages::Reference* p = reference_;
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Reference.reference)
  return p != nullptr ? *p : *reinterpret_cast<const ::AxesCamController::Messages::Reference*>(
      &::AxesCamController::Messages::_Reference_default_instance_);
}
inline ::AxesCamController::Messages::Reference* Reference::release_reference() {
  // @@protoc_insertion_point(field_release:Guidance.AxesCamController.Messages.Reference.reference)
  
  ::AxesCamController::Messages::Reference* temp = reference_;
  reference_ = nullptr;
  return temp;
}
inline ::AxesCamController::Messages::Reference* Reference::mutable_reference() {
  
  if (reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::AxesCamController::Messages::Reference>(GetArenaNoVirtual());
    reference_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Guidance.AxesCamController.Messages.Reference.reference)
  return reference_;
}
inline void Reference::set_allocated_reference(::AxesCamController::Messages::Reference* reference) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reference_);
  }
  if (reference) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      reference = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    
  } else {
    
  }
  reference_ = reference;
  // @@protoc_insertion_point(field_set_allocated:Guidance.AxesCamController.Messages.Reference.reference)
}

// -------------------------------------------------------------------

// Config

// .Guidance.Camera.Messages.Enum cam = 1;
inline void Config::clear_cam() {
  cam_ = 0;
}
inline ::Guidance::Camera::Messages::Enum Config::cam() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Config.cam)
  return static_cast< ::Guidance::Camera::Messages::Enum >(cam_);
}
inline void Config::set_cam(::Guidance::Camera::Messages::Enum value) {
  
  cam_ = value;
  // @@protoc_insertion_point(field_set:Guidance.AxesCamController.Messages.Config.cam)
}

// .AxesCamController.Messages.Config config = 2;
inline bool Config::has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline const ::AxesCamController::Messages::Config& Config::config() const {
  const ::AxesCamController::Messages::Config* p = config_;
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Config.config)
  return p != nullptr ? *p : *reinterpret_cast<const ::AxesCamController::Messages::Config*>(
      &::AxesCamController::Messages::_Config_default_instance_);
}
inline ::AxesCamController::Messages::Config* Config::release_config() {
  // @@protoc_insertion_point(field_release:Guidance.AxesCamController.Messages.Config.config)
  
  ::AxesCamController::Messages::Config* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::AxesCamController::Messages::Config* Config::mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::AxesCamController::Messages::Config>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Guidance.AxesCamController.Messages.Config.config)
  return config_;
}
inline void Config::set_allocated_config(::AxesCamController::Messages::Config* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(config_);
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:Guidance.AxesCamController.Messages.Config.config)
}

// -------------------------------------------------------------------

// ReferenceStatus

// .Guidance.Camera.Messages.Enum cam = 1;
inline void ReferenceStatus::clear_cam() {
  cam_ = 0;
}
inline ::Guidance::Camera::Messages::Enum ReferenceStatus::cam() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.ReferenceStatus.cam)
  return static_cast< ::Guidance::Camera::Messages::Enum >(cam_);
}
inline void ReferenceStatus::set_cam(::Guidance::Camera::Messages::Enum value) {
  
  cam_ = value;
  // @@protoc_insertion_point(field_set:Guidance.AxesCamController.Messages.ReferenceStatus.cam)
}

// .AxesCamController.Messages.ReferenceStatus status = 2;
inline bool ReferenceStatus::has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline const ::AxesCamController::Messages::ReferenceStatus& ReferenceStatus::status() const {
  const ::AxesCamController::Messages::ReferenceStatus* p = status_;
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.ReferenceStatus.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::AxesCamController::Messages::ReferenceStatus*>(
      &::AxesCamController::Messages::_ReferenceStatus_default_instance_);
}
inline ::AxesCamController::Messages::ReferenceStatus* ReferenceStatus::release_status() {
  // @@protoc_insertion_point(field_release:Guidance.AxesCamController.Messages.ReferenceStatus.status)
  
  ::AxesCamController::Messages::ReferenceStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::AxesCamController::Messages::ReferenceStatus* ReferenceStatus::mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::AxesCamController::Messages::ReferenceStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Guidance.AxesCamController.Messages.ReferenceStatus.status)
  return status_;
}
inline void ReferenceStatus::set_allocated_status(::AxesCamController::Messages::ReferenceStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:Guidance.AxesCamController.Messages.ReferenceStatus.status)
}

// -------------------------------------------------------------------

// Capabilities_Bounds

// float min = 1;
inline void Capabilities_Bounds::clear_min() {
  min_ = 0;
}
inline float Capabilities_Bounds::min() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Capabilities.Bounds.min)
  return min_;
}
inline void Capabilities_Bounds::set_min(float value) {
  
  min_ = value;
  // @@protoc_insertion_point(field_set:Guidance.AxesCamController.Messages.Capabilities.Bounds.min)
}

// float max = 2;
inline void Capabilities_Bounds::clear_max() {
  max_ = 0;
}
inline float Capabilities_Bounds::max() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Capabilities.Bounds.max)
  return max_;
}
inline void Capabilities_Bounds::set_max(float value) {
  
  max_ = value;
  // @@protoc_insertion_point(field_set:Guidance.AxesCamController.Messages.Capabilities.Bounds.max)
}

// -------------------------------------------------------------------

// Capabilities

// .Guidance.Camera.Messages.Enum cam = 1;
inline void Capabilities::clear_cam() {
  cam_ = 0;
}
inline ::Guidance::Camera::Messages::Enum Capabilities::cam() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Capabilities.cam)
  return static_cast< ::Guidance::Camera::Messages::Enum >(cam_);
}
inline void Capabilities::set_cam(::Guidance::Camera::Messages::Enum value) {
  
  cam_ = value;
  // @@protoc_insertion_point(field_set:Guidance.AxesCamController.Messages.Capabilities.cam)
}

// bool yaw_drivable = 2;
inline void Capabilities::clear_yaw_drivable() {
  yaw_drivable_ = false;
}
inline bool Capabilities::yaw_drivable() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Capabilities.yaw_drivable)
  return yaw_drivable_;
}
inline void Capabilities::set_yaw_drivable(bool value) {
  
  yaw_drivable_ = value;
  // @@protoc_insertion_point(field_set:Guidance.AxesCamController.Messages.Capabilities.yaw_drivable)
}

// bool pitch_drivable = 3;
inline void Capabilities::clear_pitch_drivable() {
  pitch_drivable_ = false;
}
inline bool Capabilities::pitch_drivable() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Capabilities.pitch_drivable)
  return pitch_drivable_;
}
inline void Capabilities::set_pitch_drivable(bool value) {
  
  pitch_drivable_ = value;
  // @@protoc_insertion_point(field_set:Guidance.AxesCamController.Messages.Capabilities.pitch_drivable)
}

// bool roll_drivable = 4;
inline void Capabilities::clear_roll_drivable() {
  roll_drivable_ = false;
}
inline bool Capabilities::roll_drivable() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Capabilities.roll_drivable)
  return roll_drivable_;
}
inline void Capabilities::set_roll_drivable(bool value) {
  
  roll_drivable_ = value;
  // @@protoc_insertion_point(field_set:Guidance.AxesCamController.Messages.Capabilities.roll_drivable)
}

// .Guidance.AxesCamController.Messages.Capabilities.Bounds yaw_bounds = 5;
inline bool Capabilities::has_yaw_bounds() const {
  return this != internal_default_instance() && yaw_bounds_ != nullptr;
}
inline void Capabilities::clear_yaw_bounds() {
  if (GetArenaNoVirtual() == nullptr && yaw_bounds_ != nullptr) {
    delete yaw_bounds_;
  }
  yaw_bounds_ = nullptr;
}
inline const ::Guidance::AxesCamController::Messages::Capabilities_Bounds& Capabilities::yaw_bounds() const {
  const ::Guidance::AxesCamController::Messages::Capabilities_Bounds* p = yaw_bounds_;
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Capabilities.yaw_bounds)
  return p != nullptr ? *p : *reinterpret_cast<const ::Guidance::AxesCamController::Messages::Capabilities_Bounds*>(
      &::Guidance::AxesCamController::Messages::_Capabilities_Bounds_default_instance_);
}
inline ::Guidance::AxesCamController::Messages::Capabilities_Bounds* Capabilities::release_yaw_bounds() {
  // @@protoc_insertion_point(field_release:Guidance.AxesCamController.Messages.Capabilities.yaw_bounds)
  
  ::Guidance::AxesCamController::Messages::Capabilities_Bounds* temp = yaw_bounds_;
  yaw_bounds_ = nullptr;
  return temp;
}
inline ::Guidance::AxesCamController::Messages::Capabilities_Bounds* Capabilities::mutable_yaw_bounds() {
  
  if (yaw_bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::Guidance::AxesCamController::Messages::Capabilities_Bounds>(GetArenaNoVirtual());
    yaw_bounds_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Guidance.AxesCamController.Messages.Capabilities.yaw_bounds)
  return yaw_bounds_;
}
inline void Capabilities::set_allocated_yaw_bounds(::Guidance::AxesCamController::Messages::Capabilities_Bounds* yaw_bounds) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete yaw_bounds_;
  }
  if (yaw_bounds) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      yaw_bounds = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yaw_bounds, submessage_arena);
    }
    
  } else {
    
  }
  yaw_bounds_ = yaw_bounds;
  // @@protoc_insertion_point(field_set_allocated:Guidance.AxesCamController.Messages.Capabilities.yaw_bounds)
}

// .Guidance.AxesCamController.Messages.Capabilities.Bounds pitch_bounds = 6;
inline bool Capabilities::has_pitch_bounds() const {
  return this != internal_default_instance() && pitch_bounds_ != nullptr;
}
inline void Capabilities::clear_pitch_bounds() {
  if (GetArenaNoVirtual() == nullptr && pitch_bounds_ != nullptr) {
    delete pitch_bounds_;
  }
  pitch_bounds_ = nullptr;
}
inline const ::Guidance::AxesCamController::Messages::Capabilities_Bounds& Capabilities::pitch_bounds() const {
  const ::Guidance::AxesCamController::Messages::Capabilities_Bounds* p = pitch_bounds_;
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Capabilities.pitch_bounds)
  return p != nullptr ? *p : *reinterpret_cast<const ::Guidance::AxesCamController::Messages::Capabilities_Bounds*>(
      &::Guidance::AxesCamController::Messages::_Capabilities_Bounds_default_instance_);
}
inline ::Guidance::AxesCamController::Messages::Capabilities_Bounds* Capabilities::release_pitch_bounds() {
  // @@protoc_insertion_point(field_release:Guidance.AxesCamController.Messages.Capabilities.pitch_bounds)
  
  ::Guidance::AxesCamController::Messages::Capabilities_Bounds* temp = pitch_bounds_;
  pitch_bounds_ = nullptr;
  return temp;
}
inline ::Guidance::AxesCamController::Messages::Capabilities_Bounds* Capabilities::mutable_pitch_bounds() {
  
  if (pitch_bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::Guidance::AxesCamController::Messages::Capabilities_Bounds>(GetArenaNoVirtual());
    pitch_bounds_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Guidance.AxesCamController.Messages.Capabilities.pitch_bounds)
  return pitch_bounds_;
}
inline void Capabilities::set_allocated_pitch_bounds(::Guidance::AxesCamController::Messages::Capabilities_Bounds* pitch_bounds) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pitch_bounds_;
  }
  if (pitch_bounds) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pitch_bounds = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pitch_bounds, submessage_arena);
    }
    
  } else {
    
  }
  pitch_bounds_ = pitch_bounds;
  // @@protoc_insertion_point(field_set_allocated:Guidance.AxesCamController.Messages.Capabilities.pitch_bounds)
}

// .Guidance.AxesCamController.Messages.Capabilities.Bounds roll_bounds = 7;
inline bool Capabilities::has_roll_bounds() const {
  return this != internal_default_instance() && roll_bounds_ != nullptr;
}
inline void Capabilities::clear_roll_bounds() {
  if (GetArenaNoVirtual() == nullptr && roll_bounds_ != nullptr) {
    delete roll_bounds_;
  }
  roll_bounds_ = nullptr;
}
inline const ::Guidance::AxesCamController::Messages::Capabilities_Bounds& Capabilities::roll_bounds() const {
  const ::Guidance::AxesCamController::Messages::Capabilities_Bounds* p = roll_bounds_;
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Capabilities.roll_bounds)
  return p != nullptr ? *p : *reinterpret_cast<const ::Guidance::AxesCamController::Messages::Capabilities_Bounds*>(
      &::Guidance::AxesCamController::Messages::_Capabilities_Bounds_default_instance_);
}
inline ::Guidance::AxesCamController::Messages::Capabilities_Bounds* Capabilities::release_roll_bounds() {
  // @@protoc_insertion_point(field_release:Guidance.AxesCamController.Messages.Capabilities.roll_bounds)
  
  ::Guidance::AxesCamController::Messages::Capabilities_Bounds* temp = roll_bounds_;
  roll_bounds_ = nullptr;
  return temp;
}
inline ::Guidance::AxesCamController::Messages::Capabilities_Bounds* Capabilities::mutable_roll_bounds() {
  
  if (roll_bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::Guidance::AxesCamController::Messages::Capabilities_Bounds>(GetArenaNoVirtual());
    roll_bounds_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Guidance.AxesCamController.Messages.Capabilities.roll_bounds)
  return roll_bounds_;
}
inline void Capabilities::set_allocated_roll_bounds(::Guidance::AxesCamController::Messages::Capabilities_Bounds* roll_bounds) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete roll_bounds_;
  }
  if (roll_bounds) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      roll_bounds = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roll_bounds, submessage_arena);
    }
    
  } else {
    
  }
  roll_bounds_ = roll_bounds;
  // @@protoc_insertion_point(field_set_allocated:Guidance.AxesCamController.Messages.Capabilities.roll_bounds)
}

// -------------------------------------------------------------------

// Command

// .Guidance.AxesCamController.Messages.Reset reset = 1;
inline bool Command::has_reset() const {
  return id_case() == kReset;
}
inline void Command::set_has_reset() {
  _oneof_case_[0] = kReset;
}
inline void Command::clear_reset() {
  if (has_reset()) {
    delete id_.reset_;
    clear_has_id();
  }
}
inline ::Guidance::AxesCamController::Messages::Reset* Command::release_reset() {
  // @@protoc_insertion_point(field_release:Guidance.AxesCamController.Messages.Command.reset)
  if (has_reset()) {
    clear_has_id();
      ::Guidance::AxesCamController::Messages::Reset* temp = id_.reset_;
    id_.reset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::AxesCamController::Messages::Reset& Command::reset() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Command.reset)
  return has_reset()
      ? *id_.reset_
      : *reinterpret_cast< ::Guidance::AxesCamController::Messages::Reset*>(&::Guidance::AxesCamController::Messages::_Reset_default_instance_);
}
inline ::Guidance::AxesCamController::Messages::Reset* Command::mutable_reset() {
  if (!has_reset()) {
    clear_id();
    set_has_reset();
    id_.reset_ = CreateMaybeMessage< ::Guidance::AxesCamController::Messages::Reset >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.AxesCamController.Messages.Command.reset)
  return id_.reset_;
}

// .Guidance.AxesCamController.Messages.Reference set_reference = 2;
inline bool Command::has_set_reference() const {
  return id_case() == kSetReference;
}
inline void Command::set_has_set_reference() {
  _oneof_case_[0] = kSetReference;
}
inline void Command::clear_set_reference() {
  if (has_set_reference()) {
    delete id_.set_reference_;
    clear_has_id();
  }
}
inline ::Guidance::AxesCamController::Messages::Reference* Command::release_set_reference() {
  // @@protoc_insertion_point(field_release:Guidance.AxesCamController.Messages.Command.set_reference)
  if (has_set_reference()) {
    clear_has_id();
      ::Guidance::AxesCamController::Messages::Reference* temp = id_.set_reference_;
    id_.set_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::AxesCamController::Messages::Reference& Command::set_reference() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Command.set_reference)
  return has_set_reference()
      ? *id_.set_reference_
      : *reinterpret_cast< ::Guidance::AxesCamController::Messages::Reference*>(&::Guidance::AxesCamController::Messages::_Reference_default_instance_);
}
inline ::Guidance::AxesCamController::Messages::Reference* Command::mutable_set_reference() {
  if (!has_set_reference()) {
    clear_id();
    set_has_set_reference();
    id_.set_reference_ = CreateMaybeMessage< ::Guidance::AxesCamController::Messages::Reference >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.AxesCamController.Messages.Command.set_reference)
  return id_.set_reference_;
}

// .Guidance.AxesCamController.Messages.Config set_config = 3;
inline bool Command::has_set_config() const {
  return id_case() == kSetConfig;
}
inline void Command::set_has_set_config() {
  _oneof_case_[0] = kSetConfig;
}
inline void Command::clear_set_config() {
  if (has_set_config()) {
    delete id_.set_config_;
    clear_has_id();
  }
}
inline ::Guidance::AxesCamController::Messages::Config* Command::release_set_config() {
  // @@protoc_insertion_point(field_release:Guidance.AxesCamController.Messages.Command.set_config)
  if (has_set_config()) {
    clear_has_id();
      ::Guidance::AxesCamController::Messages::Config* temp = id_.set_config_;
    id_.set_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::AxesCamController::Messages::Config& Command::set_config() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Command.set_config)
  return has_set_config()
      ? *id_.set_config_
      : *reinterpret_cast< ::Guidance::AxesCamController::Messages::Config*>(&::Guidance::AxesCamController::Messages::_Config_default_instance_);
}
inline ::Guidance::AxesCamController::Messages::Config* Command::mutable_set_config() {
  if (!has_set_config()) {
    clear_id();
    set_has_set_config();
    id_.set_config_ = CreateMaybeMessage< ::Guidance::AxesCamController::Messages::Config >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.AxesCamController.Messages.Command.set_config)
  return id_.set_config_;
}

inline bool Command::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void Command::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline Command::IdCase Command::id_case() const {
  return Command::IdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event

// .Guidance.AxesCamController.Messages.Config config = 1;
inline bool Event::has_config() const {
  return id_case() == kConfig;
}
inline void Event::set_has_config() {
  _oneof_case_[0] = kConfig;
}
inline void Event::clear_config() {
  if (has_config()) {
    delete id_.config_;
    clear_has_id();
  }
}
inline ::Guidance::AxesCamController::Messages::Config* Event::release_config() {
  // @@protoc_insertion_point(field_release:Guidance.AxesCamController.Messages.Event.config)
  if (has_config()) {
    clear_has_id();
      ::Guidance::AxesCamController::Messages::Config* temp = id_.config_;
    id_.config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::AxesCamController::Messages::Config& Event::config() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Event.config)
  return has_config()
      ? *id_.config_
      : *reinterpret_cast< ::Guidance::AxesCamController::Messages::Config*>(&::Guidance::AxesCamController::Messages::_Config_default_instance_);
}
inline ::Guidance::AxesCamController::Messages::Config* Event::mutable_config() {
  if (!has_config()) {
    clear_id();
    set_has_config();
    id_.config_ = CreateMaybeMessage< ::Guidance::AxesCamController::Messages::Config >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.AxesCamController.Messages.Event.config)
  return id_.config_;
}

// .Guidance.AxesCamController.Messages.ReferenceStatus reference_status = 2;
inline bool Event::has_reference_status() const {
  return id_case() == kReferenceStatus;
}
inline void Event::set_has_reference_status() {
  _oneof_case_[0] = kReferenceStatus;
}
inline void Event::clear_reference_status() {
  if (has_reference_status()) {
    delete id_.reference_status_;
    clear_has_id();
  }
}
inline ::Guidance::AxesCamController::Messages::ReferenceStatus* Event::release_reference_status() {
  // @@protoc_insertion_point(field_release:Guidance.AxesCamController.Messages.Event.reference_status)
  if (has_reference_status()) {
    clear_has_id();
      ::Guidance::AxesCamController::Messages::ReferenceStatus* temp = id_.reference_status_;
    id_.reference_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::AxesCamController::Messages::ReferenceStatus& Event::reference_status() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Event.reference_status)
  return has_reference_status()
      ? *id_.reference_status_
      : *reinterpret_cast< ::Guidance::AxesCamController::Messages::ReferenceStatus*>(&::Guidance::AxesCamController::Messages::_ReferenceStatus_default_instance_);
}
inline ::Guidance::AxesCamController::Messages::ReferenceStatus* Event::mutable_reference_status() {
  if (!has_reference_status()) {
    clear_id();
    set_has_reference_status();
    id_.reference_status_ = CreateMaybeMessage< ::Guidance::AxesCamController::Messages::ReferenceStatus >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.AxesCamController.Messages.Event.reference_status)
  return id_.reference_status_;
}

// .Guidance.AxesCamController.Messages.Capabilities capabilities = 3;
inline bool Event::has_capabilities() const {
  return id_case() == kCapabilities;
}
inline void Event::set_has_capabilities() {
  _oneof_case_[0] = kCapabilities;
}
inline void Event::clear_capabilities() {
  if (has_capabilities()) {
    delete id_.capabilities_;
    clear_has_id();
  }
}
inline ::Guidance::AxesCamController::Messages::Capabilities* Event::release_capabilities() {
  // @@protoc_insertion_point(field_release:Guidance.AxesCamController.Messages.Event.capabilities)
  if (has_capabilities()) {
    clear_has_id();
      ::Guidance::AxesCamController::Messages::Capabilities* temp = id_.capabilities_;
    id_.capabilities_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::AxesCamController::Messages::Capabilities& Event::capabilities() const {
  // @@protoc_insertion_point(field_get:Guidance.AxesCamController.Messages.Event.capabilities)
  return has_capabilities()
      ? *id_.capabilities_
      : *reinterpret_cast< ::Guidance::AxesCamController::Messages::Capabilities*>(&::Guidance::AxesCamController::Messages::_Capabilities_default_instance_);
}
inline ::Guidance::AxesCamController::Messages::Capabilities* Event::mutable_capabilities() {
  if (!has_capabilities()) {
    clear_id();
    set_has_capabilities();
    id_.capabilities_ = CreateMaybeMessage< ::Guidance::AxesCamController::Messages::Capabilities >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.AxesCamController.Messages.Event.capabilities)
  return id_.capabilities_;
}

inline bool Event::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void Event::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline Event::IdCase Event::id_case() const {
  return Event::IdCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Messages
}  // namespace AxesCamController
}  // namespace Guidance

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_guidance_2faxes_5fcam_5fcontroller_2eproto
