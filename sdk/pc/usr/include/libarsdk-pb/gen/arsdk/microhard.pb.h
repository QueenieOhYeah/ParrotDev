// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: arsdk/microhard.proto

#ifndef PROTOBUF_INCLUDED_arsdk_2fmicrohard_2eproto
#define PROTOBUF_INCLUDED_arsdk_2fmicrohard_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "parrot/protobuf/extensions.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_arsdk_2fmicrohard_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_arsdk_2fmicrohard_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[22]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_arsdk_2fmicrohard_2eproto();
namespace arsdk {
namespace microhard {
class Capabilities;
class CapabilitiesDefaultTypeInternal;
extern CapabilitiesDefaultTypeInternal _Capabilities_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class Command_GetState;
class Command_GetStateDefaultTypeInternal;
extern Command_GetStateDefaultTypeInternal _Command_GetState_default_instance_;
class Command_PairDevice;
class Command_PairDeviceDefaultTypeInternal;
extern Command_PairDeviceDefaultTypeInternal _Command_PairDevice_default_instance_;
class Command_PowerOn;
class Command_PowerOnDefaultTypeInternal;
extern Command_PowerOnDefaultTypeInternal _Command_PowerOn_default_instance_;
class Command_ShutDown;
class Command_ShutDownDefaultTypeInternal;
extern Command_ShutDownDefaultTypeInternal _Command_ShutDown_default_instance_;
class ConnectionParameters;
class ConnectionParametersDefaultTypeInternal;
extern ConnectionParametersDefaultTypeInternal _ConnectionParameters_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Event_HardwareError;
class Event_HardwareErrorDefaultTypeInternal;
extern Event_HardwareErrorDefaultTypeInternal _Event_HardwareError_default_instance_;
class Event_Pairing;
class Event_PairingDefaultTypeInternal;
extern Event_PairingDefaultTypeInternal _Event_Pairing_default_instance_;
class Event_State;
class Event_StateDefaultTypeInternal;
extern Event_StateDefaultTypeInternal _Event_State_default_instance_;
class PairingParameters;
class PairingParametersDefaultTypeInternal;
extern PairingParametersDefaultTypeInternal _PairingParameters_default_instance_;
class PairingStatus;
class PairingStatusDefaultTypeInternal;
extern PairingStatusDefaultTypeInternal _PairingStatus_default_instance_;
class PairingStatus_Failure;
class PairingStatus_FailureDefaultTypeInternal;
extern PairingStatus_FailureDefaultTypeInternal _PairingStatus_Failure_default_instance_;
class PairingStatus_Success;
class PairingStatus_SuccessDefaultTypeInternal;
extern PairingStatus_SuccessDefaultTypeInternal _PairingStatus_Success_default_instance_;
class State;
class StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
class State_Booting;
class State_BootingDefaultTypeInternal;
extern State_BootingDefaultTypeInternal _State_Booting_default_instance_;
class State_Connected;
class State_ConnectedDefaultTypeInternal;
extern State_ConnectedDefaultTypeInternal _State_Connected_default_instance_;
class State_Connecting;
class State_ConnectingDefaultTypeInternal;
extern State_ConnectingDefaultTypeInternal _State_Connecting_default_instance_;
class State_Idle;
class State_IdleDefaultTypeInternal;
extern State_IdleDefaultTypeInternal _State_Idle_default_instance_;
class State_Offline;
class State_OfflineDefaultTypeInternal;
extern State_OfflineDefaultTypeInternal _State_Offline_default_instance_;
class State_Pairing;
class State_PairingDefaultTypeInternal;
extern State_PairingDefaultTypeInternal _State_Pairing_default_instance_;
}  // namespace microhard
}  // namespace arsdk
namespace google {
namespace protobuf {
template<> ::arsdk::microhard::Capabilities* Arena::CreateMaybeMessage<::arsdk::microhard::Capabilities>(Arena*);
template<> ::arsdk::microhard::Command* Arena::CreateMaybeMessage<::arsdk::microhard::Command>(Arena*);
template<> ::arsdk::microhard::Command_GetState* Arena::CreateMaybeMessage<::arsdk::microhard::Command_GetState>(Arena*);
template<> ::arsdk::microhard::Command_PairDevice* Arena::CreateMaybeMessage<::arsdk::microhard::Command_PairDevice>(Arena*);
template<> ::arsdk::microhard::Command_PowerOn* Arena::CreateMaybeMessage<::arsdk::microhard::Command_PowerOn>(Arena*);
template<> ::arsdk::microhard::Command_ShutDown* Arena::CreateMaybeMessage<::arsdk::microhard::Command_ShutDown>(Arena*);
template<> ::arsdk::microhard::ConnectionParameters* Arena::CreateMaybeMessage<::arsdk::microhard::ConnectionParameters>(Arena*);
template<> ::arsdk::microhard::Event* Arena::CreateMaybeMessage<::arsdk::microhard::Event>(Arena*);
template<> ::arsdk::microhard::Event_HardwareError* Arena::CreateMaybeMessage<::arsdk::microhard::Event_HardwareError>(Arena*);
template<> ::arsdk::microhard::Event_Pairing* Arena::CreateMaybeMessage<::arsdk::microhard::Event_Pairing>(Arena*);
template<> ::arsdk::microhard::Event_State* Arena::CreateMaybeMessage<::arsdk::microhard::Event_State>(Arena*);
template<> ::arsdk::microhard::PairingParameters* Arena::CreateMaybeMessage<::arsdk::microhard::PairingParameters>(Arena*);
template<> ::arsdk::microhard::PairingStatus* Arena::CreateMaybeMessage<::arsdk::microhard::PairingStatus>(Arena*);
template<> ::arsdk::microhard::PairingStatus_Failure* Arena::CreateMaybeMessage<::arsdk::microhard::PairingStatus_Failure>(Arena*);
template<> ::arsdk::microhard::PairingStatus_Success* Arena::CreateMaybeMessage<::arsdk::microhard::PairingStatus_Success>(Arena*);
template<> ::arsdk::microhard::State* Arena::CreateMaybeMessage<::arsdk::microhard::State>(Arena*);
template<> ::arsdk::microhard::State_Booting* Arena::CreateMaybeMessage<::arsdk::microhard::State_Booting>(Arena*);
template<> ::arsdk::microhard::State_Connected* Arena::CreateMaybeMessage<::arsdk::microhard::State_Connected>(Arena*);
template<> ::arsdk::microhard::State_Connecting* Arena::CreateMaybeMessage<::arsdk::microhard::State_Connecting>(Arena*);
template<> ::arsdk::microhard::State_Idle* Arena::CreateMaybeMessage<::arsdk::microhard::State_Idle>(Arena*);
template<> ::arsdk::microhard::State_Offline* Arena::CreateMaybeMessage<::arsdk::microhard::State_Offline>(Arena*);
template<> ::arsdk::microhard::State_Pairing* Arena::CreateMaybeMessage<::arsdk::microhard::State_Pairing>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace arsdk {
namespace microhard {

enum Bandwidth {
  BANDWIDTH_1MHZ = 0,
  BANDWIDTH_2MHZ = 1,
  BANDWIDTH_4MHZ = 2,
  BANDWIDTH_8MHZ = 3,
  Bandwidth_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Bandwidth_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Bandwidth_IsValid(int value);
const Bandwidth Bandwidth_MIN = BANDWIDTH_1MHZ;
const Bandwidth Bandwidth_MAX = BANDWIDTH_8MHZ;
const int Bandwidth_ARRAYSIZE = Bandwidth_MAX + 1;

const ::google::protobuf::EnumDescriptor* Bandwidth_descriptor();
inline const ::std::string& Bandwidth_Name(Bandwidth value) {
  return ::google::protobuf::internal::NameOfEnum(
    Bandwidth_descriptor(), value);
}
inline bool Bandwidth_Parse(
    const ::std::string& name, Bandwidth* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Bandwidth>(
    Bandwidth_descriptor(), name, value);
}
enum Encryption {
  ENCRYPTION_NONE = 0,
  ENCRYPTION_AES128 = 1,
  ENCRYPTION_AES256 = 2,
  Encryption_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Encryption_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Encryption_IsValid(int value);
const Encryption Encryption_MIN = ENCRYPTION_NONE;
const Encryption Encryption_MAX = ENCRYPTION_AES256;
const int Encryption_ARRAYSIZE = Encryption_MAX + 1;

const ::google::protobuf::EnumDescriptor* Encryption_descriptor();
inline const ::std::string& Encryption_Name(Encryption value) {
  return ::google::protobuf::internal::NameOfEnum(
    Encryption_descriptor(), value);
}
inline bool Encryption_Parse(
    const ::std::string& name, Encryption* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Encryption>(
    Encryption_descriptor(), name, value);
}
enum HardwareErrorCause {
  HARDWARE_ERROR_CAUSE_INTERNAL = 0,
  HardwareErrorCause_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  HardwareErrorCause_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool HardwareErrorCause_IsValid(int value);
const HardwareErrorCause HardwareErrorCause_MIN = HARDWARE_ERROR_CAUSE_INTERNAL;
const HardwareErrorCause HardwareErrorCause_MAX = HARDWARE_ERROR_CAUSE_INTERNAL;
const int HardwareErrorCause_ARRAYSIZE = HardwareErrorCause_MAX + 1;

const ::google::protobuf::EnumDescriptor* HardwareErrorCause_descriptor();
inline const ::std::string& HardwareErrorCause_Name(HardwareErrorCause value) {
  return ::google::protobuf::internal::NameOfEnum(
    HardwareErrorCause_descriptor(), value);
}
inline bool HardwareErrorCause_Parse(
    const ::std::string& name, HardwareErrorCause* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HardwareErrorCause>(
    HardwareErrorCause_descriptor(), name, value);
}
enum PairingFailureReason {
  PAIRING_FAILURE_REASON_INTERNAL_ERROR = 0,
  PAIRING_FAILURE_REASON_ALREADY_PAIRED = 1,
  PAIRING_FAILURE_REASON_DEVICE_NOT_REACHABLE = 2,
  PAIRING_FAILURE_REASON_INVALID_STATE = 3,
  PAIRING_FAILURE_REASON_INVALID_CONFIG = 4,
  PairingFailureReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  PairingFailureReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool PairingFailureReason_IsValid(int value);
const PairingFailureReason PairingFailureReason_MIN = PAIRING_FAILURE_REASON_INTERNAL_ERROR;
const PairingFailureReason PairingFailureReason_MAX = PAIRING_FAILURE_REASON_INVALID_CONFIG;
const int PairingFailureReason_ARRAYSIZE = PairingFailureReason_MAX + 1;

const ::google::protobuf::EnumDescriptor* PairingFailureReason_descriptor();
inline const ::std::string& PairingFailureReason_Name(PairingFailureReason value) {
  return ::google::protobuf::internal::NameOfEnum(
    PairingFailureReason_descriptor(), value);
}
inline bool PairingFailureReason_Parse(
    const ::std::string& name, PairingFailureReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PairingFailureReason>(
    PairingFailureReason_descriptor(), name, value);
}
// ===================================================================

class Command_GetState :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.Command.GetState) */ {
 public:
  Command_GetState();
  virtual ~Command_GetState();

  Command_GetState(const Command_GetState& from);

  inline Command_GetState& operator=(const Command_GetState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command_GetState(Command_GetState&& from) noexcept
    : Command_GetState() {
    *this = ::std::move(from);
  }

  inline Command_GetState& operator=(Command_GetState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command_GetState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command_GetState* internal_default_instance() {
    return reinterpret_cast<const Command_GetState*>(
               &_Command_GetState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Command_GetState* other);
  friend void swap(Command_GetState& a, Command_GetState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command_GetState* New() const final {
    return CreateMaybeMessage<Command_GetState>(nullptr);
  }

  Command_GetState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command_GetState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command_GetState& from);
  void MergeFrom(const Command_GetState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command_GetState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool include_default_capabilities = 1;
  void clear_include_default_capabilities();
  static const int kIncludeDefaultCapabilitiesFieldNumber = 1;
  bool include_default_capabilities() const;
  void set_include_default_capabilities(bool value);

  // @@protoc_insertion_point(class_scope:arsdk.microhard.Command.GetState)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool include_default_capabilities_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class Command_PowerOn :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.Command.PowerOn) */ {
 public:
  Command_PowerOn();
  virtual ~Command_PowerOn();

  Command_PowerOn(const Command_PowerOn& from);

  inline Command_PowerOn& operator=(const Command_PowerOn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command_PowerOn(Command_PowerOn&& from) noexcept
    : Command_PowerOn() {
    *this = ::std::move(from);
  }

  inline Command_PowerOn& operator=(Command_PowerOn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command_PowerOn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command_PowerOn* internal_default_instance() {
    return reinterpret_cast<const Command_PowerOn*>(
               &_Command_PowerOn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Command_PowerOn* other);
  friend void swap(Command_PowerOn& a, Command_PowerOn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command_PowerOn* New() const final {
    return CreateMaybeMessage<Command_PowerOn>(nullptr);
  }

  Command_PowerOn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command_PowerOn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command_PowerOn& from);
  void MergeFrom(const Command_PowerOn& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command_PowerOn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:arsdk.microhard.Command.PowerOn)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class Command_ShutDown :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.Command.ShutDown) */ {
 public:
  Command_ShutDown();
  virtual ~Command_ShutDown();

  Command_ShutDown(const Command_ShutDown& from);

  inline Command_ShutDown& operator=(const Command_ShutDown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command_ShutDown(Command_ShutDown&& from) noexcept
    : Command_ShutDown() {
    *this = ::std::move(from);
  }

  inline Command_ShutDown& operator=(Command_ShutDown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command_ShutDown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command_ShutDown* internal_default_instance() {
    return reinterpret_cast<const Command_ShutDown*>(
               &_Command_ShutDown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Command_ShutDown* other);
  friend void swap(Command_ShutDown& a, Command_ShutDown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command_ShutDown* New() const final {
    return CreateMaybeMessage<Command_ShutDown>(nullptr);
  }

  Command_ShutDown* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command_ShutDown>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command_ShutDown& from);
  void MergeFrom(const Command_ShutDown& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command_ShutDown* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:arsdk.microhard.Command.ShutDown)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class Command_PairDevice :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.Command.PairDevice) */ {
 public:
  Command_PairDevice();
  virtual ~Command_PairDevice();

  Command_PairDevice(const Command_PairDevice& from);

  inline Command_PairDevice& operator=(const Command_PairDevice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command_PairDevice(Command_PairDevice&& from) noexcept
    : Command_PairDevice() {
    *this = ::std::move(from);
  }

  inline Command_PairDevice& operator=(Command_PairDevice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command_PairDevice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command_PairDevice* internal_default_instance() {
    return reinterpret_cast<const Command_PairDevice*>(
               &_Command_PairDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Command_PairDevice* other);
  friend void swap(Command_PairDevice& a, Command_PairDevice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command_PairDevice* New() const final {
    return CreateMaybeMessage<Command_PairDevice>(nullptr);
  }

  Command_PairDevice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command_PairDevice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command_PairDevice& from);
  void MergeFrom(const Command_PairDevice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command_PairDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string network_id = 1;
  void clear_network_id();
  static const int kNetworkIdFieldNumber = 1;
  const ::std::string& network_id() const;
  void set_network_id(const ::std::string& value);
  #if LANG_CXX11
  void set_network_id(::std::string&& value);
  #endif
  void set_network_id(const char* value);
  void set_network_id(const char* value, size_t size);
  ::std::string* mutable_network_id();
  ::std::string* release_network_id();
  void set_allocated_network_id(::std::string* network_id);

  // string encryption_key = 2;
  void clear_encryption_key();
  static const int kEncryptionKeyFieldNumber = 2;
  const ::std::string& encryption_key() const;
  void set_encryption_key(const ::std::string& value);
  #if LANG_CXX11
  void set_encryption_key(::std::string&& value);
  #endif
  void set_encryption_key(const char* value);
  void set_encryption_key(const char* value, size_t size);
  ::std::string* mutable_encryption_key();
  ::std::string* release_encryption_key();
  void set_allocated_encryption_key(::std::string* encryption_key);

  // .arsdk.microhard.PairingParameters pairing_parameters = 3;
  bool has_pairing_parameters() const;
  void clear_pairing_parameters();
  static const int kPairingParametersFieldNumber = 3;
  const ::arsdk::microhard::PairingParameters& pairing_parameters() const;
  ::arsdk::microhard::PairingParameters* release_pairing_parameters();
  ::arsdk::microhard::PairingParameters* mutable_pairing_parameters();
  void set_allocated_pairing_parameters(::arsdk::microhard::PairingParameters* pairing_parameters);

  // .arsdk.microhard.ConnectionParameters connection_parameters = 4;
  bool has_connection_parameters() const;
  void clear_connection_parameters();
  static const int kConnectionParametersFieldNumber = 4;
  const ::arsdk::microhard::ConnectionParameters& connection_parameters() const;
  ::arsdk::microhard::ConnectionParameters* release_connection_parameters();
  ::arsdk::microhard::ConnectionParameters* mutable_connection_parameters();
  void set_allocated_connection_parameters(::arsdk::microhard::ConnectionParameters* connection_parameters);

  // @@protoc_insertion_point(class_scope:arsdk.microhard.Command.PairDevice)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr network_id_;
  ::google::protobuf::internal::ArenaStringPtr encryption_key_;
  ::arsdk::microhard::PairingParameters* pairing_parameters_;
  ::arsdk::microhard::ConnectionParameters* connection_parameters_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class Command :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command& default_instance();

  enum IdCase {
    kGetState = 16,
    kPowerOn = 17,
    kShutdown = 18,
    kPairDevice = 19,
    ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Command_GetState GetState;
  typedef Command_PowerOn PowerOn;
  typedef Command_ShutDown ShutDown;
  typedef Command_PairDevice PairDevice;

  // accessors -------------------------------------------------------

  // .arsdk.microhard.Command.GetState get_state = 16;
  bool has_get_state() const;
  void clear_get_state();
  static const int kGetStateFieldNumber = 16;
  const ::arsdk::microhard::Command_GetState& get_state() const;
  ::arsdk::microhard::Command_GetState* release_get_state();
  ::arsdk::microhard::Command_GetState* mutable_get_state();
  void set_allocated_get_state(::arsdk::microhard::Command_GetState* get_state);

  // .arsdk.microhard.Command.PowerOn power_on = 17;
  bool has_power_on() const;
  void clear_power_on();
  static const int kPowerOnFieldNumber = 17;
  const ::arsdk::microhard::Command_PowerOn& power_on() const;
  ::arsdk::microhard::Command_PowerOn* release_power_on();
  ::arsdk::microhard::Command_PowerOn* mutable_power_on();
  void set_allocated_power_on(::arsdk::microhard::Command_PowerOn* power_on);

  // .arsdk.microhard.Command.ShutDown shutdown = 18;
  bool has_shutdown() const;
  void clear_shutdown();
  static const int kShutdownFieldNumber = 18;
  const ::arsdk::microhard::Command_ShutDown& shutdown() const;
  ::arsdk::microhard::Command_ShutDown* release_shutdown();
  ::arsdk::microhard::Command_ShutDown* mutable_shutdown();
  void set_allocated_shutdown(::arsdk::microhard::Command_ShutDown* shutdown);

  // .arsdk.microhard.Command.PairDevice pair_device = 19;
  bool has_pair_device() const;
  void clear_pair_device();
  static const int kPairDeviceFieldNumber = 19;
  const ::arsdk::microhard::Command_PairDevice& pair_device() const;
  ::arsdk::microhard::Command_PairDevice* release_pair_device();
  ::arsdk::microhard::Command_PairDevice* mutable_pair_device();
  void set_allocated_pair_device(::arsdk::microhard::Command_PairDevice* pair_device);

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:arsdk.microhard.Command)
 private:
  class HasBitSetters;
  void set_has_get_state();
  void set_has_power_on();
  void set_has_shutdown();
  void set_has_pair_device();

  inline bool has_id() const;
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    ::arsdk::microhard::Command_GetState* get_state_;
    ::arsdk::microhard::Command_PowerOn* power_on_;
    ::arsdk::microhard::Command_ShutDown* shutdown_;
    ::arsdk::microhard::Command_PairDevice* pair_device_;
  } id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class Event_State :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.Event.State) */ {
 public:
  Event_State();
  virtual ~Event_State();

  Event_State(const Event_State& from);

  inline Event_State& operator=(const Event_State& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_State(Event_State&& from) noexcept
    : Event_State() {
    *this = ::std::move(from);
  }

  inline Event_State& operator=(Event_State&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Event_State& default_instance();

  enum StateCase {
    kOffline = 2,
    kBooting = 3,
    kIdle = 4,
    kPairing = 5,
    kConnecting = 6,
    kConnected = 7,
    STATE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_State* internal_default_instance() {
    return reinterpret_cast<const Event_State*>(
               &_Event_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Event_State* other);
  friend void swap(Event_State& a, Event_State& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_State* New() const final {
    return CreateMaybeMessage<Event_State>(nullptr);
  }

  Event_State* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event_State>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event_State& from);
  void MergeFrom(const Event_State& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event_State* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .arsdk.microhard.Capabilities default_capabilities = 1;
  bool has_default_capabilities() const;
  void clear_default_capabilities();
  static const int kDefaultCapabilitiesFieldNumber = 1;
  const ::arsdk::microhard::Capabilities& default_capabilities() const;
  ::arsdk::microhard::Capabilities* release_default_capabilities();
  ::arsdk::microhard::Capabilities* mutable_default_capabilities();
  void set_allocated_default_capabilities(::arsdk::microhard::Capabilities* default_capabilities);

  // .arsdk.microhard.State.Offline offline = 2;
  bool has_offline() const;
  void clear_offline();
  static const int kOfflineFieldNumber = 2;
  const ::arsdk::microhard::State_Offline& offline() const;
  ::arsdk::microhard::State_Offline* release_offline();
  ::arsdk::microhard::State_Offline* mutable_offline();
  void set_allocated_offline(::arsdk::microhard::State_Offline* offline);

  // .arsdk.microhard.State.Booting booting = 3;
  bool has_booting() const;
  void clear_booting();
  static const int kBootingFieldNumber = 3;
  const ::arsdk::microhard::State_Booting& booting() const;
  ::arsdk::microhard::State_Booting* release_booting();
  ::arsdk::microhard::State_Booting* mutable_booting();
  void set_allocated_booting(::arsdk::microhard::State_Booting* booting);

  // .arsdk.microhard.State.Idle idle = 4;
  bool has_idle() const;
  void clear_idle();
  static const int kIdleFieldNumber = 4;
  const ::arsdk::microhard::State_Idle& idle() const;
  ::arsdk::microhard::State_Idle* release_idle();
  ::arsdk::microhard::State_Idle* mutable_idle();
  void set_allocated_idle(::arsdk::microhard::State_Idle* idle);

  // .arsdk.microhard.State.Pairing pairing = 5;
  bool has_pairing() const;
  void clear_pairing();
  static const int kPairingFieldNumber = 5;
  const ::arsdk::microhard::State_Pairing& pairing() const;
  ::arsdk::microhard::State_Pairing* release_pairing();
  ::arsdk::microhard::State_Pairing* mutable_pairing();
  void set_allocated_pairing(::arsdk::microhard::State_Pairing* pairing);

  // .arsdk.microhard.State.Connecting connecting = 6;
  bool has_connecting() const;
  void clear_connecting();
  static const int kConnectingFieldNumber = 6;
  const ::arsdk::microhard::State_Connecting& connecting() const;
  ::arsdk::microhard::State_Connecting* release_connecting();
  ::arsdk::microhard::State_Connecting* mutable_connecting();
  void set_allocated_connecting(::arsdk::microhard::State_Connecting* connecting);

  // .arsdk.microhard.State.Connected connected = 7;
  bool has_connected() const;
  void clear_connected();
  static const int kConnectedFieldNumber = 7;
  const ::arsdk::microhard::State_Connected& connected() const;
  ::arsdk::microhard::State_Connected* release_connected();
  ::arsdk::microhard::State_Connected* mutable_connected();
  void set_allocated_connected(::arsdk::microhard::State_Connected* connected);

  void clear_state();
  StateCase state_case() const;
  // @@protoc_insertion_point(class_scope:arsdk.microhard.Event.State)
 private:
  class HasBitSetters;
  void set_has_offline();
  void set_has_booting();
  void set_has_idle();
  void set_has_pairing();
  void set_has_connecting();
  void set_has_connected();

  inline bool has_state() const;
  inline void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::arsdk::microhard::Capabilities* default_capabilities_;
  union StateUnion {
    StateUnion() {}
    ::arsdk::microhard::State_Offline* offline_;
    ::arsdk::microhard::State_Booting* booting_;
    ::arsdk::microhard::State_Idle* idle_;
    ::arsdk::microhard::State_Pairing* pairing_;
    ::arsdk::microhard::State_Connecting* connecting_;
    ::arsdk::microhard::State_Connected* connected_;
  } state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class Event_HardwareError :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.Event.HardwareError) */ {
 public:
  Event_HardwareError();
  virtual ~Event_HardwareError();

  Event_HardwareError(const Event_HardwareError& from);

  inline Event_HardwareError& operator=(const Event_HardwareError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_HardwareError(Event_HardwareError&& from) noexcept
    : Event_HardwareError() {
    *this = ::std::move(from);
  }

  inline Event_HardwareError& operator=(Event_HardwareError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Event_HardwareError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_HardwareError* internal_default_instance() {
    return reinterpret_cast<const Event_HardwareError*>(
               &_Event_HardwareError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Event_HardwareError* other);
  friend void swap(Event_HardwareError& a, Event_HardwareError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_HardwareError* New() const final {
    return CreateMaybeMessage<Event_HardwareError>(nullptr);
  }

  Event_HardwareError* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event_HardwareError>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event_HardwareError& from);
  void MergeFrom(const Event_HardwareError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event_HardwareError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .arsdk.microhard.HardwareErrorCause cause = 1;
  void clear_cause();
  static const int kCauseFieldNumber = 1;
  ::arsdk::microhard::HardwareErrorCause cause() const;
  void set_cause(::arsdk::microhard::HardwareErrorCause value);

  // @@protoc_insertion_point(class_scope:arsdk.microhard.Event.HardwareError)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int cause_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class Event_Pairing :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.Event.Pairing) */ {
 public:
  Event_Pairing();
  virtual ~Event_Pairing();

  Event_Pairing(const Event_Pairing& from);

  inline Event_Pairing& operator=(const Event_Pairing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_Pairing(Event_Pairing&& from) noexcept
    : Event_Pairing() {
    *this = ::std::move(from);
  }

  inline Event_Pairing& operator=(Event_Pairing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Event_Pairing& default_instance();

  enum StatusCase {
    kFailure = 1,
    kSuccess = 2,
    STATUS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_Pairing* internal_default_instance() {
    return reinterpret_cast<const Event_Pairing*>(
               &_Event_Pairing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Event_Pairing* other);
  friend void swap(Event_Pairing& a, Event_Pairing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_Pairing* New() const final {
    return CreateMaybeMessage<Event_Pairing>(nullptr);
  }

  Event_Pairing* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event_Pairing>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event_Pairing& from);
  void MergeFrom(const Event_Pairing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event_Pairing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string network_id = 3;
  void clear_network_id();
  static const int kNetworkIdFieldNumber = 3;
  const ::std::string& network_id() const;
  void set_network_id(const ::std::string& value);
  #if LANG_CXX11
  void set_network_id(::std::string&& value);
  #endif
  void set_network_id(const char* value);
  void set_network_id(const char* value, size_t size);
  ::std::string* mutable_network_id();
  ::std::string* release_network_id();
  void set_allocated_network_id(::std::string* network_id);

  // .arsdk.microhard.PairingStatus.Failure failure = 1;
  bool has_failure() const;
  void clear_failure();
  static const int kFailureFieldNumber = 1;
  const ::arsdk::microhard::PairingStatus_Failure& failure() const;
  ::arsdk::microhard::PairingStatus_Failure* release_failure();
  ::arsdk::microhard::PairingStatus_Failure* mutable_failure();
  void set_allocated_failure(::arsdk::microhard::PairingStatus_Failure* failure);

  // .arsdk.microhard.PairingStatus.Success success = 2;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 2;
  const ::arsdk::microhard::PairingStatus_Success& success() const;
  ::arsdk::microhard::PairingStatus_Success* release_success();
  ::arsdk::microhard::PairingStatus_Success* mutable_success();
  void set_allocated_success(::arsdk::microhard::PairingStatus_Success* success);

  void clear_status();
  StatusCase status_case() const;
  // @@protoc_insertion_point(class_scope:arsdk.microhard.Event.Pairing)
 private:
  class HasBitSetters;
  void set_has_failure();
  void set_has_success();

  inline bool has_status() const;
  inline void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr network_id_;
  union StatusUnion {
    StatusUnion() {}
    ::arsdk::microhard::PairingStatus_Failure* failure_;
    ::arsdk::microhard::PairingStatus_Success* success_;
  } status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class Event :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Event& default_instance();

  enum IdCase {
    kState = 16,
    kHardwareError = 18,
    kPairing = 19,
    ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(nullptr);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Event_State State;
  typedef Event_HardwareError HardwareError;
  typedef Event_Pairing Pairing;

  // accessors -------------------------------------------------------

  // .arsdk.microhard.Event.State state = 16;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 16;
  const ::arsdk::microhard::Event_State& state() const;
  ::arsdk::microhard::Event_State* release_state();
  ::arsdk::microhard::Event_State* mutable_state();
  void set_allocated_state(::arsdk::microhard::Event_State* state);

  // .arsdk.microhard.Event.HardwareError hardware_error = 18;
  bool has_hardware_error() const;
  void clear_hardware_error();
  static const int kHardwareErrorFieldNumber = 18;
  const ::arsdk::microhard::Event_HardwareError& hardware_error() const;
  ::arsdk::microhard::Event_HardwareError* release_hardware_error();
  ::arsdk::microhard::Event_HardwareError* mutable_hardware_error();
  void set_allocated_hardware_error(::arsdk::microhard::Event_HardwareError* hardware_error);

  // .arsdk.microhard.Event.Pairing pairing = 19;
  bool has_pairing() const;
  void clear_pairing();
  static const int kPairingFieldNumber = 19;
  const ::arsdk::microhard::Event_Pairing& pairing() const;
  ::arsdk::microhard::Event_Pairing* release_pairing();
  ::arsdk::microhard::Event_Pairing* mutable_pairing();
  void set_allocated_pairing(::arsdk::microhard::Event_Pairing* pairing);

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:arsdk.microhard.Event)
 private:
  class HasBitSetters;
  void set_has_state();
  void set_has_hardware_error();
  void set_has_pairing();

  inline bool has_id() const;
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    ::arsdk::microhard::Event_State* state_;
    ::arsdk::microhard::Event_HardwareError* hardware_error_;
    ::arsdk::microhard::Event_Pairing* pairing_;
  } id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class Capabilities :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.Capabilities) */ {
 public:
  Capabilities();
  virtual ~Capabilities();

  Capabilities(const Capabilities& from);

  inline Capabilities& operator=(const Capabilities& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Capabilities(Capabilities&& from) noexcept
    : Capabilities() {
    *this = ::std::move(from);
  }

  inline Capabilities& operator=(Capabilities&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Capabilities& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Capabilities* internal_default_instance() {
    return reinterpret_cast<const Capabilities*>(
               &_Capabilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Capabilities* other);
  friend void swap(Capabilities& a, Capabilities& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Capabilities* New() const final {
    return CreateMaybeMessage<Capabilities>(nullptr);
  }

  Capabilities* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Capabilities>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Capabilities& from);
  void MergeFrom(const Capabilities& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Capabilities* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arsdk.microhard.Bandwidth bandwidths = 5;
  int bandwidths_size() const;
  void clear_bandwidths();
  static const int kBandwidthsFieldNumber = 5;
  ::arsdk::microhard::Bandwidth bandwidths(int index) const;
  void set_bandwidths(int index, ::arsdk::microhard::Bandwidth value);
  void add_bandwidths(::arsdk::microhard::Bandwidth value);
  const ::google::protobuf::RepeatedField<int>& bandwidths() const;
  ::google::protobuf::RepeatedField<int>* mutable_bandwidths();

  // repeated .arsdk.microhard.Encryption encryption_algorithms = 6;
  int encryption_algorithms_size() const;
  void clear_encryption_algorithms();
  static const int kEncryptionAlgorithmsFieldNumber = 6;
  ::arsdk::microhard::Encryption encryption_algorithms(int index) const;
  void set_encryption_algorithms(int index, ::arsdk::microhard::Encryption value);
  void add_encryption_algorithms(::arsdk::microhard::Encryption value);
  const ::google::protobuf::RepeatedField<int>& encryption_algorithms() const;
  ::google::protobuf::RepeatedField<int>* mutable_encryption_algorithms();

  // uint32 channel_min = 1;
  void clear_channel_min();
  static const int kChannelMinFieldNumber = 1;
  ::google::protobuf::uint32 channel_min() const;
  void set_channel_min(::google::protobuf::uint32 value);

  // uint32 channel_max = 2;
  void clear_channel_max();
  static const int kChannelMaxFieldNumber = 2;
  ::google::protobuf::uint32 channel_max() const;
  void set_channel_max(::google::protobuf::uint32 value);

  // uint32 power_min = 3;
  void clear_power_min();
  static const int kPowerMinFieldNumber = 3;
  ::google::protobuf::uint32 power_min() const;
  void set_power_min(::google::protobuf::uint32 value);

  // uint32 power_max = 4;
  void clear_power_max();
  static const int kPowerMaxFieldNumber = 4;
  ::google::protobuf::uint32 power_max() const;
  void set_power_max(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:arsdk.microhard.Capabilities)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField<int> bandwidths_;
  mutable std::atomic<int> _bandwidths_cached_byte_size_;
  ::google::protobuf::RepeatedField<int> encryption_algorithms_;
  mutable std::atomic<int> _encryption_algorithms_cached_byte_size_;
  ::google::protobuf::uint32 channel_min_;
  ::google::protobuf::uint32 channel_max_;
  ::google::protobuf::uint32 power_min_;
  ::google::protobuf::uint32 power_max_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class ConnectionParameters :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.ConnectionParameters) */ {
 public:
  ConnectionParameters();
  virtual ~ConnectionParameters();

  ConnectionParameters(const ConnectionParameters& from);

  inline ConnectionParameters& operator=(const ConnectionParameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionParameters(ConnectionParameters&& from) noexcept
    : ConnectionParameters() {
    *this = ::std::move(from);
  }

  inline ConnectionParameters& operator=(ConnectionParameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConnectionParameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionParameters* internal_default_instance() {
    return reinterpret_cast<const ConnectionParameters*>(
               &_ConnectionParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ConnectionParameters* other);
  friend void swap(ConnectionParameters& a, ConnectionParameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionParameters* New() const final {
    return CreateMaybeMessage<ConnectionParameters>(nullptr);
  }

  ConnectionParameters* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionParameters>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectionParameters& from);
  void MergeFrom(const ConnectionParameters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionParameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 channel = 1;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // uint32 power = 2;
  void clear_power();
  static const int kPowerFieldNumber = 2;
  ::google::protobuf::uint32 power() const;
  void set_power(::google::protobuf::uint32 value);

  // .arsdk.microhard.Bandwidth bandwidth = 3;
  void clear_bandwidth();
  static const int kBandwidthFieldNumber = 3;
  ::arsdk::microhard::Bandwidth bandwidth() const;
  void set_bandwidth(::arsdk::microhard::Bandwidth value);

  // @@protoc_insertion_point(class_scope:arsdk.microhard.ConnectionParameters)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint32 power_;
  int bandwidth_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class State_Offline :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.State.Offline) */ {
 public:
  State_Offline();
  virtual ~State_Offline();

  State_Offline(const State_Offline& from);

  inline State_Offline& operator=(const State_Offline& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  State_Offline(State_Offline&& from) noexcept
    : State_Offline() {
    *this = ::std::move(from);
  }

  inline State_Offline& operator=(State_Offline&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const State_Offline& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State_Offline* internal_default_instance() {
    return reinterpret_cast<const State_Offline*>(
               &_State_Offline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(State_Offline* other);
  friend void swap(State_Offline& a, State_Offline& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline State_Offline* New() const final {
    return CreateMaybeMessage<State_Offline>(nullptr);
  }

  State_Offline* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<State_Offline>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const State_Offline& from);
  void MergeFrom(const State_Offline& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State_Offline* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:arsdk.microhard.State.Offline)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class State_Booting :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.State.Booting) */ {
 public:
  State_Booting();
  virtual ~State_Booting();

  State_Booting(const State_Booting& from);

  inline State_Booting& operator=(const State_Booting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  State_Booting(State_Booting&& from) noexcept
    : State_Booting() {
    *this = ::std::move(from);
  }

  inline State_Booting& operator=(State_Booting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const State_Booting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State_Booting* internal_default_instance() {
    return reinterpret_cast<const State_Booting*>(
               &_State_Booting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(State_Booting* other);
  friend void swap(State_Booting& a, State_Booting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline State_Booting* New() const final {
    return CreateMaybeMessage<State_Booting>(nullptr);
  }

  State_Booting* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<State_Booting>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const State_Booting& from);
  void MergeFrom(const State_Booting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State_Booting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:arsdk.microhard.State.Booting)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class State_Idle :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.State.Idle) */ {
 public:
  State_Idle();
  virtual ~State_Idle();

  State_Idle(const State_Idle& from);

  inline State_Idle& operator=(const State_Idle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  State_Idle(State_Idle&& from) noexcept
    : State_Idle() {
    *this = ::std::move(from);
  }

  inline State_Idle& operator=(State_Idle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const State_Idle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State_Idle* internal_default_instance() {
    return reinterpret_cast<const State_Idle*>(
               &_State_Idle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(State_Idle* other);
  friend void swap(State_Idle& a, State_Idle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline State_Idle* New() const final {
    return CreateMaybeMessage<State_Idle>(nullptr);
  }

  State_Idle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<State_Idle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const State_Idle& from);
  void MergeFrom(const State_Idle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State_Idle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:arsdk.microhard.State.Idle)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class State_Pairing :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.State.Pairing) */ {
 public:
  State_Pairing();
  virtual ~State_Pairing();

  State_Pairing(const State_Pairing& from);

  inline State_Pairing& operator=(const State_Pairing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  State_Pairing(State_Pairing&& from) noexcept
    : State_Pairing() {
    *this = ::std::move(from);
  }

  inline State_Pairing& operator=(State_Pairing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const State_Pairing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State_Pairing* internal_default_instance() {
    return reinterpret_cast<const State_Pairing*>(
               &_State_Pairing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(State_Pairing* other);
  friend void swap(State_Pairing& a, State_Pairing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline State_Pairing* New() const final {
    return CreateMaybeMessage<State_Pairing>(nullptr);
  }

  State_Pairing* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<State_Pairing>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const State_Pairing& from);
  void MergeFrom(const State_Pairing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State_Pairing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string network_id = 1;
  void clear_network_id();
  static const int kNetworkIdFieldNumber = 1;
  const ::std::string& network_id() const;
  void set_network_id(const ::std::string& value);
  #if LANG_CXX11
  void set_network_id(::std::string&& value);
  #endif
  void set_network_id(const char* value);
  void set_network_id(const char* value, size_t size);
  ::std::string* mutable_network_id();
  ::std::string* release_network_id();
  void set_allocated_network_id(::std::string* network_id);

  // .arsdk.microhard.PairingParameters pairing_parameters = 2;
  bool has_pairing_parameters() const;
  void clear_pairing_parameters();
  static const int kPairingParametersFieldNumber = 2;
  const ::arsdk::microhard::PairingParameters& pairing_parameters() const;
  ::arsdk::microhard::PairingParameters* release_pairing_parameters();
  ::arsdk::microhard::PairingParameters* mutable_pairing_parameters();
  void set_allocated_pairing_parameters(::arsdk::microhard::PairingParameters* pairing_parameters);

  // .arsdk.microhard.ConnectionParameters connection_parameters = 3;
  bool has_connection_parameters() const;
  void clear_connection_parameters();
  static const int kConnectionParametersFieldNumber = 3;
  const ::arsdk::microhard::ConnectionParameters& connection_parameters() const;
  ::arsdk::microhard::ConnectionParameters* release_connection_parameters();
  ::arsdk::microhard::ConnectionParameters* mutable_connection_parameters();
  void set_allocated_connection_parameters(::arsdk::microhard::ConnectionParameters* connection_parameters);

  // @@protoc_insertion_point(class_scope:arsdk.microhard.State.Pairing)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr network_id_;
  ::arsdk::microhard::PairingParameters* pairing_parameters_;
  ::arsdk::microhard::ConnectionParameters* connection_parameters_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class State_Connecting :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.State.Connecting) */ {
 public:
  State_Connecting();
  virtual ~State_Connecting();

  State_Connecting(const State_Connecting& from);

  inline State_Connecting& operator=(const State_Connecting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  State_Connecting(State_Connecting&& from) noexcept
    : State_Connecting() {
    *this = ::std::move(from);
  }

  inline State_Connecting& operator=(State_Connecting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const State_Connecting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State_Connecting* internal_default_instance() {
    return reinterpret_cast<const State_Connecting*>(
               &_State_Connecting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(State_Connecting* other);
  friend void swap(State_Connecting& a, State_Connecting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline State_Connecting* New() const final {
    return CreateMaybeMessage<State_Connecting>(nullptr);
  }

  State_Connecting* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<State_Connecting>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const State_Connecting& from);
  void MergeFrom(const State_Connecting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State_Connecting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string device_uid = 1;
  void clear_device_uid();
  static const int kDeviceUidFieldNumber = 1;
  const ::std::string& device_uid() const;
  void set_device_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_device_uid(::std::string&& value);
  #endif
  void set_device_uid(const char* value);
  void set_device_uid(const char* value, size_t size);
  ::std::string* mutable_device_uid();
  ::std::string* release_device_uid();
  void set_allocated_device_uid(::std::string* device_uid);

  // @@protoc_insertion_point(class_scope:arsdk.microhard.State.Connecting)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr device_uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class State_Connected :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.State.Connected) */ {
 public:
  State_Connected();
  virtual ~State_Connected();

  State_Connected(const State_Connected& from);

  inline State_Connected& operator=(const State_Connected& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  State_Connected(State_Connected&& from) noexcept
    : State_Connected() {
    *this = ::std::move(from);
  }

  inline State_Connected& operator=(State_Connected&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const State_Connected& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State_Connected* internal_default_instance() {
    return reinterpret_cast<const State_Connected*>(
               &_State_Connected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(State_Connected* other);
  friend void swap(State_Connected& a, State_Connected& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline State_Connected* New() const final {
    return CreateMaybeMessage<State_Connected>(nullptr);
  }

  State_Connected* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<State_Connected>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const State_Connected& from);
  void MergeFrom(const State_Connected& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State_Connected* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string device_uid = 1;
  void clear_device_uid();
  static const int kDeviceUidFieldNumber = 1;
  const ::std::string& device_uid() const;
  void set_device_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_device_uid(::std::string&& value);
  #endif
  void set_device_uid(const char* value);
  void set_device_uid(const char* value, size_t size);
  ::std::string* mutable_device_uid();
  ::std::string* release_device_uid();
  void set_allocated_device_uid(::std::string* device_uid);

  // @@protoc_insertion_point(class_scope:arsdk.microhard.State.Connected)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr device_uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class State :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.State) */ {
 public:
  State();
  virtual ~State();

  State(const State& from);

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  State(State&& from) noexcept
    : State() {
    *this = ::std::move(from);
  }

  inline State& operator=(State&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const State& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(State* other);
  friend void swap(State& a, State& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline State* New() const final {
    return CreateMaybeMessage<State>(nullptr);
  }

  State* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<State>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef State_Offline Offline;
  typedef State_Booting Booting;
  typedef State_Idle Idle;
  typedef State_Pairing Pairing;
  typedef State_Connecting Connecting;
  typedef State_Connected Connected;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:arsdk.microhard.State)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class PairingParameters :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.PairingParameters) */ {
 public:
  PairingParameters();
  virtual ~PairingParameters();

  PairingParameters(const PairingParameters& from);

  inline PairingParameters& operator=(const PairingParameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PairingParameters(PairingParameters&& from) noexcept
    : PairingParameters() {
    *this = ::std::move(from);
  }

  inline PairingParameters& operator=(PairingParameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PairingParameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PairingParameters* internal_default_instance() {
    return reinterpret_cast<const PairingParameters*>(
               &_PairingParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(PairingParameters* other);
  friend void swap(PairingParameters& a, PairingParameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PairingParameters* New() const final {
    return CreateMaybeMessage<PairingParameters>(nullptr);
  }

  PairingParameters* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PairingParameters>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PairingParameters& from);
  void MergeFrom(const PairingParameters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PairingParameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 channel = 1;
  void clear_channel();
  static const int kChannelFieldNumber = 1;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // uint32 power = 2;
  void clear_power();
  static const int kPowerFieldNumber = 2;
  ::google::protobuf::uint32 power() const;
  void set_power(::google::protobuf::uint32 value);

  // .arsdk.microhard.Bandwidth bandwidth = 3;
  void clear_bandwidth();
  static const int kBandwidthFieldNumber = 3;
  ::arsdk::microhard::Bandwidth bandwidth() const;
  void set_bandwidth(::arsdk::microhard::Bandwidth value);

  // .arsdk.microhard.Encryption encryption_algorithm = 4;
  void clear_encryption_algorithm();
  static const int kEncryptionAlgorithmFieldNumber = 4;
  ::arsdk::microhard::Encryption encryption_algorithm() const;
  void set_encryption_algorithm(::arsdk::microhard::Encryption value);

  // @@protoc_insertion_point(class_scope:arsdk.microhard.PairingParameters)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint32 power_;
  int bandwidth_;
  int encryption_algorithm_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class PairingStatus_Failure :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.PairingStatus.Failure) */ {
 public:
  PairingStatus_Failure();
  virtual ~PairingStatus_Failure();

  PairingStatus_Failure(const PairingStatus_Failure& from);

  inline PairingStatus_Failure& operator=(const PairingStatus_Failure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PairingStatus_Failure(PairingStatus_Failure&& from) noexcept
    : PairingStatus_Failure() {
    *this = ::std::move(from);
  }

  inline PairingStatus_Failure& operator=(PairingStatus_Failure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PairingStatus_Failure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PairingStatus_Failure* internal_default_instance() {
    return reinterpret_cast<const PairingStatus_Failure*>(
               &_PairingStatus_Failure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(PairingStatus_Failure* other);
  friend void swap(PairingStatus_Failure& a, PairingStatus_Failure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PairingStatus_Failure* New() const final {
    return CreateMaybeMessage<PairingStatus_Failure>(nullptr);
  }

  PairingStatus_Failure* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PairingStatus_Failure>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PairingStatus_Failure& from);
  void MergeFrom(const PairingStatus_Failure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PairingStatus_Failure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .arsdk.microhard.PairingFailureReason reason = 1;
  void clear_reason();
  static const int kReasonFieldNumber = 1;
  ::arsdk::microhard::PairingFailureReason reason() const;
  void set_reason(::arsdk::microhard::PairingFailureReason value);

  // @@protoc_insertion_point(class_scope:arsdk.microhard.PairingStatus.Failure)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int reason_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class PairingStatus_Success :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.PairingStatus.Success) */ {
 public:
  PairingStatus_Success();
  virtual ~PairingStatus_Success();

  PairingStatus_Success(const PairingStatus_Success& from);

  inline PairingStatus_Success& operator=(const PairingStatus_Success& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PairingStatus_Success(PairingStatus_Success&& from) noexcept
    : PairingStatus_Success() {
    *this = ::std::move(from);
  }

  inline PairingStatus_Success& operator=(PairingStatus_Success&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PairingStatus_Success& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PairingStatus_Success* internal_default_instance() {
    return reinterpret_cast<const PairingStatus_Success*>(
               &_PairingStatus_Success_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(PairingStatus_Success* other);
  friend void swap(PairingStatus_Success& a, PairingStatus_Success& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PairingStatus_Success* New() const final {
    return CreateMaybeMessage<PairingStatus_Success>(nullptr);
  }

  PairingStatus_Success* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PairingStatus_Success>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PairingStatus_Success& from);
  void MergeFrom(const PairingStatus_Success& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PairingStatus_Success* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string device_uid = 1;
  void clear_device_uid();
  static const int kDeviceUidFieldNumber = 1;
  const ::std::string& device_uid() const;
  void set_device_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_device_uid(::std::string&& value);
  #endif
  void set_device_uid(const char* value);
  void set_device_uid(const char* value, size_t size);
  ::std::string* mutable_device_uid();
  ::std::string* release_device_uid();
  void set_allocated_device_uid(::std::string* device_uid);

  // @@protoc_insertion_point(class_scope:arsdk.microhard.PairingStatus.Success)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr device_uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// -------------------------------------------------------------------

class PairingStatus :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.microhard.PairingStatus) */ {
 public:
  PairingStatus();
  virtual ~PairingStatus();

  PairingStatus(const PairingStatus& from);

  inline PairingStatus& operator=(const PairingStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PairingStatus(PairingStatus&& from) noexcept
    : PairingStatus() {
    *this = ::std::move(from);
  }

  inline PairingStatus& operator=(PairingStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PairingStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PairingStatus* internal_default_instance() {
    return reinterpret_cast<const PairingStatus*>(
               &_PairingStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(PairingStatus* other);
  friend void swap(PairingStatus& a, PairingStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PairingStatus* New() const final {
    return CreateMaybeMessage<PairingStatus>(nullptr);
  }

  PairingStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PairingStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PairingStatus& from);
  void MergeFrom(const PairingStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PairingStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PairingStatus_Failure Failure;
  typedef PairingStatus_Success Success;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:arsdk.microhard.PairingStatus)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fmicrohard_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Command_GetState

// bool include_default_capabilities = 1;
inline void Command_GetState::clear_include_default_capabilities() {
  include_default_capabilities_ = false;
}
inline bool Command_GetState::include_default_capabilities() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Command.GetState.include_default_capabilities)
  return include_default_capabilities_;
}
inline void Command_GetState::set_include_default_capabilities(bool value) {
  
  include_default_capabilities_ = value;
  // @@protoc_insertion_point(field_set:arsdk.microhard.Command.GetState.include_default_capabilities)
}

// -------------------------------------------------------------------

// Command_PowerOn

// -------------------------------------------------------------------

// Command_ShutDown

// -------------------------------------------------------------------

// Command_PairDevice

// string network_id = 1;
inline void Command_PairDevice::clear_network_id() {
  network_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Command_PairDevice::network_id() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Command.PairDevice.network_id)
  return network_id_.GetNoArena();
}
inline void Command_PairDevice::set_network_id(const ::std::string& value) {
  
  network_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arsdk.microhard.Command.PairDevice.network_id)
}
#if LANG_CXX11
inline void Command_PairDevice::set_network_id(::std::string&& value) {
  
  network_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arsdk.microhard.Command.PairDevice.network_id)
}
#endif
inline void Command_PairDevice::set_network_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  network_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arsdk.microhard.Command.PairDevice.network_id)
}
inline void Command_PairDevice::set_network_id(const char* value, size_t size) {
  
  network_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arsdk.microhard.Command.PairDevice.network_id)
}
inline ::std::string* Command_PairDevice::mutable_network_id() {
  
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Command.PairDevice.network_id)
  return network_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command_PairDevice::release_network_id() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Command.PairDevice.network_id)
  
  return network_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Command_PairDevice::set_allocated_network_id(::std::string* network_id) {
  if (network_id != nullptr) {
    
  } else {
    
  }
  network_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), network_id);
  // @@protoc_insertion_point(field_set_allocated:arsdk.microhard.Command.PairDevice.network_id)
}

// string encryption_key = 2;
inline void Command_PairDevice::clear_encryption_key() {
  encryption_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Command_PairDevice::encryption_key() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Command.PairDevice.encryption_key)
  return encryption_key_.GetNoArena();
}
inline void Command_PairDevice::set_encryption_key(const ::std::string& value) {
  
  encryption_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arsdk.microhard.Command.PairDevice.encryption_key)
}
#if LANG_CXX11
inline void Command_PairDevice::set_encryption_key(::std::string&& value) {
  
  encryption_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arsdk.microhard.Command.PairDevice.encryption_key)
}
#endif
inline void Command_PairDevice::set_encryption_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  encryption_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arsdk.microhard.Command.PairDevice.encryption_key)
}
inline void Command_PairDevice::set_encryption_key(const char* value, size_t size) {
  
  encryption_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arsdk.microhard.Command.PairDevice.encryption_key)
}
inline ::std::string* Command_PairDevice::mutable_encryption_key() {
  
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Command.PairDevice.encryption_key)
  return encryption_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command_PairDevice::release_encryption_key() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Command.PairDevice.encryption_key)
  
  return encryption_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Command_PairDevice::set_allocated_encryption_key(::std::string* encryption_key) {
  if (encryption_key != nullptr) {
    
  } else {
    
  }
  encryption_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encryption_key);
  // @@protoc_insertion_point(field_set_allocated:arsdk.microhard.Command.PairDevice.encryption_key)
}

// .arsdk.microhard.PairingParameters pairing_parameters = 3;
inline bool Command_PairDevice::has_pairing_parameters() const {
  return this != internal_default_instance() && pairing_parameters_ != nullptr;
}
inline void Command_PairDevice::clear_pairing_parameters() {
  if (GetArenaNoVirtual() == nullptr && pairing_parameters_ != nullptr) {
    delete pairing_parameters_;
  }
  pairing_parameters_ = nullptr;
}
inline const ::arsdk::microhard::PairingParameters& Command_PairDevice::pairing_parameters() const {
  const ::arsdk::microhard::PairingParameters* p = pairing_parameters_;
  // @@protoc_insertion_point(field_get:arsdk.microhard.Command.PairDevice.pairing_parameters)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::microhard::PairingParameters*>(
      &::arsdk::microhard::_PairingParameters_default_instance_);
}
inline ::arsdk::microhard::PairingParameters* Command_PairDevice::release_pairing_parameters() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Command.PairDevice.pairing_parameters)
  
  ::arsdk::microhard::PairingParameters* temp = pairing_parameters_;
  pairing_parameters_ = nullptr;
  return temp;
}
inline ::arsdk::microhard::PairingParameters* Command_PairDevice::mutable_pairing_parameters() {
  
  if (pairing_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::microhard::PairingParameters>(GetArenaNoVirtual());
    pairing_parameters_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Command.PairDevice.pairing_parameters)
  return pairing_parameters_;
}
inline void Command_PairDevice::set_allocated_pairing_parameters(::arsdk::microhard::PairingParameters* pairing_parameters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pairing_parameters_;
  }
  if (pairing_parameters) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pairing_parameters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pairing_parameters, submessage_arena);
    }
    
  } else {
    
  }
  pairing_parameters_ = pairing_parameters;
  // @@protoc_insertion_point(field_set_allocated:arsdk.microhard.Command.PairDevice.pairing_parameters)
}

// .arsdk.microhard.ConnectionParameters connection_parameters = 4;
inline bool Command_PairDevice::has_connection_parameters() const {
  return this != internal_default_instance() && connection_parameters_ != nullptr;
}
inline void Command_PairDevice::clear_connection_parameters() {
  if (GetArenaNoVirtual() == nullptr && connection_parameters_ != nullptr) {
    delete connection_parameters_;
  }
  connection_parameters_ = nullptr;
}
inline const ::arsdk::microhard::ConnectionParameters& Command_PairDevice::connection_parameters() const {
  const ::arsdk::microhard::ConnectionParameters* p = connection_parameters_;
  // @@protoc_insertion_point(field_get:arsdk.microhard.Command.PairDevice.connection_parameters)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::microhard::ConnectionParameters*>(
      &::arsdk::microhard::_ConnectionParameters_default_instance_);
}
inline ::arsdk::microhard::ConnectionParameters* Command_PairDevice::release_connection_parameters() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Command.PairDevice.connection_parameters)
  
  ::arsdk::microhard::ConnectionParameters* temp = connection_parameters_;
  connection_parameters_ = nullptr;
  return temp;
}
inline ::arsdk::microhard::ConnectionParameters* Command_PairDevice::mutable_connection_parameters() {
  
  if (connection_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::microhard::ConnectionParameters>(GetArenaNoVirtual());
    connection_parameters_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Command.PairDevice.connection_parameters)
  return connection_parameters_;
}
inline void Command_PairDevice::set_allocated_connection_parameters(::arsdk::microhard::ConnectionParameters* connection_parameters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete connection_parameters_;
  }
  if (connection_parameters) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      connection_parameters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection_parameters, submessage_arena);
    }
    
  } else {
    
  }
  connection_parameters_ = connection_parameters;
  // @@protoc_insertion_point(field_set_allocated:arsdk.microhard.Command.PairDevice.connection_parameters)
}

// -------------------------------------------------------------------

// Command

// .arsdk.microhard.Command.GetState get_state = 16;
inline bool Command::has_get_state() const {
  return id_case() == kGetState;
}
inline void Command::set_has_get_state() {
  _oneof_case_[0] = kGetState;
}
inline void Command::clear_get_state() {
  if (has_get_state()) {
    delete id_.get_state_;
    clear_has_id();
  }
}
inline ::arsdk::microhard::Command_GetState* Command::release_get_state() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Command.get_state)
  if (has_get_state()) {
    clear_has_id();
      ::arsdk::microhard::Command_GetState* temp = id_.get_state_;
    id_.get_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::Command_GetState& Command::get_state() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Command.get_state)
  return has_get_state()
      ? *id_.get_state_
      : *reinterpret_cast< ::arsdk::microhard::Command_GetState*>(&::arsdk::microhard::_Command_GetState_default_instance_);
}
inline ::arsdk::microhard::Command_GetState* Command::mutable_get_state() {
  if (!has_get_state()) {
    clear_id();
    set_has_get_state();
    id_.get_state_ = CreateMaybeMessage< ::arsdk::microhard::Command_GetState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Command.get_state)
  return id_.get_state_;
}

// .arsdk.microhard.Command.PowerOn power_on = 17;
inline bool Command::has_power_on() const {
  return id_case() == kPowerOn;
}
inline void Command::set_has_power_on() {
  _oneof_case_[0] = kPowerOn;
}
inline void Command::clear_power_on() {
  if (has_power_on()) {
    delete id_.power_on_;
    clear_has_id();
  }
}
inline ::arsdk::microhard::Command_PowerOn* Command::release_power_on() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Command.power_on)
  if (has_power_on()) {
    clear_has_id();
      ::arsdk::microhard::Command_PowerOn* temp = id_.power_on_;
    id_.power_on_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::Command_PowerOn& Command::power_on() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Command.power_on)
  return has_power_on()
      ? *id_.power_on_
      : *reinterpret_cast< ::arsdk::microhard::Command_PowerOn*>(&::arsdk::microhard::_Command_PowerOn_default_instance_);
}
inline ::arsdk::microhard::Command_PowerOn* Command::mutable_power_on() {
  if (!has_power_on()) {
    clear_id();
    set_has_power_on();
    id_.power_on_ = CreateMaybeMessage< ::arsdk::microhard::Command_PowerOn >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Command.power_on)
  return id_.power_on_;
}

// .arsdk.microhard.Command.ShutDown shutdown = 18;
inline bool Command::has_shutdown() const {
  return id_case() == kShutdown;
}
inline void Command::set_has_shutdown() {
  _oneof_case_[0] = kShutdown;
}
inline void Command::clear_shutdown() {
  if (has_shutdown()) {
    delete id_.shutdown_;
    clear_has_id();
  }
}
inline ::arsdk::microhard::Command_ShutDown* Command::release_shutdown() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Command.shutdown)
  if (has_shutdown()) {
    clear_has_id();
      ::arsdk::microhard::Command_ShutDown* temp = id_.shutdown_;
    id_.shutdown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::Command_ShutDown& Command::shutdown() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Command.shutdown)
  return has_shutdown()
      ? *id_.shutdown_
      : *reinterpret_cast< ::arsdk::microhard::Command_ShutDown*>(&::arsdk::microhard::_Command_ShutDown_default_instance_);
}
inline ::arsdk::microhard::Command_ShutDown* Command::mutable_shutdown() {
  if (!has_shutdown()) {
    clear_id();
    set_has_shutdown();
    id_.shutdown_ = CreateMaybeMessage< ::arsdk::microhard::Command_ShutDown >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Command.shutdown)
  return id_.shutdown_;
}

// .arsdk.microhard.Command.PairDevice pair_device = 19;
inline bool Command::has_pair_device() const {
  return id_case() == kPairDevice;
}
inline void Command::set_has_pair_device() {
  _oneof_case_[0] = kPairDevice;
}
inline void Command::clear_pair_device() {
  if (has_pair_device()) {
    delete id_.pair_device_;
    clear_has_id();
  }
}
inline ::arsdk::microhard::Command_PairDevice* Command::release_pair_device() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Command.pair_device)
  if (has_pair_device()) {
    clear_has_id();
      ::arsdk::microhard::Command_PairDevice* temp = id_.pair_device_;
    id_.pair_device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::Command_PairDevice& Command::pair_device() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Command.pair_device)
  return has_pair_device()
      ? *id_.pair_device_
      : *reinterpret_cast< ::arsdk::microhard::Command_PairDevice*>(&::arsdk::microhard::_Command_PairDevice_default_instance_);
}
inline ::arsdk::microhard::Command_PairDevice* Command::mutable_pair_device() {
  if (!has_pair_device()) {
    clear_id();
    set_has_pair_device();
    id_.pair_device_ = CreateMaybeMessage< ::arsdk::microhard::Command_PairDevice >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Command.pair_device)
  return id_.pair_device_;
}

inline bool Command::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void Command::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline Command::IdCase Command::id_case() const {
  return Command::IdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event_State

// .arsdk.microhard.Capabilities default_capabilities = 1;
inline bool Event_State::has_default_capabilities() const {
  return this != internal_default_instance() && default_capabilities_ != nullptr;
}
inline void Event_State::clear_default_capabilities() {
  if (GetArenaNoVirtual() == nullptr && default_capabilities_ != nullptr) {
    delete default_capabilities_;
  }
  default_capabilities_ = nullptr;
}
inline const ::arsdk::microhard::Capabilities& Event_State::default_capabilities() const {
  const ::arsdk::microhard::Capabilities* p = default_capabilities_;
  // @@protoc_insertion_point(field_get:arsdk.microhard.Event.State.default_capabilities)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::microhard::Capabilities*>(
      &::arsdk::microhard::_Capabilities_default_instance_);
}
inline ::arsdk::microhard::Capabilities* Event_State::release_default_capabilities() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Event.State.default_capabilities)
  
  ::arsdk::microhard::Capabilities* temp = default_capabilities_;
  default_capabilities_ = nullptr;
  return temp;
}
inline ::arsdk::microhard::Capabilities* Event_State::mutable_default_capabilities() {
  
  if (default_capabilities_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::microhard::Capabilities>(GetArenaNoVirtual());
    default_capabilities_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Event.State.default_capabilities)
  return default_capabilities_;
}
inline void Event_State::set_allocated_default_capabilities(::arsdk::microhard::Capabilities* default_capabilities) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete default_capabilities_;
  }
  if (default_capabilities) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      default_capabilities = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, default_capabilities, submessage_arena);
    }
    
  } else {
    
  }
  default_capabilities_ = default_capabilities;
  // @@protoc_insertion_point(field_set_allocated:arsdk.microhard.Event.State.default_capabilities)
}

// .arsdk.microhard.State.Offline offline = 2;
inline bool Event_State::has_offline() const {
  return state_case() == kOffline;
}
inline void Event_State::set_has_offline() {
  _oneof_case_[0] = kOffline;
}
inline void Event_State::clear_offline() {
  if (has_offline()) {
    delete state_.offline_;
    clear_has_state();
  }
}
inline ::arsdk::microhard::State_Offline* Event_State::release_offline() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Event.State.offline)
  if (has_offline()) {
    clear_has_state();
      ::arsdk::microhard::State_Offline* temp = state_.offline_;
    state_.offline_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::State_Offline& Event_State::offline() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Event.State.offline)
  return has_offline()
      ? *state_.offline_
      : *reinterpret_cast< ::arsdk::microhard::State_Offline*>(&::arsdk::microhard::_State_Offline_default_instance_);
}
inline ::arsdk::microhard::State_Offline* Event_State::mutable_offline() {
  if (!has_offline()) {
    clear_state();
    set_has_offline();
    state_.offline_ = CreateMaybeMessage< ::arsdk::microhard::State_Offline >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Event.State.offline)
  return state_.offline_;
}

// .arsdk.microhard.State.Booting booting = 3;
inline bool Event_State::has_booting() const {
  return state_case() == kBooting;
}
inline void Event_State::set_has_booting() {
  _oneof_case_[0] = kBooting;
}
inline void Event_State::clear_booting() {
  if (has_booting()) {
    delete state_.booting_;
    clear_has_state();
  }
}
inline ::arsdk::microhard::State_Booting* Event_State::release_booting() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Event.State.booting)
  if (has_booting()) {
    clear_has_state();
      ::arsdk::microhard::State_Booting* temp = state_.booting_;
    state_.booting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::State_Booting& Event_State::booting() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Event.State.booting)
  return has_booting()
      ? *state_.booting_
      : *reinterpret_cast< ::arsdk::microhard::State_Booting*>(&::arsdk::microhard::_State_Booting_default_instance_);
}
inline ::arsdk::microhard::State_Booting* Event_State::mutable_booting() {
  if (!has_booting()) {
    clear_state();
    set_has_booting();
    state_.booting_ = CreateMaybeMessage< ::arsdk::microhard::State_Booting >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Event.State.booting)
  return state_.booting_;
}

// .arsdk.microhard.State.Idle idle = 4;
inline bool Event_State::has_idle() const {
  return state_case() == kIdle;
}
inline void Event_State::set_has_idle() {
  _oneof_case_[0] = kIdle;
}
inline void Event_State::clear_idle() {
  if (has_idle()) {
    delete state_.idle_;
    clear_has_state();
  }
}
inline ::arsdk::microhard::State_Idle* Event_State::release_idle() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Event.State.idle)
  if (has_idle()) {
    clear_has_state();
      ::arsdk::microhard::State_Idle* temp = state_.idle_;
    state_.idle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::State_Idle& Event_State::idle() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Event.State.idle)
  return has_idle()
      ? *state_.idle_
      : *reinterpret_cast< ::arsdk::microhard::State_Idle*>(&::arsdk::microhard::_State_Idle_default_instance_);
}
inline ::arsdk::microhard::State_Idle* Event_State::mutable_idle() {
  if (!has_idle()) {
    clear_state();
    set_has_idle();
    state_.idle_ = CreateMaybeMessage< ::arsdk::microhard::State_Idle >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Event.State.idle)
  return state_.idle_;
}

// .arsdk.microhard.State.Pairing pairing = 5;
inline bool Event_State::has_pairing() const {
  return state_case() == kPairing;
}
inline void Event_State::set_has_pairing() {
  _oneof_case_[0] = kPairing;
}
inline void Event_State::clear_pairing() {
  if (has_pairing()) {
    delete state_.pairing_;
    clear_has_state();
  }
}
inline ::arsdk::microhard::State_Pairing* Event_State::release_pairing() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Event.State.pairing)
  if (has_pairing()) {
    clear_has_state();
      ::arsdk::microhard::State_Pairing* temp = state_.pairing_;
    state_.pairing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::State_Pairing& Event_State::pairing() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Event.State.pairing)
  return has_pairing()
      ? *state_.pairing_
      : *reinterpret_cast< ::arsdk::microhard::State_Pairing*>(&::arsdk::microhard::_State_Pairing_default_instance_);
}
inline ::arsdk::microhard::State_Pairing* Event_State::mutable_pairing() {
  if (!has_pairing()) {
    clear_state();
    set_has_pairing();
    state_.pairing_ = CreateMaybeMessage< ::arsdk::microhard::State_Pairing >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Event.State.pairing)
  return state_.pairing_;
}

// .arsdk.microhard.State.Connecting connecting = 6;
inline bool Event_State::has_connecting() const {
  return state_case() == kConnecting;
}
inline void Event_State::set_has_connecting() {
  _oneof_case_[0] = kConnecting;
}
inline void Event_State::clear_connecting() {
  if (has_connecting()) {
    delete state_.connecting_;
    clear_has_state();
  }
}
inline ::arsdk::microhard::State_Connecting* Event_State::release_connecting() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Event.State.connecting)
  if (has_connecting()) {
    clear_has_state();
      ::arsdk::microhard::State_Connecting* temp = state_.connecting_;
    state_.connecting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::State_Connecting& Event_State::connecting() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Event.State.connecting)
  return has_connecting()
      ? *state_.connecting_
      : *reinterpret_cast< ::arsdk::microhard::State_Connecting*>(&::arsdk::microhard::_State_Connecting_default_instance_);
}
inline ::arsdk::microhard::State_Connecting* Event_State::mutable_connecting() {
  if (!has_connecting()) {
    clear_state();
    set_has_connecting();
    state_.connecting_ = CreateMaybeMessage< ::arsdk::microhard::State_Connecting >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Event.State.connecting)
  return state_.connecting_;
}

// .arsdk.microhard.State.Connected connected = 7;
inline bool Event_State::has_connected() const {
  return state_case() == kConnected;
}
inline void Event_State::set_has_connected() {
  _oneof_case_[0] = kConnected;
}
inline void Event_State::clear_connected() {
  if (has_connected()) {
    delete state_.connected_;
    clear_has_state();
  }
}
inline ::arsdk::microhard::State_Connected* Event_State::release_connected() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Event.State.connected)
  if (has_connected()) {
    clear_has_state();
      ::arsdk::microhard::State_Connected* temp = state_.connected_;
    state_.connected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::State_Connected& Event_State::connected() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Event.State.connected)
  return has_connected()
      ? *state_.connected_
      : *reinterpret_cast< ::arsdk::microhard::State_Connected*>(&::arsdk::microhard::_State_Connected_default_instance_);
}
inline ::arsdk::microhard::State_Connected* Event_State::mutable_connected() {
  if (!has_connected()) {
    clear_state();
    set_has_connected();
    state_.connected_ = CreateMaybeMessage< ::arsdk::microhard::State_Connected >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Event.State.connected)
  return state_.connected_;
}

inline bool Event_State::has_state() const {
  return state_case() != STATE_NOT_SET;
}
inline void Event_State::clear_has_state() {
  _oneof_case_[0] = STATE_NOT_SET;
}
inline Event_State::StateCase Event_State::state_case() const {
  return Event_State::StateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event_HardwareError

// .arsdk.microhard.HardwareErrorCause cause = 1;
inline void Event_HardwareError::clear_cause() {
  cause_ = 0;
}
inline ::arsdk::microhard::HardwareErrorCause Event_HardwareError::cause() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Event.HardwareError.cause)
  return static_cast< ::arsdk::microhard::HardwareErrorCause >(cause_);
}
inline void Event_HardwareError::set_cause(::arsdk::microhard::HardwareErrorCause value) {
  
  cause_ = value;
  // @@protoc_insertion_point(field_set:arsdk.microhard.Event.HardwareError.cause)
}

// -------------------------------------------------------------------

// Event_Pairing

// .arsdk.microhard.PairingStatus.Failure failure = 1;
inline bool Event_Pairing::has_failure() const {
  return status_case() == kFailure;
}
inline void Event_Pairing::set_has_failure() {
  _oneof_case_[0] = kFailure;
}
inline void Event_Pairing::clear_failure() {
  if (has_failure()) {
    delete status_.failure_;
    clear_has_status();
  }
}
inline ::arsdk::microhard::PairingStatus_Failure* Event_Pairing::release_failure() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Event.Pairing.failure)
  if (has_failure()) {
    clear_has_status();
      ::arsdk::microhard::PairingStatus_Failure* temp = status_.failure_;
    status_.failure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::PairingStatus_Failure& Event_Pairing::failure() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Event.Pairing.failure)
  return has_failure()
      ? *status_.failure_
      : *reinterpret_cast< ::arsdk::microhard::PairingStatus_Failure*>(&::arsdk::microhard::_PairingStatus_Failure_default_instance_);
}
inline ::arsdk::microhard::PairingStatus_Failure* Event_Pairing::mutable_failure() {
  if (!has_failure()) {
    clear_status();
    set_has_failure();
    status_.failure_ = CreateMaybeMessage< ::arsdk::microhard::PairingStatus_Failure >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Event.Pairing.failure)
  return status_.failure_;
}

// .arsdk.microhard.PairingStatus.Success success = 2;
inline bool Event_Pairing::has_success() const {
  return status_case() == kSuccess;
}
inline void Event_Pairing::set_has_success() {
  _oneof_case_[0] = kSuccess;
}
inline void Event_Pairing::clear_success() {
  if (has_success()) {
    delete status_.success_;
    clear_has_status();
  }
}
inline ::arsdk::microhard::PairingStatus_Success* Event_Pairing::release_success() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Event.Pairing.success)
  if (has_success()) {
    clear_has_status();
      ::arsdk::microhard::PairingStatus_Success* temp = status_.success_;
    status_.success_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::PairingStatus_Success& Event_Pairing::success() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Event.Pairing.success)
  return has_success()
      ? *status_.success_
      : *reinterpret_cast< ::arsdk::microhard::PairingStatus_Success*>(&::arsdk::microhard::_PairingStatus_Success_default_instance_);
}
inline ::arsdk::microhard::PairingStatus_Success* Event_Pairing::mutable_success() {
  if (!has_success()) {
    clear_status();
    set_has_success();
    status_.success_ = CreateMaybeMessage< ::arsdk::microhard::PairingStatus_Success >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Event.Pairing.success)
  return status_.success_;
}

// string network_id = 3;
inline void Event_Pairing::clear_network_id() {
  network_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event_Pairing::network_id() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Event.Pairing.network_id)
  return network_id_.GetNoArena();
}
inline void Event_Pairing::set_network_id(const ::std::string& value) {
  
  network_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arsdk.microhard.Event.Pairing.network_id)
}
#if LANG_CXX11
inline void Event_Pairing::set_network_id(::std::string&& value) {
  
  network_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arsdk.microhard.Event.Pairing.network_id)
}
#endif
inline void Event_Pairing::set_network_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  network_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arsdk.microhard.Event.Pairing.network_id)
}
inline void Event_Pairing::set_network_id(const char* value, size_t size) {
  
  network_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arsdk.microhard.Event.Pairing.network_id)
}
inline ::std::string* Event_Pairing::mutable_network_id() {
  
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Event.Pairing.network_id)
  return network_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event_Pairing::release_network_id() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Event.Pairing.network_id)
  
  return network_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event_Pairing::set_allocated_network_id(::std::string* network_id) {
  if (network_id != nullptr) {
    
  } else {
    
  }
  network_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), network_id);
  // @@protoc_insertion_point(field_set_allocated:arsdk.microhard.Event.Pairing.network_id)
}

inline bool Event_Pairing::has_status() const {
  return status_case() != STATUS_NOT_SET;
}
inline void Event_Pairing::clear_has_status() {
  _oneof_case_[0] = STATUS_NOT_SET;
}
inline Event_Pairing::StatusCase Event_Pairing::status_case() const {
  return Event_Pairing::StatusCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event

// .arsdk.microhard.Event.State state = 16;
inline bool Event::has_state() const {
  return id_case() == kState;
}
inline void Event::set_has_state() {
  _oneof_case_[0] = kState;
}
inline void Event::clear_state() {
  if (has_state()) {
    delete id_.state_;
    clear_has_id();
  }
}
inline ::arsdk::microhard::Event_State* Event::release_state() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Event.state)
  if (has_state()) {
    clear_has_id();
      ::arsdk::microhard::Event_State* temp = id_.state_;
    id_.state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::Event_State& Event::state() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Event.state)
  return has_state()
      ? *id_.state_
      : *reinterpret_cast< ::arsdk::microhard::Event_State*>(&::arsdk::microhard::_Event_State_default_instance_);
}
inline ::arsdk::microhard::Event_State* Event::mutable_state() {
  if (!has_state()) {
    clear_id();
    set_has_state();
    id_.state_ = CreateMaybeMessage< ::arsdk::microhard::Event_State >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Event.state)
  return id_.state_;
}

// .arsdk.microhard.Event.HardwareError hardware_error = 18;
inline bool Event::has_hardware_error() const {
  return id_case() == kHardwareError;
}
inline void Event::set_has_hardware_error() {
  _oneof_case_[0] = kHardwareError;
}
inline void Event::clear_hardware_error() {
  if (has_hardware_error()) {
    delete id_.hardware_error_;
    clear_has_id();
  }
}
inline ::arsdk::microhard::Event_HardwareError* Event::release_hardware_error() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Event.hardware_error)
  if (has_hardware_error()) {
    clear_has_id();
      ::arsdk::microhard::Event_HardwareError* temp = id_.hardware_error_;
    id_.hardware_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::Event_HardwareError& Event::hardware_error() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Event.hardware_error)
  return has_hardware_error()
      ? *id_.hardware_error_
      : *reinterpret_cast< ::arsdk::microhard::Event_HardwareError*>(&::arsdk::microhard::_Event_HardwareError_default_instance_);
}
inline ::arsdk::microhard::Event_HardwareError* Event::mutable_hardware_error() {
  if (!has_hardware_error()) {
    clear_id();
    set_has_hardware_error();
    id_.hardware_error_ = CreateMaybeMessage< ::arsdk::microhard::Event_HardwareError >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Event.hardware_error)
  return id_.hardware_error_;
}

// .arsdk.microhard.Event.Pairing pairing = 19;
inline bool Event::has_pairing() const {
  return id_case() == kPairing;
}
inline void Event::set_has_pairing() {
  _oneof_case_[0] = kPairing;
}
inline void Event::clear_pairing() {
  if (has_pairing()) {
    delete id_.pairing_;
    clear_has_id();
  }
}
inline ::arsdk::microhard::Event_Pairing* Event::release_pairing() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.Event.pairing)
  if (has_pairing()) {
    clear_has_id();
      ::arsdk::microhard::Event_Pairing* temp = id_.pairing_;
    id_.pairing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::microhard::Event_Pairing& Event::pairing() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Event.pairing)
  return has_pairing()
      ? *id_.pairing_
      : *reinterpret_cast< ::arsdk::microhard::Event_Pairing*>(&::arsdk::microhard::_Event_Pairing_default_instance_);
}
inline ::arsdk::microhard::Event_Pairing* Event::mutable_pairing() {
  if (!has_pairing()) {
    clear_id();
    set_has_pairing();
    id_.pairing_ = CreateMaybeMessage< ::arsdk::microhard::Event_Pairing >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.Event.pairing)
  return id_.pairing_;
}

inline bool Event::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void Event::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline Event::IdCase Event::id_case() const {
  return Event::IdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Capabilities

// uint32 channel_min = 1;
inline void Capabilities::clear_channel_min() {
  channel_min_ = 0u;
}
inline ::google::protobuf::uint32 Capabilities::channel_min() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Capabilities.channel_min)
  return channel_min_;
}
inline void Capabilities::set_channel_min(::google::protobuf::uint32 value) {
  
  channel_min_ = value;
  // @@protoc_insertion_point(field_set:arsdk.microhard.Capabilities.channel_min)
}

// uint32 channel_max = 2;
inline void Capabilities::clear_channel_max() {
  channel_max_ = 0u;
}
inline ::google::protobuf::uint32 Capabilities::channel_max() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Capabilities.channel_max)
  return channel_max_;
}
inline void Capabilities::set_channel_max(::google::protobuf::uint32 value) {
  
  channel_max_ = value;
  // @@protoc_insertion_point(field_set:arsdk.microhard.Capabilities.channel_max)
}

// uint32 power_min = 3;
inline void Capabilities::clear_power_min() {
  power_min_ = 0u;
}
inline ::google::protobuf::uint32 Capabilities::power_min() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Capabilities.power_min)
  return power_min_;
}
inline void Capabilities::set_power_min(::google::protobuf::uint32 value) {
  
  power_min_ = value;
  // @@protoc_insertion_point(field_set:arsdk.microhard.Capabilities.power_min)
}

// uint32 power_max = 4;
inline void Capabilities::clear_power_max() {
  power_max_ = 0u;
}
inline ::google::protobuf::uint32 Capabilities::power_max() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Capabilities.power_max)
  return power_max_;
}
inline void Capabilities::set_power_max(::google::protobuf::uint32 value) {
  
  power_max_ = value;
  // @@protoc_insertion_point(field_set:arsdk.microhard.Capabilities.power_max)
}

// repeated .arsdk.microhard.Bandwidth bandwidths = 5;
inline int Capabilities::bandwidths_size() const {
  return bandwidths_.size();
}
inline void Capabilities::clear_bandwidths() {
  bandwidths_.Clear();
}
inline ::arsdk::microhard::Bandwidth Capabilities::bandwidths(int index) const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Capabilities.bandwidths)
  return static_cast< ::arsdk::microhard::Bandwidth >(bandwidths_.Get(index));
}
inline void Capabilities::set_bandwidths(int index, ::arsdk::microhard::Bandwidth value) {
  bandwidths_.Set(index, value);
  // @@protoc_insertion_point(field_set:arsdk.microhard.Capabilities.bandwidths)
}
inline void Capabilities::add_bandwidths(::arsdk::microhard::Bandwidth value) {
  bandwidths_.Add(value);
  // @@protoc_insertion_point(field_add:arsdk.microhard.Capabilities.bandwidths)
}
inline const ::google::protobuf::RepeatedField<int>&
Capabilities::bandwidths() const {
  // @@protoc_insertion_point(field_list:arsdk.microhard.Capabilities.bandwidths)
  return bandwidths_;
}
inline ::google::protobuf::RepeatedField<int>*
Capabilities::mutable_bandwidths() {
  // @@protoc_insertion_point(field_mutable_list:arsdk.microhard.Capabilities.bandwidths)
  return &bandwidths_;
}

// repeated .arsdk.microhard.Encryption encryption_algorithms = 6;
inline int Capabilities::encryption_algorithms_size() const {
  return encryption_algorithms_.size();
}
inline void Capabilities::clear_encryption_algorithms() {
  encryption_algorithms_.Clear();
}
inline ::arsdk::microhard::Encryption Capabilities::encryption_algorithms(int index) const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.Capabilities.encryption_algorithms)
  return static_cast< ::arsdk::microhard::Encryption >(encryption_algorithms_.Get(index));
}
inline void Capabilities::set_encryption_algorithms(int index, ::arsdk::microhard::Encryption value) {
  encryption_algorithms_.Set(index, value);
  // @@protoc_insertion_point(field_set:arsdk.microhard.Capabilities.encryption_algorithms)
}
inline void Capabilities::add_encryption_algorithms(::arsdk::microhard::Encryption value) {
  encryption_algorithms_.Add(value);
  // @@protoc_insertion_point(field_add:arsdk.microhard.Capabilities.encryption_algorithms)
}
inline const ::google::protobuf::RepeatedField<int>&
Capabilities::encryption_algorithms() const {
  // @@protoc_insertion_point(field_list:arsdk.microhard.Capabilities.encryption_algorithms)
  return encryption_algorithms_;
}
inline ::google::protobuf::RepeatedField<int>*
Capabilities::mutable_encryption_algorithms() {
  // @@protoc_insertion_point(field_mutable_list:arsdk.microhard.Capabilities.encryption_algorithms)
  return &encryption_algorithms_;
}

// -------------------------------------------------------------------

// ConnectionParameters

// uint32 channel = 1;
inline void ConnectionParameters::clear_channel() {
  channel_ = 0u;
}
inline ::google::protobuf::uint32 ConnectionParameters::channel() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.ConnectionParameters.channel)
  return channel_;
}
inline void ConnectionParameters::set_channel(::google::protobuf::uint32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:arsdk.microhard.ConnectionParameters.channel)
}

// uint32 power = 2;
inline void ConnectionParameters::clear_power() {
  power_ = 0u;
}
inline ::google::protobuf::uint32 ConnectionParameters::power() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.ConnectionParameters.power)
  return power_;
}
inline void ConnectionParameters::set_power(::google::protobuf::uint32 value) {
  
  power_ = value;
  // @@protoc_insertion_point(field_set:arsdk.microhard.ConnectionParameters.power)
}

// .arsdk.microhard.Bandwidth bandwidth = 3;
inline void ConnectionParameters::clear_bandwidth() {
  bandwidth_ = 0;
}
inline ::arsdk::microhard::Bandwidth ConnectionParameters::bandwidth() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.ConnectionParameters.bandwidth)
  return static_cast< ::arsdk::microhard::Bandwidth >(bandwidth_);
}
inline void ConnectionParameters::set_bandwidth(::arsdk::microhard::Bandwidth value) {
  
  bandwidth_ = value;
  // @@protoc_insertion_point(field_set:arsdk.microhard.ConnectionParameters.bandwidth)
}

// -------------------------------------------------------------------

// State_Offline

// -------------------------------------------------------------------

// State_Booting

// -------------------------------------------------------------------

// State_Idle

// -------------------------------------------------------------------

// State_Pairing

// string network_id = 1;
inline void State_Pairing::clear_network_id() {
  network_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& State_Pairing::network_id() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.State.Pairing.network_id)
  return network_id_.GetNoArena();
}
inline void State_Pairing::set_network_id(const ::std::string& value) {
  
  network_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arsdk.microhard.State.Pairing.network_id)
}
#if LANG_CXX11
inline void State_Pairing::set_network_id(::std::string&& value) {
  
  network_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arsdk.microhard.State.Pairing.network_id)
}
#endif
inline void State_Pairing::set_network_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  network_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arsdk.microhard.State.Pairing.network_id)
}
inline void State_Pairing::set_network_id(const char* value, size_t size) {
  
  network_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arsdk.microhard.State.Pairing.network_id)
}
inline ::std::string* State_Pairing::mutable_network_id() {
  
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.State.Pairing.network_id)
  return network_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* State_Pairing::release_network_id() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.State.Pairing.network_id)
  
  return network_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void State_Pairing::set_allocated_network_id(::std::string* network_id) {
  if (network_id != nullptr) {
    
  } else {
    
  }
  network_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), network_id);
  // @@protoc_insertion_point(field_set_allocated:arsdk.microhard.State.Pairing.network_id)
}

// .arsdk.microhard.PairingParameters pairing_parameters = 2;
inline bool State_Pairing::has_pairing_parameters() const {
  return this != internal_default_instance() && pairing_parameters_ != nullptr;
}
inline void State_Pairing::clear_pairing_parameters() {
  if (GetArenaNoVirtual() == nullptr && pairing_parameters_ != nullptr) {
    delete pairing_parameters_;
  }
  pairing_parameters_ = nullptr;
}
inline const ::arsdk::microhard::PairingParameters& State_Pairing::pairing_parameters() const {
  const ::arsdk::microhard::PairingParameters* p = pairing_parameters_;
  // @@protoc_insertion_point(field_get:arsdk.microhard.State.Pairing.pairing_parameters)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::microhard::PairingParameters*>(
      &::arsdk::microhard::_PairingParameters_default_instance_);
}
inline ::arsdk::microhard::PairingParameters* State_Pairing::release_pairing_parameters() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.State.Pairing.pairing_parameters)
  
  ::arsdk::microhard::PairingParameters* temp = pairing_parameters_;
  pairing_parameters_ = nullptr;
  return temp;
}
inline ::arsdk::microhard::PairingParameters* State_Pairing::mutable_pairing_parameters() {
  
  if (pairing_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::microhard::PairingParameters>(GetArenaNoVirtual());
    pairing_parameters_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.State.Pairing.pairing_parameters)
  return pairing_parameters_;
}
inline void State_Pairing::set_allocated_pairing_parameters(::arsdk::microhard::PairingParameters* pairing_parameters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pairing_parameters_;
  }
  if (pairing_parameters) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pairing_parameters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pairing_parameters, submessage_arena);
    }
    
  } else {
    
  }
  pairing_parameters_ = pairing_parameters;
  // @@protoc_insertion_point(field_set_allocated:arsdk.microhard.State.Pairing.pairing_parameters)
}

// .arsdk.microhard.ConnectionParameters connection_parameters = 3;
inline bool State_Pairing::has_connection_parameters() const {
  return this != internal_default_instance() && connection_parameters_ != nullptr;
}
inline void State_Pairing::clear_connection_parameters() {
  if (GetArenaNoVirtual() == nullptr && connection_parameters_ != nullptr) {
    delete connection_parameters_;
  }
  connection_parameters_ = nullptr;
}
inline const ::arsdk::microhard::ConnectionParameters& State_Pairing::connection_parameters() const {
  const ::arsdk::microhard::ConnectionParameters* p = connection_parameters_;
  // @@protoc_insertion_point(field_get:arsdk.microhard.State.Pairing.connection_parameters)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::microhard::ConnectionParameters*>(
      &::arsdk::microhard::_ConnectionParameters_default_instance_);
}
inline ::arsdk::microhard::ConnectionParameters* State_Pairing::release_connection_parameters() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.State.Pairing.connection_parameters)
  
  ::arsdk::microhard::ConnectionParameters* temp = connection_parameters_;
  connection_parameters_ = nullptr;
  return temp;
}
inline ::arsdk::microhard::ConnectionParameters* State_Pairing::mutable_connection_parameters() {
  
  if (connection_parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::microhard::ConnectionParameters>(GetArenaNoVirtual());
    connection_parameters_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.State.Pairing.connection_parameters)
  return connection_parameters_;
}
inline void State_Pairing::set_allocated_connection_parameters(::arsdk::microhard::ConnectionParameters* connection_parameters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete connection_parameters_;
  }
  if (connection_parameters) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      connection_parameters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connection_parameters, submessage_arena);
    }
    
  } else {
    
  }
  connection_parameters_ = connection_parameters;
  // @@protoc_insertion_point(field_set_allocated:arsdk.microhard.State.Pairing.connection_parameters)
}

// -------------------------------------------------------------------

// State_Connecting

// string device_uid = 1;
inline void State_Connecting::clear_device_uid() {
  device_uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& State_Connecting::device_uid() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.State.Connecting.device_uid)
  return device_uid_.GetNoArena();
}
inline void State_Connecting::set_device_uid(const ::std::string& value) {
  
  device_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arsdk.microhard.State.Connecting.device_uid)
}
#if LANG_CXX11
inline void State_Connecting::set_device_uid(::std::string&& value) {
  
  device_uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arsdk.microhard.State.Connecting.device_uid)
}
#endif
inline void State_Connecting::set_device_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  device_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arsdk.microhard.State.Connecting.device_uid)
}
inline void State_Connecting::set_device_uid(const char* value, size_t size) {
  
  device_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arsdk.microhard.State.Connecting.device_uid)
}
inline ::std::string* State_Connecting::mutable_device_uid() {
  
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.State.Connecting.device_uid)
  return device_uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* State_Connecting::release_device_uid() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.State.Connecting.device_uid)
  
  return device_uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void State_Connecting::set_allocated_device_uid(::std::string* device_uid) {
  if (device_uid != nullptr) {
    
  } else {
    
  }
  device_uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_uid);
  // @@protoc_insertion_point(field_set_allocated:arsdk.microhard.State.Connecting.device_uid)
}

// -------------------------------------------------------------------

// State_Connected

// string device_uid = 1;
inline void State_Connected::clear_device_uid() {
  device_uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& State_Connected::device_uid() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.State.Connected.device_uid)
  return device_uid_.GetNoArena();
}
inline void State_Connected::set_device_uid(const ::std::string& value) {
  
  device_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arsdk.microhard.State.Connected.device_uid)
}
#if LANG_CXX11
inline void State_Connected::set_device_uid(::std::string&& value) {
  
  device_uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arsdk.microhard.State.Connected.device_uid)
}
#endif
inline void State_Connected::set_device_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  device_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arsdk.microhard.State.Connected.device_uid)
}
inline void State_Connected::set_device_uid(const char* value, size_t size) {
  
  device_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arsdk.microhard.State.Connected.device_uid)
}
inline ::std::string* State_Connected::mutable_device_uid() {
  
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.State.Connected.device_uid)
  return device_uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* State_Connected::release_device_uid() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.State.Connected.device_uid)
  
  return device_uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void State_Connected::set_allocated_device_uid(::std::string* device_uid) {
  if (device_uid != nullptr) {
    
  } else {
    
  }
  device_uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_uid);
  // @@protoc_insertion_point(field_set_allocated:arsdk.microhard.State.Connected.device_uid)
}

// -------------------------------------------------------------------

// State

// -------------------------------------------------------------------

// PairingParameters

// uint32 channel = 1;
inline void PairingParameters::clear_channel() {
  channel_ = 0u;
}
inline ::google::protobuf::uint32 PairingParameters::channel() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.PairingParameters.channel)
  return channel_;
}
inline void PairingParameters::set_channel(::google::protobuf::uint32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:arsdk.microhard.PairingParameters.channel)
}

// uint32 power = 2;
inline void PairingParameters::clear_power() {
  power_ = 0u;
}
inline ::google::protobuf::uint32 PairingParameters::power() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.PairingParameters.power)
  return power_;
}
inline void PairingParameters::set_power(::google::protobuf::uint32 value) {
  
  power_ = value;
  // @@protoc_insertion_point(field_set:arsdk.microhard.PairingParameters.power)
}

// .arsdk.microhard.Bandwidth bandwidth = 3;
inline void PairingParameters::clear_bandwidth() {
  bandwidth_ = 0;
}
inline ::arsdk::microhard::Bandwidth PairingParameters::bandwidth() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.PairingParameters.bandwidth)
  return static_cast< ::arsdk::microhard::Bandwidth >(bandwidth_);
}
inline void PairingParameters::set_bandwidth(::arsdk::microhard::Bandwidth value) {
  
  bandwidth_ = value;
  // @@protoc_insertion_point(field_set:arsdk.microhard.PairingParameters.bandwidth)
}

// .arsdk.microhard.Encryption encryption_algorithm = 4;
inline void PairingParameters::clear_encryption_algorithm() {
  encryption_algorithm_ = 0;
}
inline ::arsdk::microhard::Encryption PairingParameters::encryption_algorithm() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.PairingParameters.encryption_algorithm)
  return static_cast< ::arsdk::microhard::Encryption >(encryption_algorithm_);
}
inline void PairingParameters::set_encryption_algorithm(::arsdk::microhard::Encryption value) {
  
  encryption_algorithm_ = value;
  // @@protoc_insertion_point(field_set:arsdk.microhard.PairingParameters.encryption_algorithm)
}

// -------------------------------------------------------------------

// PairingStatus_Failure

// .arsdk.microhard.PairingFailureReason reason = 1;
inline void PairingStatus_Failure::clear_reason() {
  reason_ = 0;
}
inline ::arsdk::microhard::PairingFailureReason PairingStatus_Failure::reason() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.PairingStatus.Failure.reason)
  return static_cast< ::arsdk::microhard::PairingFailureReason >(reason_);
}
inline void PairingStatus_Failure::set_reason(::arsdk::microhard::PairingFailureReason value) {
  
  reason_ = value;
  // @@protoc_insertion_point(field_set:arsdk.microhard.PairingStatus.Failure.reason)
}

// -------------------------------------------------------------------

// PairingStatus_Success

// string device_uid = 1;
inline void PairingStatus_Success::clear_device_uid() {
  device_uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PairingStatus_Success::device_uid() const {
  // @@protoc_insertion_point(field_get:arsdk.microhard.PairingStatus.Success.device_uid)
  return device_uid_.GetNoArena();
}
inline void PairingStatus_Success::set_device_uid(const ::std::string& value) {
  
  device_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arsdk.microhard.PairingStatus.Success.device_uid)
}
#if LANG_CXX11
inline void PairingStatus_Success::set_device_uid(::std::string&& value) {
  
  device_uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arsdk.microhard.PairingStatus.Success.device_uid)
}
#endif
inline void PairingStatus_Success::set_device_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  device_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arsdk.microhard.PairingStatus.Success.device_uid)
}
inline void PairingStatus_Success::set_device_uid(const char* value, size_t size) {
  
  device_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arsdk.microhard.PairingStatus.Success.device_uid)
}
inline ::std::string* PairingStatus_Success::mutable_device_uid() {
  
  // @@protoc_insertion_point(field_mutable:arsdk.microhard.PairingStatus.Success.device_uid)
  return device_uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PairingStatus_Success::release_device_uid() {
  // @@protoc_insertion_point(field_release:arsdk.microhard.PairingStatus.Success.device_uid)
  
  return device_uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PairingStatus_Success::set_allocated_device_uid(::std::string* device_uid) {
  if (device_uid != nullptr) {
    
  } else {
    
  }
  device_uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_uid);
  // @@protoc_insertion_point(field_set_allocated:arsdk.microhard.PairingStatus.Success.device_uid)
}

// -------------------------------------------------------------------

// PairingStatus

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace microhard
}  // namespace arsdk

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::arsdk::microhard::Bandwidth> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::arsdk::microhard::Bandwidth>() {
  return ::arsdk::microhard::Bandwidth_descriptor();
}
template <> struct is_proto_enum< ::arsdk::microhard::Encryption> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::arsdk::microhard::Encryption>() {
  return ::arsdk::microhard::Encryption_descriptor();
}
template <> struct is_proto_enum< ::arsdk::microhard::HardwareErrorCause> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::arsdk::microhard::HardwareErrorCause>() {
  return ::arsdk::microhard::HardwareErrorCause_descriptor();
}
template <> struct is_proto_enum< ::arsdk::microhard::PairingFailureReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::arsdk::microhard::PairingFailureReason>() {
  return ::arsdk::microhard::PairingFailureReason_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_arsdk_2fmicrohard_2eproto
