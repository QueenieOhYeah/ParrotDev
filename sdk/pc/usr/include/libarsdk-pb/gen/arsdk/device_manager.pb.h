// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: arsdk/device_manager.proto

#ifndef PROTOBUF_INCLUDED_arsdk_2fdevice_5fmanager_2eproto
#define PROTOBUF_INCLUDED_arsdk_2fdevice_5fmanager_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include "parrot/protobuf/extensions.pb.h"
#include "arsdk/microhard.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_arsdk_2fdevice_5fmanager_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_arsdk_2fdevice_5fmanager_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[29]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_arsdk_2fdevice_5fmanager_2eproto();
namespace arsdk {
namespace devicemanager {
class Capabilities;
class CapabilitiesDefaultTypeInternal;
extern CapabilitiesDefaultTypeInternal _Capabilities_default_instance_;
class Capabilities_Microhard;
class Capabilities_MicrohardDefaultTypeInternal;
extern Capabilities_MicrohardDefaultTypeInternal _Capabilities_Microhard_default_instance_;
class CellularInfo;
class CellularInfoDefaultTypeInternal;
extern CellularInfoDefaultTypeInternal _CellularInfo_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class Command_ConnectDevice;
class Command_ConnectDeviceDefaultTypeInternal;
extern Command_ConnectDeviceDefaultTypeInternal _Command_ConnectDevice_default_instance_;
class Command_ConnectDevice_Cellular;
class Command_ConnectDevice_CellularDefaultTypeInternal;
extern Command_ConnectDevice_CellularDefaultTypeInternal _Command_ConnectDevice_Cellular_default_instance_;
class Command_ConnectDevice_Microhard;
class Command_ConnectDevice_MicrohardDefaultTypeInternal;
extern Command_ConnectDevice_MicrohardDefaultTypeInternal _Command_ConnectDevice_Microhard_default_instance_;
class Command_ConnectDevice_Wifi;
class Command_ConnectDevice_WifiDefaultTypeInternal;
extern Command_ConnectDevice_WifiDefaultTypeInternal _Command_ConnectDevice_Wifi_default_instance_;
class Command_DiscoverDevices;
class Command_DiscoverDevicesDefaultTypeInternal;
extern Command_DiscoverDevicesDefaultTypeInternal _Command_DiscoverDevices_default_instance_;
class Command_ForgetDevice;
class Command_ForgetDeviceDefaultTypeInternal;
extern Command_ForgetDeviceDefaultTypeInternal _Command_ForgetDevice_default_instance_;
class Command_GetState;
class Command_GetStateDefaultTypeInternal;
extern Command_GetStateDefaultTypeInternal _Command_GetState_default_instance_;
class ConnectionState;
class ConnectionStateDefaultTypeInternal;
extern ConnectionStateDefaultTypeInternal _ConnectionState_default_instance_;
class ConnectionState_Connected;
class ConnectionState_ConnectedDefaultTypeInternal;
extern ConnectionState_ConnectedDefaultTypeInternal _ConnectionState_Connected_default_instance_;
class ConnectionState_Connecting;
class ConnectionState_ConnectingDefaultTypeInternal;
extern ConnectionState_ConnectingDefaultTypeInternal _ConnectionState_Connecting_default_instance_;
class ConnectionState_Disconnecting;
class ConnectionState_DisconnectingDefaultTypeInternal;
extern ConnectionState_DisconnectingDefaultTypeInternal _ConnectionState_Disconnecting_default_instance_;
class ConnectionState_Idle;
class ConnectionState_IdleDefaultTypeInternal;
extern ConnectionState_IdleDefaultTypeInternal _ConnectionState_Idle_default_instance_;
class ConnectionState_Searching;
class ConnectionState_SearchingDefaultTypeInternal;
extern ConnectionState_SearchingDefaultTypeInternal _ConnectionState_Searching_default_instance_;
class DeviceInfo;
class DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class DiscoveredDevice;
class DiscoveredDeviceDefaultTypeInternal;
extern DiscoveredDeviceDefaultTypeInternal _DiscoveredDevice_default_instance_;
class DiscoveredDevice_CellularVisibility;
class DiscoveredDevice_CellularVisibilityDefaultTypeInternal;
extern DiscoveredDevice_CellularVisibilityDefaultTypeInternal _DiscoveredDevice_CellularVisibility_default_instance_;
class DiscoveredDevice_WifiVisibility;
class DiscoveredDevice_WifiVisibilityDefaultTypeInternal;
extern DiscoveredDevice_WifiVisibilityDefaultTypeInternal _DiscoveredDevice_WifiVisibility_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Event_ConnectionFailure;
class Event_ConnectionFailureDefaultTypeInternal;
extern Event_ConnectionFailureDefaultTypeInternal _Event_ConnectionFailure_default_instance_;
class Event_DiscoveredDevices;
class Event_DiscoveredDevicesDefaultTypeInternal;
extern Event_DiscoveredDevicesDefaultTypeInternal _Event_DiscoveredDevices_default_instance_;
class Event_State;
class Event_StateDefaultTypeInternal;
extern Event_StateDefaultTypeInternal _Event_State_default_instance_;
class Event_State_KnownDevices;
class Event_State_KnownDevicesDefaultTypeInternal;
extern Event_State_KnownDevicesDefaultTypeInternal _Event_State_KnownDevices_default_instance_;
class KnownDevice;
class KnownDeviceDefaultTypeInternal;
extern KnownDeviceDefaultTypeInternal _KnownDevice_default_instance_;
class MicrohardInfo;
class MicrohardInfoDefaultTypeInternal;
extern MicrohardInfoDefaultTypeInternal _MicrohardInfo_default_instance_;
class WifiInfo;
class WifiInfoDefaultTypeInternal;
extern WifiInfoDefaultTypeInternal _WifiInfo_default_instance_;
}  // namespace devicemanager
}  // namespace arsdk
namespace google {
namespace protobuf {
template<> ::arsdk::devicemanager::Capabilities* Arena::CreateMaybeMessage<::arsdk::devicemanager::Capabilities>(Arena*);
template<> ::arsdk::devicemanager::Capabilities_Microhard* Arena::CreateMaybeMessage<::arsdk::devicemanager::Capabilities_Microhard>(Arena*);
template<> ::arsdk::devicemanager::CellularInfo* Arena::CreateMaybeMessage<::arsdk::devicemanager::CellularInfo>(Arena*);
template<> ::arsdk::devicemanager::Command* Arena::CreateMaybeMessage<::arsdk::devicemanager::Command>(Arena*);
template<> ::arsdk::devicemanager::Command_ConnectDevice* Arena::CreateMaybeMessage<::arsdk::devicemanager::Command_ConnectDevice>(Arena*);
template<> ::arsdk::devicemanager::Command_ConnectDevice_Cellular* Arena::CreateMaybeMessage<::arsdk::devicemanager::Command_ConnectDevice_Cellular>(Arena*);
template<> ::arsdk::devicemanager::Command_ConnectDevice_Microhard* Arena::CreateMaybeMessage<::arsdk::devicemanager::Command_ConnectDevice_Microhard>(Arena*);
template<> ::arsdk::devicemanager::Command_ConnectDevice_Wifi* Arena::CreateMaybeMessage<::arsdk::devicemanager::Command_ConnectDevice_Wifi>(Arena*);
template<> ::arsdk::devicemanager::Command_DiscoverDevices* Arena::CreateMaybeMessage<::arsdk::devicemanager::Command_DiscoverDevices>(Arena*);
template<> ::arsdk::devicemanager::Command_ForgetDevice* Arena::CreateMaybeMessage<::arsdk::devicemanager::Command_ForgetDevice>(Arena*);
template<> ::arsdk::devicemanager::Command_GetState* Arena::CreateMaybeMessage<::arsdk::devicemanager::Command_GetState>(Arena*);
template<> ::arsdk::devicemanager::ConnectionState* Arena::CreateMaybeMessage<::arsdk::devicemanager::ConnectionState>(Arena*);
template<> ::arsdk::devicemanager::ConnectionState_Connected* Arena::CreateMaybeMessage<::arsdk::devicemanager::ConnectionState_Connected>(Arena*);
template<> ::arsdk::devicemanager::ConnectionState_Connecting* Arena::CreateMaybeMessage<::arsdk::devicemanager::ConnectionState_Connecting>(Arena*);
template<> ::arsdk::devicemanager::ConnectionState_Disconnecting* Arena::CreateMaybeMessage<::arsdk::devicemanager::ConnectionState_Disconnecting>(Arena*);
template<> ::arsdk::devicemanager::ConnectionState_Idle* Arena::CreateMaybeMessage<::arsdk::devicemanager::ConnectionState_Idle>(Arena*);
template<> ::arsdk::devicemanager::ConnectionState_Searching* Arena::CreateMaybeMessage<::arsdk::devicemanager::ConnectionState_Searching>(Arena*);
template<> ::arsdk::devicemanager::DeviceInfo* Arena::CreateMaybeMessage<::arsdk::devicemanager::DeviceInfo>(Arena*);
template<> ::arsdk::devicemanager::DiscoveredDevice* Arena::CreateMaybeMessage<::arsdk::devicemanager::DiscoveredDevice>(Arena*);
template<> ::arsdk::devicemanager::DiscoveredDevice_CellularVisibility* Arena::CreateMaybeMessage<::arsdk::devicemanager::DiscoveredDevice_CellularVisibility>(Arena*);
template<> ::arsdk::devicemanager::DiscoveredDevice_WifiVisibility* Arena::CreateMaybeMessage<::arsdk::devicemanager::DiscoveredDevice_WifiVisibility>(Arena*);
template<> ::arsdk::devicemanager::Event* Arena::CreateMaybeMessage<::arsdk::devicemanager::Event>(Arena*);
template<> ::arsdk::devicemanager::Event_ConnectionFailure* Arena::CreateMaybeMessage<::arsdk::devicemanager::Event_ConnectionFailure>(Arena*);
template<> ::arsdk::devicemanager::Event_DiscoveredDevices* Arena::CreateMaybeMessage<::arsdk::devicemanager::Event_DiscoveredDevices>(Arena*);
template<> ::arsdk::devicemanager::Event_State* Arena::CreateMaybeMessage<::arsdk::devicemanager::Event_State>(Arena*);
template<> ::arsdk::devicemanager::Event_State_KnownDevices* Arena::CreateMaybeMessage<::arsdk::devicemanager::Event_State_KnownDevices>(Arena*);
template<> ::arsdk::devicemanager::KnownDevice* Arena::CreateMaybeMessage<::arsdk::devicemanager::KnownDevice>(Arena*);
template<> ::arsdk::devicemanager::MicrohardInfo* Arena::CreateMaybeMessage<::arsdk::devicemanager::MicrohardInfo>(Arena*);
template<> ::arsdk::devicemanager::WifiInfo* Arena::CreateMaybeMessage<::arsdk::devicemanager::WifiInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace arsdk {
namespace devicemanager {

enum ConnectionFailureReason {
  CONNECTION_FAILURE_REASON_PEER_LIMIT = 0,
  CONNECTION_FAILURE_REASON_AUTHENTICATION_FAILED = 1,
  ConnectionFailureReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ConnectionFailureReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ConnectionFailureReason_IsValid(int value);
const ConnectionFailureReason ConnectionFailureReason_MIN = CONNECTION_FAILURE_REASON_PEER_LIMIT;
const ConnectionFailureReason ConnectionFailureReason_MAX = CONNECTION_FAILURE_REASON_AUTHENTICATION_FAILED;
const int ConnectionFailureReason_ARRAYSIZE = ConnectionFailureReason_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectionFailureReason_descriptor();
inline const ::std::string& ConnectionFailureReason_Name(ConnectionFailureReason value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectionFailureReason_descriptor(), value);
}
inline bool ConnectionFailureReason_Parse(
    const ::std::string& name, ConnectionFailureReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectionFailureReason>(
    ConnectionFailureReason_descriptor(), name, value);
}
enum Transport {
  TRANSPORT_WIFI = 0,
  TRANSPORT_CELLULAR = 1,
  TRANSPORT_MICROHARD = 2,
  Transport_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Transport_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Transport_IsValid(int value);
const Transport Transport_MIN = TRANSPORT_WIFI;
const Transport Transport_MAX = TRANSPORT_MICROHARD;
const int Transport_ARRAYSIZE = Transport_MAX + 1;

const ::google::protobuf::EnumDescriptor* Transport_descriptor();
inline const ::std::string& Transport_Name(Transport value) {
  return ::google::protobuf::internal::NameOfEnum(
    Transport_descriptor(), value);
}
inline bool Transport_Parse(
    const ::std::string& name, Transport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Transport>(
    Transport_descriptor(), name, value);
}
enum WifiSecurity {
  WIFI_SECURITY_NONE = 0,
  WIFI_SECURITY_WPA2 = 1,
  WifiSecurity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  WifiSecurity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool WifiSecurity_IsValid(int value);
const WifiSecurity WifiSecurity_MIN = WIFI_SECURITY_NONE;
const WifiSecurity WifiSecurity_MAX = WIFI_SECURITY_WPA2;
const int WifiSecurity_ARRAYSIZE = WifiSecurity_MAX + 1;

const ::google::protobuf::EnumDescriptor* WifiSecurity_descriptor();
inline const ::std::string& WifiSecurity_Name(WifiSecurity value) {
  return ::google::protobuf::internal::NameOfEnum(
    WifiSecurity_descriptor(), value);
}
inline bool WifiSecurity_Parse(
    const ::std::string& name, WifiSecurity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WifiSecurity>(
    WifiSecurity_descriptor(), name, value);
}
// ===================================================================

class Command_GetState :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Command.GetState) */ {
 public:
  Command_GetState();
  virtual ~Command_GetState();

  Command_GetState(const Command_GetState& from);

  inline Command_GetState& operator=(const Command_GetState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command_GetState(Command_GetState&& from) noexcept
    : Command_GetState() {
    *this = ::std::move(from);
  }

  inline Command_GetState& operator=(Command_GetState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command_GetState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command_GetState* internal_default_instance() {
    return reinterpret_cast<const Command_GetState*>(
               &_Command_GetState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Command_GetState* other);
  friend void swap(Command_GetState& a, Command_GetState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command_GetState* New() const final {
    return CreateMaybeMessage<Command_GetState>(nullptr);
  }

  Command_GetState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command_GetState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command_GetState& from);
  void MergeFrom(const Command_GetState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command_GetState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool include_default_capabilities = 1;
  void clear_include_default_capabilities();
  static const int kIncludeDefaultCapabilitiesFieldNumber = 1;
  bool include_default_capabilities() const;
  void set_include_default_capabilities(bool value);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Command.GetState)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool include_default_capabilities_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Command_ConnectDevice_Wifi :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Command.ConnectDevice.Wifi) */ {
 public:
  Command_ConnectDevice_Wifi();
  virtual ~Command_ConnectDevice_Wifi();

  Command_ConnectDevice_Wifi(const Command_ConnectDevice_Wifi& from);

  inline Command_ConnectDevice_Wifi& operator=(const Command_ConnectDevice_Wifi& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command_ConnectDevice_Wifi(Command_ConnectDevice_Wifi&& from) noexcept
    : Command_ConnectDevice_Wifi() {
    *this = ::std::move(from);
  }

  inline Command_ConnectDevice_Wifi& operator=(Command_ConnectDevice_Wifi&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command_ConnectDevice_Wifi& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command_ConnectDevice_Wifi* internal_default_instance() {
    return reinterpret_cast<const Command_ConnectDevice_Wifi*>(
               &_Command_ConnectDevice_Wifi_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Command_ConnectDevice_Wifi* other);
  friend void swap(Command_ConnectDevice_Wifi& a, Command_ConnectDevice_Wifi& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command_ConnectDevice_Wifi* New() const final {
    return CreateMaybeMessage<Command_ConnectDevice_Wifi>(nullptr);
  }

  Command_ConnectDevice_Wifi* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command_ConnectDevice_Wifi>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command_ConnectDevice_Wifi& from);
  void MergeFrom(const Command_ConnectDevice_Wifi& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command_ConnectDevice_Wifi* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string security_key = 1;
  void clear_security_key();
  static const int kSecurityKeyFieldNumber = 1;
  const ::std::string& security_key() const;
  void set_security_key(const ::std::string& value);
  #if LANG_CXX11
  void set_security_key(::std::string&& value);
  #endif
  void set_security_key(const char* value);
  void set_security_key(const char* value, size_t size);
  ::std::string* mutable_security_key();
  ::std::string* release_security_key();
  void set_allocated_security_key(::std::string* security_key);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Command.ConnectDevice.Wifi)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr security_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Command_ConnectDevice_Cellular :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Command.ConnectDevice.Cellular) */ {
 public:
  Command_ConnectDevice_Cellular();
  virtual ~Command_ConnectDevice_Cellular();

  Command_ConnectDevice_Cellular(const Command_ConnectDevice_Cellular& from);

  inline Command_ConnectDevice_Cellular& operator=(const Command_ConnectDevice_Cellular& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command_ConnectDevice_Cellular(Command_ConnectDevice_Cellular&& from) noexcept
    : Command_ConnectDevice_Cellular() {
    *this = ::std::move(from);
  }

  inline Command_ConnectDevice_Cellular& operator=(Command_ConnectDevice_Cellular&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command_ConnectDevice_Cellular& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command_ConnectDevice_Cellular* internal_default_instance() {
    return reinterpret_cast<const Command_ConnectDevice_Cellular*>(
               &_Command_ConnectDevice_Cellular_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Command_ConnectDevice_Cellular* other);
  friend void swap(Command_ConnectDevice_Cellular& a, Command_ConnectDevice_Cellular& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command_ConnectDevice_Cellular* New() const final {
    return CreateMaybeMessage<Command_ConnectDevice_Cellular>(nullptr);
  }

  Command_ConnectDevice_Cellular* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command_ConnectDevice_Cellular>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command_ConnectDevice_Cellular& from);
  void MergeFrom(const Command_ConnectDevice_Cellular& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command_ConnectDevice_Cellular* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Command.ConnectDevice.Cellular)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Command_ConnectDevice_Microhard :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Command.ConnectDevice.Microhard) */ {
 public:
  Command_ConnectDevice_Microhard();
  virtual ~Command_ConnectDevice_Microhard();

  Command_ConnectDevice_Microhard(const Command_ConnectDevice_Microhard& from);

  inline Command_ConnectDevice_Microhard& operator=(const Command_ConnectDevice_Microhard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command_ConnectDevice_Microhard(Command_ConnectDevice_Microhard&& from) noexcept
    : Command_ConnectDevice_Microhard() {
    *this = ::std::move(from);
  }

  inline Command_ConnectDevice_Microhard& operator=(Command_ConnectDevice_Microhard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command_ConnectDevice_Microhard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command_ConnectDevice_Microhard* internal_default_instance() {
    return reinterpret_cast<const Command_ConnectDevice_Microhard*>(
               &_Command_ConnectDevice_Microhard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Command_ConnectDevice_Microhard* other);
  friend void swap(Command_ConnectDevice_Microhard& a, Command_ConnectDevice_Microhard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command_ConnectDevice_Microhard* New() const final {
    return CreateMaybeMessage<Command_ConnectDevice_Microhard>(nullptr);
  }

  Command_ConnectDevice_Microhard* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command_ConnectDevice_Microhard>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command_ConnectDevice_Microhard& from);
  void MergeFrom(const Command_ConnectDevice_Microhard& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command_ConnectDevice_Microhard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.UInt32Value power = 1;
  bool has_power() const;
  void clear_power();
  static const int kPowerFieldNumber = 1;
  const ::google::protobuf::UInt32Value& power() const;
  ::google::protobuf::UInt32Value* release_power();
  ::google::protobuf::UInt32Value* mutable_power();
  void set_allocated_power(::google::protobuf::UInt32Value* power);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Command.ConnectDevice.Microhard)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::UInt32Value* power_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Command_ConnectDevice :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Command.ConnectDevice) */ {
 public:
  Command_ConnectDevice();
  virtual ~Command_ConnectDevice();

  Command_ConnectDevice(const Command_ConnectDevice& from);

  inline Command_ConnectDevice& operator=(const Command_ConnectDevice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command_ConnectDevice(Command_ConnectDevice&& from) noexcept
    : Command_ConnectDevice() {
    *this = ::std::move(from);
  }

  inline Command_ConnectDevice& operator=(Command_ConnectDevice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command_ConnectDevice& default_instance();

  enum TransportCase {
    kWifi = 2,
    kCellular = 3,
    kMicrohard = 4,
    TRANSPORT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command_ConnectDevice* internal_default_instance() {
    return reinterpret_cast<const Command_ConnectDevice*>(
               &_Command_ConnectDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Command_ConnectDevice* other);
  friend void swap(Command_ConnectDevice& a, Command_ConnectDevice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command_ConnectDevice* New() const final {
    return CreateMaybeMessage<Command_ConnectDevice>(nullptr);
  }

  Command_ConnectDevice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command_ConnectDevice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command_ConnectDevice& from);
  void MergeFrom(const Command_ConnectDevice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command_ConnectDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Command_ConnectDevice_Wifi Wifi;
  typedef Command_ConnectDevice_Cellular Cellular;
  typedef Command_ConnectDevice_Microhard Microhard;

  // accessors -------------------------------------------------------

  // string uid = 1;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_uid(::std::string&& value);
  #endif
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);

  // .arsdk.devicemanager.Command.ConnectDevice.Wifi wifi = 2;
  bool has_wifi() const;
  void clear_wifi();
  static const int kWifiFieldNumber = 2;
  const ::arsdk::devicemanager::Command_ConnectDevice_Wifi& wifi() const;
  ::arsdk::devicemanager::Command_ConnectDevice_Wifi* release_wifi();
  ::arsdk::devicemanager::Command_ConnectDevice_Wifi* mutable_wifi();
  void set_allocated_wifi(::arsdk::devicemanager::Command_ConnectDevice_Wifi* wifi);

  // .arsdk.devicemanager.Command.ConnectDevice.Cellular cellular = 3;
  bool has_cellular() const;
  void clear_cellular();
  static const int kCellularFieldNumber = 3;
  const ::arsdk::devicemanager::Command_ConnectDevice_Cellular& cellular() const;
  ::arsdk::devicemanager::Command_ConnectDevice_Cellular* release_cellular();
  ::arsdk::devicemanager::Command_ConnectDevice_Cellular* mutable_cellular();
  void set_allocated_cellular(::arsdk::devicemanager::Command_ConnectDevice_Cellular* cellular);

  // .arsdk.devicemanager.Command.ConnectDevice.Microhard microhard = 4;
  bool has_microhard() const;
  void clear_microhard();
  static const int kMicrohardFieldNumber = 4;
  const ::arsdk::devicemanager::Command_ConnectDevice_Microhard& microhard() const;
  ::arsdk::devicemanager::Command_ConnectDevice_Microhard* release_microhard();
  ::arsdk::devicemanager::Command_ConnectDevice_Microhard* mutable_microhard();
  void set_allocated_microhard(::arsdk::devicemanager::Command_ConnectDevice_Microhard* microhard);

  void clear_transport();
  TransportCase transport_case() const;
  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Command.ConnectDevice)
 private:
  class HasBitSetters;
  void set_has_wifi();
  void set_has_cellular();
  void set_has_microhard();

  inline bool has_transport() const;
  inline void clear_has_transport();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  union TransportUnion {
    TransportUnion() {}
    ::arsdk::devicemanager::Command_ConnectDevice_Wifi* wifi_;
    ::arsdk::devicemanager::Command_ConnectDevice_Cellular* cellular_;
    ::arsdk::devicemanager::Command_ConnectDevice_Microhard* microhard_;
  } transport_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Command_ForgetDevice :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Command.ForgetDevice) */ {
 public:
  Command_ForgetDevice();
  virtual ~Command_ForgetDevice();

  Command_ForgetDevice(const Command_ForgetDevice& from);

  inline Command_ForgetDevice& operator=(const Command_ForgetDevice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command_ForgetDevice(Command_ForgetDevice&& from) noexcept
    : Command_ForgetDevice() {
    *this = ::std::move(from);
  }

  inline Command_ForgetDevice& operator=(Command_ForgetDevice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command_ForgetDevice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command_ForgetDevice* internal_default_instance() {
    return reinterpret_cast<const Command_ForgetDevice*>(
               &_Command_ForgetDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Command_ForgetDevice* other);
  friend void swap(Command_ForgetDevice& a, Command_ForgetDevice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command_ForgetDevice* New() const final {
    return CreateMaybeMessage<Command_ForgetDevice>(nullptr);
  }

  Command_ForgetDevice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command_ForgetDevice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command_ForgetDevice& from);
  void MergeFrom(const Command_ForgetDevice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command_ForgetDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uid = 1;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_uid(::std::string&& value);
  #endif
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Command.ForgetDevice)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Command_DiscoverDevices :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Command.DiscoverDevices) */ {
 public:
  Command_DiscoverDevices();
  virtual ~Command_DiscoverDevices();

  Command_DiscoverDevices(const Command_DiscoverDevices& from);

  inline Command_DiscoverDevices& operator=(const Command_DiscoverDevices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command_DiscoverDevices(Command_DiscoverDevices&& from) noexcept
    : Command_DiscoverDevices() {
    *this = ::std::move(from);
  }

  inline Command_DiscoverDevices& operator=(Command_DiscoverDevices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command_DiscoverDevices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command_DiscoverDevices* internal_default_instance() {
    return reinterpret_cast<const Command_DiscoverDevices*>(
               &_Command_DiscoverDevices_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Command_DiscoverDevices* other);
  friend void swap(Command_DiscoverDevices& a, Command_DiscoverDevices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command_DiscoverDevices* New() const final {
    return CreateMaybeMessage<Command_DiscoverDevices>(nullptr);
  }

  Command_DiscoverDevices* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command_DiscoverDevices>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command_DiscoverDevices& from);
  void MergeFrom(const Command_DiscoverDevices& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command_DiscoverDevices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Command.DiscoverDevices)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Command :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command& default_instance();

  enum IdCase {
    kGetState = 16,
    kConnectDevice = 17,
    kForgetDevice = 18,
    kDiscoverDevices = 19,
    ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Command_GetState GetState;
  typedef Command_ConnectDevice ConnectDevice;
  typedef Command_ForgetDevice ForgetDevice;
  typedef Command_DiscoverDevices DiscoverDevices;

  // accessors -------------------------------------------------------

  // .arsdk.devicemanager.Command.GetState get_state = 16;
  bool has_get_state() const;
  void clear_get_state();
  static const int kGetStateFieldNumber = 16;
  const ::arsdk::devicemanager::Command_GetState& get_state() const;
  ::arsdk::devicemanager::Command_GetState* release_get_state();
  ::arsdk::devicemanager::Command_GetState* mutable_get_state();
  void set_allocated_get_state(::arsdk::devicemanager::Command_GetState* get_state);

  // .arsdk.devicemanager.Command.ConnectDevice connect_device = 17;
  bool has_connect_device() const;
  void clear_connect_device();
  static const int kConnectDeviceFieldNumber = 17;
  const ::arsdk::devicemanager::Command_ConnectDevice& connect_device() const;
  ::arsdk::devicemanager::Command_ConnectDevice* release_connect_device();
  ::arsdk::devicemanager::Command_ConnectDevice* mutable_connect_device();
  void set_allocated_connect_device(::arsdk::devicemanager::Command_ConnectDevice* connect_device);

  // .arsdk.devicemanager.Command.ForgetDevice forget_device = 18;
  bool has_forget_device() const;
  void clear_forget_device();
  static const int kForgetDeviceFieldNumber = 18;
  const ::arsdk::devicemanager::Command_ForgetDevice& forget_device() const;
  ::arsdk::devicemanager::Command_ForgetDevice* release_forget_device();
  ::arsdk::devicemanager::Command_ForgetDevice* mutable_forget_device();
  void set_allocated_forget_device(::arsdk::devicemanager::Command_ForgetDevice* forget_device);

  // .arsdk.devicemanager.Command.DiscoverDevices discover_devices = 19;
  bool has_discover_devices() const;
  void clear_discover_devices();
  static const int kDiscoverDevicesFieldNumber = 19;
  const ::arsdk::devicemanager::Command_DiscoverDevices& discover_devices() const;
  ::arsdk::devicemanager::Command_DiscoverDevices* release_discover_devices();
  ::arsdk::devicemanager::Command_DiscoverDevices* mutable_discover_devices();
  void set_allocated_discover_devices(::arsdk::devicemanager::Command_DiscoverDevices* discover_devices);

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Command)
 private:
  class HasBitSetters;
  void set_has_get_state();
  void set_has_connect_device();
  void set_has_forget_device();
  void set_has_discover_devices();

  inline bool has_id() const;
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    ::arsdk::devicemanager::Command_GetState* get_state_;
    ::arsdk::devicemanager::Command_ConnectDevice* connect_device_;
    ::arsdk::devicemanager::Command_ForgetDevice* forget_device_;
    ::arsdk::devicemanager::Command_DiscoverDevices* discover_devices_;
  } id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Event_State_KnownDevices :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Event.State.KnownDevices) */ {
 public:
  Event_State_KnownDevices();
  virtual ~Event_State_KnownDevices();

  Event_State_KnownDevices(const Event_State_KnownDevices& from);

  inline Event_State_KnownDevices& operator=(const Event_State_KnownDevices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_State_KnownDevices(Event_State_KnownDevices&& from) noexcept
    : Event_State_KnownDevices() {
    *this = ::std::move(from);
  }

  inline Event_State_KnownDevices& operator=(Event_State_KnownDevices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Event_State_KnownDevices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_State_KnownDevices* internal_default_instance() {
    return reinterpret_cast<const Event_State_KnownDevices*>(
               &_Event_State_KnownDevices_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Event_State_KnownDevices* other);
  friend void swap(Event_State_KnownDevices& a, Event_State_KnownDevices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_State_KnownDevices* New() const final {
    return CreateMaybeMessage<Event_State_KnownDevices>(nullptr);
  }

  Event_State_KnownDevices* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event_State_KnownDevices>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event_State_KnownDevices& from);
  void MergeFrom(const Event_State_KnownDevices& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event_State_KnownDevices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arsdk.devicemanager.KnownDevice devices = 2;
  int devices_size() const;
  void clear_devices();
  static const int kDevicesFieldNumber = 2;
  ::arsdk::devicemanager::KnownDevice* mutable_devices(int index);
  ::google::protobuf::RepeatedPtrField< ::arsdk::devicemanager::KnownDevice >*
      mutable_devices();
  const ::arsdk::devicemanager::KnownDevice& devices(int index) const;
  ::arsdk::devicemanager::KnownDevice* add_devices();
  const ::google::protobuf::RepeatedPtrField< ::arsdk::devicemanager::KnownDevice >&
      devices() const;

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Event.State.KnownDevices)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::arsdk::devicemanager::KnownDevice > devices_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Event_State :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Event.State) */ {
 public:
  Event_State();
  virtual ~Event_State();

  Event_State(const Event_State& from);

  inline Event_State& operator=(const Event_State& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_State(Event_State&& from) noexcept
    : Event_State() {
    *this = ::std::move(from);
  }

  inline Event_State& operator=(Event_State&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Event_State& default_instance();

  enum ConnectionStateCase {
    kIdle = 4,
    kSearching = 5,
    kConnecting = 6,
    kConnected = 7,
    kDisconnecting = 8,
    CONNECTION_STATE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_State* internal_default_instance() {
    return reinterpret_cast<const Event_State*>(
               &_Event_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Event_State* other);
  friend void swap(Event_State& a, Event_State& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_State* New() const final {
    return CreateMaybeMessage<Event_State>(nullptr);
  }

  Event_State* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event_State>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event_State& from);
  void MergeFrom(const Event_State& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event_State* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Event_State_KnownDevices KnownDevices;

  // accessors -------------------------------------------------------

  // .arsdk.devicemanager.Capabilities default_capabilities = 1;
  bool has_default_capabilities() const;
  void clear_default_capabilities();
  static const int kDefaultCapabilitiesFieldNumber = 1;
  const ::arsdk::devicemanager::Capabilities& default_capabilities() const;
  ::arsdk::devicemanager::Capabilities* release_default_capabilities();
  ::arsdk::devicemanager::Capabilities* mutable_default_capabilities();
  void set_allocated_default_capabilities(::arsdk::devicemanager::Capabilities* default_capabilities);

  // .arsdk.devicemanager.Event.State.KnownDevices known_devices = 3;
  bool has_known_devices() const;
  void clear_known_devices();
  static const int kKnownDevicesFieldNumber = 3;
  const ::arsdk::devicemanager::Event_State_KnownDevices& known_devices() const;
  ::arsdk::devicemanager::Event_State_KnownDevices* release_known_devices();
  ::arsdk::devicemanager::Event_State_KnownDevices* mutable_known_devices();
  void set_allocated_known_devices(::arsdk::devicemanager::Event_State_KnownDevices* known_devices);

  // .arsdk.devicemanager.ConnectionState.Idle idle = 4;
  bool has_idle() const;
  void clear_idle();
  static const int kIdleFieldNumber = 4;
  const ::arsdk::devicemanager::ConnectionState_Idle& idle() const;
  ::arsdk::devicemanager::ConnectionState_Idle* release_idle();
  ::arsdk::devicemanager::ConnectionState_Idle* mutable_idle();
  void set_allocated_idle(::arsdk::devicemanager::ConnectionState_Idle* idle);

  // .arsdk.devicemanager.ConnectionState.Searching searching = 5;
  bool has_searching() const;
  void clear_searching();
  static const int kSearchingFieldNumber = 5;
  const ::arsdk::devicemanager::ConnectionState_Searching& searching() const;
  ::arsdk::devicemanager::ConnectionState_Searching* release_searching();
  ::arsdk::devicemanager::ConnectionState_Searching* mutable_searching();
  void set_allocated_searching(::arsdk::devicemanager::ConnectionState_Searching* searching);

  // .arsdk.devicemanager.ConnectionState.Connecting connecting = 6;
  bool has_connecting() const;
  void clear_connecting();
  static const int kConnectingFieldNumber = 6;
  const ::arsdk::devicemanager::ConnectionState_Connecting& connecting() const;
  ::arsdk::devicemanager::ConnectionState_Connecting* release_connecting();
  ::arsdk::devicemanager::ConnectionState_Connecting* mutable_connecting();
  void set_allocated_connecting(::arsdk::devicemanager::ConnectionState_Connecting* connecting);

  // .arsdk.devicemanager.ConnectionState.Connected connected = 7;
  bool has_connected() const;
  void clear_connected();
  static const int kConnectedFieldNumber = 7;
  const ::arsdk::devicemanager::ConnectionState_Connected& connected() const;
  ::arsdk::devicemanager::ConnectionState_Connected* release_connected();
  ::arsdk::devicemanager::ConnectionState_Connected* mutable_connected();
  void set_allocated_connected(::arsdk::devicemanager::ConnectionState_Connected* connected);

  // .arsdk.devicemanager.ConnectionState.Disconnecting disconnecting = 8;
  bool has_disconnecting() const;
  void clear_disconnecting();
  static const int kDisconnectingFieldNumber = 8;
  const ::arsdk::devicemanager::ConnectionState_Disconnecting& disconnecting() const;
  ::arsdk::devicemanager::ConnectionState_Disconnecting* release_disconnecting();
  ::arsdk::devicemanager::ConnectionState_Disconnecting* mutable_disconnecting();
  void set_allocated_disconnecting(::arsdk::devicemanager::ConnectionState_Disconnecting* disconnecting);

  void clear_connection_state();
  ConnectionStateCase connection_state_case() const;
  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Event.State)
 private:
  class HasBitSetters;
  void set_has_idle();
  void set_has_searching();
  void set_has_connecting();
  void set_has_connected();
  void set_has_disconnecting();

  inline bool has_connection_state() const;
  inline void clear_has_connection_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::arsdk::devicemanager::Capabilities* default_capabilities_;
  ::arsdk::devicemanager::Event_State_KnownDevices* known_devices_;
  union ConnectionStateUnion {
    ConnectionStateUnion() {}
    ::arsdk::devicemanager::ConnectionState_Idle* idle_;
    ::arsdk::devicemanager::ConnectionState_Searching* searching_;
    ::arsdk::devicemanager::ConnectionState_Connecting* connecting_;
    ::arsdk::devicemanager::ConnectionState_Connected* connected_;
    ::arsdk::devicemanager::ConnectionState_Disconnecting* disconnecting_;
  } connection_state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Event_ConnectionFailure :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Event.ConnectionFailure) */ {
 public:
  Event_ConnectionFailure();
  virtual ~Event_ConnectionFailure();

  Event_ConnectionFailure(const Event_ConnectionFailure& from);

  inline Event_ConnectionFailure& operator=(const Event_ConnectionFailure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_ConnectionFailure(Event_ConnectionFailure&& from) noexcept
    : Event_ConnectionFailure() {
    *this = ::std::move(from);
  }

  inline Event_ConnectionFailure& operator=(Event_ConnectionFailure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Event_ConnectionFailure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_ConnectionFailure* internal_default_instance() {
    return reinterpret_cast<const Event_ConnectionFailure*>(
               &_Event_ConnectionFailure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Event_ConnectionFailure* other);
  friend void swap(Event_ConnectionFailure& a, Event_ConnectionFailure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_ConnectionFailure* New() const final {
    return CreateMaybeMessage<Event_ConnectionFailure>(nullptr);
  }

  Event_ConnectionFailure* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event_ConnectionFailure>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event_ConnectionFailure& from);
  void MergeFrom(const Event_ConnectionFailure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event_ConnectionFailure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .arsdk.devicemanager.DeviceInfo device = 1;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  const ::arsdk::devicemanager::DeviceInfo& device() const;
  ::arsdk::devicemanager::DeviceInfo* release_device();
  ::arsdk::devicemanager::DeviceInfo* mutable_device();
  void set_allocated_device(::arsdk::devicemanager::DeviceInfo* device);

  // .arsdk.devicemanager.Transport transport = 2;
  void clear_transport();
  static const int kTransportFieldNumber = 2;
  ::arsdk::devicemanager::Transport transport() const;
  void set_transport(::arsdk::devicemanager::Transport value);

  // .arsdk.devicemanager.ConnectionFailureReason reason = 3;
  void clear_reason();
  static const int kReasonFieldNumber = 3;
  ::arsdk::devicemanager::ConnectionFailureReason reason() const;
  void set_reason(::arsdk::devicemanager::ConnectionFailureReason value);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Event.ConnectionFailure)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::arsdk::devicemanager::DeviceInfo* device_;
  int transport_;
  int reason_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Event_DiscoveredDevices :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Event.DiscoveredDevices) */ {
 public:
  Event_DiscoveredDevices();
  virtual ~Event_DiscoveredDevices();

  Event_DiscoveredDevices(const Event_DiscoveredDevices& from);

  inline Event_DiscoveredDevices& operator=(const Event_DiscoveredDevices& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event_DiscoveredDevices(Event_DiscoveredDevices&& from) noexcept
    : Event_DiscoveredDevices() {
    *this = ::std::move(from);
  }

  inline Event_DiscoveredDevices& operator=(Event_DiscoveredDevices&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Event_DiscoveredDevices& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event_DiscoveredDevices* internal_default_instance() {
    return reinterpret_cast<const Event_DiscoveredDevices*>(
               &_Event_DiscoveredDevices_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Event_DiscoveredDevices* other);
  friend void swap(Event_DiscoveredDevices& a, Event_DiscoveredDevices& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event_DiscoveredDevices* New() const final {
    return CreateMaybeMessage<Event_DiscoveredDevices>(nullptr);
  }

  Event_DiscoveredDevices* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event_DiscoveredDevices>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event_DiscoveredDevices& from);
  void MergeFrom(const Event_DiscoveredDevices& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event_DiscoveredDevices* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .arsdk.devicemanager.DiscoveredDevice devices = 1;
  int devices_size() const;
  void clear_devices();
  static const int kDevicesFieldNumber = 1;
  ::arsdk::devicemanager::DiscoveredDevice* mutable_devices(int index);
  ::google::protobuf::RepeatedPtrField< ::arsdk::devicemanager::DiscoveredDevice >*
      mutable_devices();
  const ::arsdk::devicemanager::DiscoveredDevice& devices(int index) const;
  ::arsdk::devicemanager::DiscoveredDevice* add_devices();
  const ::google::protobuf::RepeatedPtrField< ::arsdk::devicemanager::DiscoveredDevice >&
      devices() const;

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Event.DiscoveredDevices)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::arsdk::devicemanager::DiscoveredDevice > devices_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Event :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Event& default_instance();

  enum IdCase {
    kState = 16,
    kConnectionFailure = 17,
    kDiscoveredDevices = 18,
    ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(nullptr);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Event_State State;
  typedef Event_ConnectionFailure ConnectionFailure;
  typedef Event_DiscoveredDevices DiscoveredDevices;

  // accessors -------------------------------------------------------

  // .arsdk.devicemanager.Event.State state = 16;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 16;
  const ::arsdk::devicemanager::Event_State& state() const;
  ::arsdk::devicemanager::Event_State* release_state();
  ::arsdk::devicemanager::Event_State* mutable_state();
  void set_allocated_state(::arsdk::devicemanager::Event_State* state);

  // .arsdk.devicemanager.Event.ConnectionFailure connection_failure = 17;
  bool has_connection_failure() const;
  void clear_connection_failure();
  static const int kConnectionFailureFieldNumber = 17;
  const ::arsdk::devicemanager::Event_ConnectionFailure& connection_failure() const;
  ::arsdk::devicemanager::Event_ConnectionFailure* release_connection_failure();
  ::arsdk::devicemanager::Event_ConnectionFailure* mutable_connection_failure();
  void set_allocated_connection_failure(::arsdk::devicemanager::Event_ConnectionFailure* connection_failure);

  // .arsdk.devicemanager.Event.DiscoveredDevices discovered_devices = 18;
  bool has_discovered_devices() const;
  void clear_discovered_devices();
  static const int kDiscoveredDevicesFieldNumber = 18;
  const ::arsdk::devicemanager::Event_DiscoveredDevices& discovered_devices() const;
  ::arsdk::devicemanager::Event_DiscoveredDevices* release_discovered_devices();
  ::arsdk::devicemanager::Event_DiscoveredDevices* mutable_discovered_devices();
  void set_allocated_discovered_devices(::arsdk::devicemanager::Event_DiscoveredDevices* discovered_devices);

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Event)
 private:
  class HasBitSetters;
  void set_has_state();
  void set_has_connection_failure();
  void set_has_discovered_devices();

  inline bool has_id() const;
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    ::arsdk::devicemanager::Event_State* state_;
    ::arsdk::devicemanager::Event_ConnectionFailure* connection_failure_;
    ::arsdk::devicemanager::Event_DiscoveredDevices* discovered_devices_;
  } id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Capabilities_Microhard :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Capabilities.Microhard) */ {
 public:
  Capabilities_Microhard();
  virtual ~Capabilities_Microhard();

  Capabilities_Microhard(const Capabilities_Microhard& from);

  inline Capabilities_Microhard& operator=(const Capabilities_Microhard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Capabilities_Microhard(Capabilities_Microhard&& from) noexcept
    : Capabilities_Microhard() {
    *this = ::std::move(from);
  }

  inline Capabilities_Microhard& operator=(Capabilities_Microhard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Capabilities_Microhard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Capabilities_Microhard* internal_default_instance() {
    return reinterpret_cast<const Capabilities_Microhard*>(
               &_Capabilities_Microhard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Capabilities_Microhard* other);
  friend void swap(Capabilities_Microhard& a, Capabilities_Microhard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Capabilities_Microhard* New() const final {
    return CreateMaybeMessage<Capabilities_Microhard>(nullptr);
  }

  Capabilities_Microhard* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Capabilities_Microhard>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Capabilities_Microhard& from);
  void MergeFrom(const Capabilities_Microhard& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Capabilities_Microhard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 power_min = 2;
  void clear_power_min();
  static const int kPowerMinFieldNumber = 2;
  ::google::protobuf::uint32 power_min() const;
  void set_power_min(::google::protobuf::uint32 value);

  // uint32 power_max = 3;
  void clear_power_max();
  static const int kPowerMaxFieldNumber = 3;
  ::google::protobuf::uint32 power_max() const;
  void set_power_max(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Capabilities.Microhard)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 power_min_;
  ::google::protobuf::uint32 power_max_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class Capabilities :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.Capabilities) */ {
 public:
  Capabilities();
  virtual ~Capabilities();

  Capabilities(const Capabilities& from);

  inline Capabilities& operator=(const Capabilities& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Capabilities(Capabilities&& from) noexcept
    : Capabilities() {
    *this = ::std::move(from);
  }

  inline Capabilities& operator=(Capabilities&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Capabilities& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Capabilities* internal_default_instance() {
    return reinterpret_cast<const Capabilities*>(
               &_Capabilities_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Capabilities* other);
  friend void swap(Capabilities& a, Capabilities& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Capabilities* New() const final {
    return CreateMaybeMessage<Capabilities>(nullptr);
  }

  Capabilities* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Capabilities>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Capabilities& from);
  void MergeFrom(const Capabilities& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Capabilities* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Capabilities_Microhard Microhard;

  // accessors -------------------------------------------------------

  // repeated .arsdk.devicemanager.Transport discovery_transports = 1;
  int discovery_transports_size() const;
  void clear_discovery_transports();
  static const int kDiscoveryTransportsFieldNumber = 1;
  ::arsdk::devicemanager::Transport discovery_transports(int index) const;
  void set_discovery_transports(int index, ::arsdk::devicemanager::Transport value);
  void add_discovery_transports(::arsdk::devicemanager::Transport value);
  const ::google::protobuf::RepeatedField<int>& discovery_transports() const;
  ::google::protobuf::RepeatedField<int>* mutable_discovery_transports();

  // .arsdk.devicemanager.Capabilities.Microhard microhard = 2;
  bool has_microhard() const;
  void clear_microhard();
  static const int kMicrohardFieldNumber = 2;
  const ::arsdk::devicemanager::Capabilities_Microhard& microhard() const;
  ::arsdk::devicemanager::Capabilities_Microhard* release_microhard();
  ::arsdk::devicemanager::Capabilities_Microhard* mutable_microhard();
  void set_allocated_microhard(::arsdk::devicemanager::Capabilities_Microhard* microhard);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.Capabilities)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField<int> discovery_transports_;
  mutable std::atomic<int> _discovery_transports_cached_byte_size_;
  ::arsdk::devicemanager::Capabilities_Microhard* microhard_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class ConnectionState_Idle :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.ConnectionState.Idle) */ {
 public:
  ConnectionState_Idle();
  virtual ~ConnectionState_Idle();

  ConnectionState_Idle(const ConnectionState_Idle& from);

  inline ConnectionState_Idle& operator=(const ConnectionState_Idle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionState_Idle(ConnectionState_Idle&& from) noexcept
    : ConnectionState_Idle() {
    *this = ::std::move(from);
  }

  inline ConnectionState_Idle& operator=(ConnectionState_Idle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConnectionState_Idle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionState_Idle* internal_default_instance() {
    return reinterpret_cast<const ConnectionState_Idle*>(
               &_ConnectionState_Idle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ConnectionState_Idle* other);
  friend void swap(ConnectionState_Idle& a, ConnectionState_Idle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionState_Idle* New() const final {
    return CreateMaybeMessage<ConnectionState_Idle>(nullptr);
  }

  ConnectionState_Idle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionState_Idle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectionState_Idle& from);
  void MergeFrom(const ConnectionState_Idle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionState_Idle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.ConnectionState.Idle)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class ConnectionState_Searching :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.ConnectionState.Searching) */ {
 public:
  ConnectionState_Searching();
  virtual ~ConnectionState_Searching();

  ConnectionState_Searching(const ConnectionState_Searching& from);

  inline ConnectionState_Searching& operator=(const ConnectionState_Searching& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionState_Searching(ConnectionState_Searching&& from) noexcept
    : ConnectionState_Searching() {
    *this = ::std::move(from);
  }

  inline ConnectionState_Searching& operator=(ConnectionState_Searching&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConnectionState_Searching& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionState_Searching* internal_default_instance() {
    return reinterpret_cast<const ConnectionState_Searching*>(
               &_ConnectionState_Searching_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ConnectionState_Searching* other);
  friend void swap(ConnectionState_Searching& a, ConnectionState_Searching& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionState_Searching* New() const final {
    return CreateMaybeMessage<ConnectionState_Searching>(nullptr);
  }

  ConnectionState_Searching* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionState_Searching>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectionState_Searching& from);
  void MergeFrom(const ConnectionState_Searching& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionState_Searching* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.ConnectionState.Searching)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class ConnectionState_Connecting :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.ConnectionState.Connecting) */ {
 public:
  ConnectionState_Connecting();
  virtual ~ConnectionState_Connecting();

  ConnectionState_Connecting(const ConnectionState_Connecting& from);

  inline ConnectionState_Connecting& operator=(const ConnectionState_Connecting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionState_Connecting(ConnectionState_Connecting&& from) noexcept
    : ConnectionState_Connecting() {
    *this = ::std::move(from);
  }

  inline ConnectionState_Connecting& operator=(ConnectionState_Connecting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConnectionState_Connecting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionState_Connecting* internal_default_instance() {
    return reinterpret_cast<const ConnectionState_Connecting*>(
               &_ConnectionState_Connecting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ConnectionState_Connecting* other);
  friend void swap(ConnectionState_Connecting& a, ConnectionState_Connecting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionState_Connecting* New() const final {
    return CreateMaybeMessage<ConnectionState_Connecting>(nullptr);
  }

  ConnectionState_Connecting* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionState_Connecting>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectionState_Connecting& from);
  void MergeFrom(const ConnectionState_Connecting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionState_Connecting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .arsdk.devicemanager.DeviceInfo device = 1;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  const ::arsdk::devicemanager::DeviceInfo& device() const;
  ::arsdk::devicemanager::DeviceInfo* release_device();
  ::arsdk::devicemanager::DeviceInfo* mutable_device();
  void set_allocated_device(::arsdk::devicemanager::DeviceInfo* device);

  // .arsdk.devicemanager.Transport transport = 2;
  void clear_transport();
  static const int kTransportFieldNumber = 2;
  ::arsdk::devicemanager::Transport transport() const;
  void set_transport(::arsdk::devicemanager::Transport value);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.ConnectionState.Connecting)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::arsdk::devicemanager::DeviceInfo* device_;
  int transport_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class ConnectionState_Connected :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.ConnectionState.Connected) */ {
 public:
  ConnectionState_Connected();
  virtual ~ConnectionState_Connected();

  ConnectionState_Connected(const ConnectionState_Connected& from);

  inline ConnectionState_Connected& operator=(const ConnectionState_Connected& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionState_Connected(ConnectionState_Connected&& from) noexcept
    : ConnectionState_Connected() {
    *this = ::std::move(from);
  }

  inline ConnectionState_Connected& operator=(ConnectionState_Connected&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConnectionState_Connected& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionState_Connected* internal_default_instance() {
    return reinterpret_cast<const ConnectionState_Connected*>(
               &_ConnectionState_Connected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ConnectionState_Connected* other);
  friend void swap(ConnectionState_Connected& a, ConnectionState_Connected& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionState_Connected* New() const final {
    return CreateMaybeMessage<ConnectionState_Connected>(nullptr);
  }

  ConnectionState_Connected* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionState_Connected>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectionState_Connected& from);
  void MergeFrom(const ConnectionState_Connected& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionState_Connected* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .arsdk.devicemanager.DeviceInfo device = 1;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  const ::arsdk::devicemanager::DeviceInfo& device() const;
  ::arsdk::devicemanager::DeviceInfo* release_device();
  ::arsdk::devicemanager::DeviceInfo* mutable_device();
  void set_allocated_device(::arsdk::devicemanager::DeviceInfo* device);

  // .arsdk.devicemanager.Transport transport = 2;
  void clear_transport();
  static const int kTransportFieldNumber = 2;
  ::arsdk::devicemanager::Transport transport() const;
  void set_transport(::arsdk::devicemanager::Transport value);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.ConnectionState.Connected)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::arsdk::devicemanager::DeviceInfo* device_;
  int transport_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class ConnectionState_Disconnecting :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.ConnectionState.Disconnecting) */ {
 public:
  ConnectionState_Disconnecting();
  virtual ~ConnectionState_Disconnecting();

  ConnectionState_Disconnecting(const ConnectionState_Disconnecting& from);

  inline ConnectionState_Disconnecting& operator=(const ConnectionState_Disconnecting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionState_Disconnecting(ConnectionState_Disconnecting&& from) noexcept
    : ConnectionState_Disconnecting() {
    *this = ::std::move(from);
  }

  inline ConnectionState_Disconnecting& operator=(ConnectionState_Disconnecting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConnectionState_Disconnecting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionState_Disconnecting* internal_default_instance() {
    return reinterpret_cast<const ConnectionState_Disconnecting*>(
               &_ConnectionState_Disconnecting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ConnectionState_Disconnecting* other);
  friend void swap(ConnectionState_Disconnecting& a, ConnectionState_Disconnecting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionState_Disconnecting* New() const final {
    return CreateMaybeMessage<ConnectionState_Disconnecting>(nullptr);
  }

  ConnectionState_Disconnecting* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionState_Disconnecting>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectionState_Disconnecting& from);
  void MergeFrom(const ConnectionState_Disconnecting& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionState_Disconnecting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .arsdk.devicemanager.DeviceInfo device = 1;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  const ::arsdk::devicemanager::DeviceInfo& device() const;
  ::arsdk::devicemanager::DeviceInfo* release_device();
  ::arsdk::devicemanager::DeviceInfo* mutable_device();
  void set_allocated_device(::arsdk::devicemanager::DeviceInfo* device);

  // .arsdk.devicemanager.Transport transport = 2;
  void clear_transport();
  static const int kTransportFieldNumber = 2;
  ::arsdk::devicemanager::Transport transport() const;
  void set_transport(::arsdk::devicemanager::Transport value);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.ConnectionState.Disconnecting)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::arsdk::devicemanager::DeviceInfo* device_;
  int transport_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class ConnectionState :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.ConnectionState) */ {
 public:
  ConnectionState();
  virtual ~ConnectionState();

  ConnectionState(const ConnectionState& from);

  inline ConnectionState& operator=(const ConnectionState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectionState(ConnectionState&& from) noexcept
    : ConnectionState() {
    *this = ::std::move(from);
  }

  inline ConnectionState& operator=(ConnectionState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ConnectionState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionState* internal_default_instance() {
    return reinterpret_cast<const ConnectionState*>(
               &_ConnectionState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(ConnectionState* other);
  friend void swap(ConnectionState& a, ConnectionState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectionState* New() const final {
    return CreateMaybeMessage<ConnectionState>(nullptr);
  }

  ConnectionState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectionState& from);
  void MergeFrom(const ConnectionState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConnectionState_Idle Idle;
  typedef ConnectionState_Searching Searching;
  typedef ConnectionState_Connecting Connecting;
  typedef ConnectionState_Connected Connected;
  typedef ConnectionState_Disconnecting Disconnecting;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.ConnectionState)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class DeviceInfo :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.DeviceInfo) */ {
 public:
  DeviceInfo();
  virtual ~DeviceInfo();

  DeviceInfo(const DeviceInfo& from);

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DeviceInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(DeviceInfo* other);
  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceInfo* New() const final {
    return CreateMaybeMessage<DeviceInfo>(nullptr);
  }

  DeviceInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uid = 1;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_uid(::std::string&& value);
  #endif
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);

  // string network_id = 3;
  void clear_network_id();
  static const int kNetworkIdFieldNumber = 3;
  const ::std::string& network_id() const;
  void set_network_id(const ::std::string& value);
  #if LANG_CXX11
  void set_network_id(::std::string&& value);
  #endif
  void set_network_id(const char* value);
  void set_network_id(const char* value, size_t size);
  ::std::string* mutable_network_id();
  ::std::string* release_network_id();
  void set_allocated_network_id(::std::string* network_id);

  // uint32 model = 2;
  void clear_model();
  static const int kModelFieldNumber = 2;
  ::google::protobuf::uint32 model() const;
  void set_model(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.DeviceInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  ::google::protobuf::internal::ArenaStringPtr network_id_;
  ::google::protobuf::uint32 model_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class WifiInfo :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.WifiInfo) */ {
 public:
  WifiInfo();
  virtual ~WifiInfo();

  WifiInfo(const WifiInfo& from);

  inline WifiInfo& operator=(const WifiInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WifiInfo(WifiInfo&& from) noexcept
    : WifiInfo() {
    *this = ::std::move(from);
  }

  inline WifiInfo& operator=(WifiInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WifiInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WifiInfo* internal_default_instance() {
    return reinterpret_cast<const WifiInfo*>(
               &_WifiInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(WifiInfo* other);
  friend void swap(WifiInfo& a, WifiInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WifiInfo* New() const final {
    return CreateMaybeMessage<WifiInfo>(nullptr);
  }

  WifiInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WifiInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WifiInfo& from);
  void MergeFrom(const WifiInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WifiInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .arsdk.devicemanager.WifiSecurity security = 1;
  void clear_security();
  static const int kSecurityFieldNumber = 1;
  ::arsdk::devicemanager::WifiSecurity security() const;
  void set_security(::arsdk::devicemanager::WifiSecurity value);

  // bool saved_key = 2;
  void clear_saved_key();
  static const int kSavedKeyFieldNumber = 2;
  bool saved_key() const;
  void set_saved_key(bool value);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.WifiInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int security_;
  bool saved_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class CellularInfo :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.CellularInfo) */ {
 public:
  CellularInfo();
  virtual ~CellularInfo();

  CellularInfo(const CellularInfo& from);

  inline CellularInfo& operator=(const CellularInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CellularInfo(CellularInfo&& from) noexcept
    : CellularInfo() {
    *this = ::std::move(from);
  }

  inline CellularInfo& operator=(CellularInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CellularInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CellularInfo* internal_default_instance() {
    return reinterpret_cast<const CellularInfo*>(
               &_CellularInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(CellularInfo* other);
  friend void swap(CellularInfo& a, CellularInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CellularInfo* New() const final {
    return CreateMaybeMessage<CellularInfo>(nullptr);
  }

  CellularInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CellularInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CellularInfo& from);
  void MergeFrom(const CellularInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CellularInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.CellularInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class MicrohardInfo :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.MicrohardInfo) */ {
 public:
  MicrohardInfo();
  virtual ~MicrohardInfo();

  MicrohardInfo(const MicrohardInfo& from);

  inline MicrohardInfo& operator=(const MicrohardInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MicrohardInfo(MicrohardInfo&& from) noexcept
    : MicrohardInfo() {
    *this = ::std::move(from);
  }

  inline MicrohardInfo& operator=(MicrohardInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MicrohardInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MicrohardInfo* internal_default_instance() {
    return reinterpret_cast<const MicrohardInfo*>(
               &_MicrohardInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(MicrohardInfo* other);
  friend void swap(MicrohardInfo& a, MicrohardInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MicrohardInfo* New() const final {
    return CreateMaybeMessage<MicrohardInfo>(nullptr);
  }

  MicrohardInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MicrohardInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MicrohardInfo& from);
  void MergeFrom(const MicrohardInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MicrohardInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 power = 1;
  void clear_power();
  static const int kPowerFieldNumber = 1;
  ::google::protobuf::uint32 power() const;
  void set_power(::google::protobuf::uint32 value);

  // uint32 channel = 2;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // .arsdk.microhard.Bandwidth bandwidth = 3;
  void clear_bandwidth();
  static const int kBandwidthFieldNumber = 3;
  ::arsdk::microhard::Bandwidth bandwidth() const;
  void set_bandwidth(::arsdk::microhard::Bandwidth value);

  // .arsdk.microhard.Encryption encryption_algorithm = 4;
  void clear_encryption_algorithm();
  static const int kEncryptionAlgorithmFieldNumber = 4;
  ::arsdk::microhard::Encryption encryption_algorithm() const;
  void set_encryption_algorithm(::arsdk::microhard::Encryption value);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.MicrohardInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 power_;
  ::google::protobuf::uint32 channel_;
  int bandwidth_;
  int encryption_algorithm_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class KnownDevice :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.KnownDevice) */ {
 public:
  KnownDevice();
  virtual ~KnownDevice();

  KnownDevice(const KnownDevice& from);

  inline KnownDevice& operator=(const KnownDevice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KnownDevice(KnownDevice&& from) noexcept
    : KnownDevice() {
    *this = ::std::move(from);
  }

  inline KnownDevice& operator=(KnownDevice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const KnownDevice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KnownDevice* internal_default_instance() {
    return reinterpret_cast<const KnownDevice*>(
               &_KnownDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(KnownDevice* other);
  friend void swap(KnownDevice& a, KnownDevice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KnownDevice* New() const final {
    return CreateMaybeMessage<KnownDevice>(nullptr);
  }

  KnownDevice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KnownDevice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KnownDevice& from);
  void MergeFrom(const KnownDevice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KnownDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .arsdk.devicemanager.DeviceInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::arsdk::devicemanager::DeviceInfo& info() const;
  ::arsdk::devicemanager::DeviceInfo* release_info();
  ::arsdk::devicemanager::DeviceInfo* mutable_info();
  void set_allocated_info(::arsdk::devicemanager::DeviceInfo* info);

  // .arsdk.devicemanager.WifiInfo wifi = 2;
  bool has_wifi() const;
  void clear_wifi();
  static const int kWifiFieldNumber = 2;
  const ::arsdk::devicemanager::WifiInfo& wifi() const;
  ::arsdk::devicemanager::WifiInfo* release_wifi();
  ::arsdk::devicemanager::WifiInfo* mutable_wifi();
  void set_allocated_wifi(::arsdk::devicemanager::WifiInfo* wifi);

  // .arsdk.devicemanager.CellularInfo cellular = 3;
  bool has_cellular() const;
  void clear_cellular();
  static const int kCellularFieldNumber = 3;
  const ::arsdk::devicemanager::CellularInfo& cellular() const;
  ::arsdk::devicemanager::CellularInfo* release_cellular();
  ::arsdk::devicemanager::CellularInfo* mutable_cellular();
  void set_allocated_cellular(::arsdk::devicemanager::CellularInfo* cellular);

  // .arsdk.devicemanager.MicrohardInfo microhard = 4;
  bool has_microhard() const;
  void clear_microhard();
  static const int kMicrohardFieldNumber = 4;
  const ::arsdk::devicemanager::MicrohardInfo& microhard() const;
  ::arsdk::devicemanager::MicrohardInfo* release_microhard();
  ::arsdk::devicemanager::MicrohardInfo* mutable_microhard();
  void set_allocated_microhard(::arsdk::devicemanager::MicrohardInfo* microhard);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.KnownDevice)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::arsdk::devicemanager::DeviceInfo* info_;
  ::arsdk::devicemanager::WifiInfo* wifi_;
  ::arsdk::devicemanager::CellularInfo* cellular_;
  ::arsdk::devicemanager::MicrohardInfo* microhard_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class DiscoveredDevice_WifiVisibility :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.DiscoveredDevice.WifiVisibility) */ {
 public:
  DiscoveredDevice_WifiVisibility();
  virtual ~DiscoveredDevice_WifiVisibility();

  DiscoveredDevice_WifiVisibility(const DiscoveredDevice_WifiVisibility& from);

  inline DiscoveredDevice_WifiVisibility& operator=(const DiscoveredDevice_WifiVisibility& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiscoveredDevice_WifiVisibility(DiscoveredDevice_WifiVisibility&& from) noexcept
    : DiscoveredDevice_WifiVisibility() {
    *this = ::std::move(from);
  }

  inline DiscoveredDevice_WifiVisibility& operator=(DiscoveredDevice_WifiVisibility&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DiscoveredDevice_WifiVisibility& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiscoveredDevice_WifiVisibility* internal_default_instance() {
    return reinterpret_cast<const DiscoveredDevice_WifiVisibility*>(
               &_DiscoveredDevice_WifiVisibility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(DiscoveredDevice_WifiVisibility* other);
  friend void swap(DiscoveredDevice_WifiVisibility& a, DiscoveredDevice_WifiVisibility& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiscoveredDevice_WifiVisibility* New() const final {
    return CreateMaybeMessage<DiscoveredDevice_WifiVisibility>(nullptr);
  }

  DiscoveredDevice_WifiVisibility* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DiscoveredDevice_WifiVisibility>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DiscoveredDevice_WifiVisibility& from);
  void MergeFrom(const DiscoveredDevice_WifiVisibility& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscoveredDevice_WifiVisibility* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .arsdk.devicemanager.WifiInfo transport_info = 1;
  bool has_transport_info() const;
  void clear_transport_info();
  static const int kTransportInfoFieldNumber = 1;
  const ::arsdk::devicemanager::WifiInfo& transport_info() const;
  ::arsdk::devicemanager::WifiInfo* release_transport_info();
  ::arsdk::devicemanager::WifiInfo* mutable_transport_info();
  void set_allocated_transport_info(::arsdk::devicemanager::WifiInfo* transport_info);

  // sint32 rssi = 2;
  void clear_rssi();
  static const int kRssiFieldNumber = 2;
  ::google::protobuf::int32 rssi() const;
  void set_rssi(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.DiscoveredDevice.WifiVisibility)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::arsdk::devicemanager::WifiInfo* transport_info_;
  ::google::protobuf::int32 rssi_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class DiscoveredDevice_CellularVisibility :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.DiscoveredDevice.CellularVisibility) */ {
 public:
  DiscoveredDevice_CellularVisibility();
  virtual ~DiscoveredDevice_CellularVisibility();

  DiscoveredDevice_CellularVisibility(const DiscoveredDevice_CellularVisibility& from);

  inline DiscoveredDevice_CellularVisibility& operator=(const DiscoveredDevice_CellularVisibility& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiscoveredDevice_CellularVisibility(DiscoveredDevice_CellularVisibility&& from) noexcept
    : DiscoveredDevice_CellularVisibility() {
    *this = ::std::move(from);
  }

  inline DiscoveredDevice_CellularVisibility& operator=(DiscoveredDevice_CellularVisibility&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DiscoveredDevice_CellularVisibility& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiscoveredDevice_CellularVisibility* internal_default_instance() {
    return reinterpret_cast<const DiscoveredDevice_CellularVisibility*>(
               &_DiscoveredDevice_CellularVisibility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(DiscoveredDevice_CellularVisibility* other);
  friend void swap(DiscoveredDevice_CellularVisibility& a, DiscoveredDevice_CellularVisibility& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiscoveredDevice_CellularVisibility* New() const final {
    return CreateMaybeMessage<DiscoveredDevice_CellularVisibility>(nullptr);
  }

  DiscoveredDevice_CellularVisibility* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DiscoveredDevice_CellularVisibility>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DiscoveredDevice_CellularVisibility& from);
  void MergeFrom(const DiscoveredDevice_CellularVisibility& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscoveredDevice_CellularVisibility* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .arsdk.devicemanager.CellularInfo transport_info = 1;
  bool has_transport_info() const;
  void clear_transport_info();
  static const int kTransportInfoFieldNumber = 1;
  const ::arsdk::devicemanager::CellularInfo& transport_info() const;
  ::arsdk::devicemanager::CellularInfo* release_transport_info();
  ::arsdk::devicemanager::CellularInfo* mutable_transport_info();
  void set_allocated_transport_info(::arsdk::devicemanager::CellularInfo* transport_info);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.DiscoveredDevice.CellularVisibility)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::arsdk::devicemanager::CellularInfo* transport_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// -------------------------------------------------------------------

class DiscoveredDevice :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:arsdk.devicemanager.DiscoveredDevice) */ {
 public:
  DiscoveredDevice();
  virtual ~DiscoveredDevice();

  DiscoveredDevice(const DiscoveredDevice& from);

  inline DiscoveredDevice& operator=(const DiscoveredDevice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiscoveredDevice(DiscoveredDevice&& from) noexcept
    : DiscoveredDevice() {
    *this = ::std::move(from);
  }

  inline DiscoveredDevice& operator=(DiscoveredDevice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DiscoveredDevice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiscoveredDevice* internal_default_instance() {
    return reinterpret_cast<const DiscoveredDevice*>(
               &_DiscoveredDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(DiscoveredDevice* other);
  friend void swap(DiscoveredDevice& a, DiscoveredDevice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiscoveredDevice* New() const final {
    return CreateMaybeMessage<DiscoveredDevice>(nullptr);
  }

  DiscoveredDevice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DiscoveredDevice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DiscoveredDevice& from);
  void MergeFrom(const DiscoveredDevice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscoveredDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DiscoveredDevice_WifiVisibility WifiVisibility;
  typedef DiscoveredDevice_CellularVisibility CellularVisibility;

  // accessors -------------------------------------------------------

  // .arsdk.devicemanager.DeviceInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::arsdk::devicemanager::DeviceInfo& info() const;
  ::arsdk::devicemanager::DeviceInfo* release_info();
  ::arsdk::devicemanager::DeviceInfo* mutable_info();
  void set_allocated_info(::arsdk::devicemanager::DeviceInfo* info);

  // .arsdk.devicemanager.DiscoveredDevice.WifiVisibility wifi_visibility = 3;
  bool has_wifi_visibility() const;
  void clear_wifi_visibility();
  static const int kWifiVisibilityFieldNumber = 3;
  const ::arsdk::devicemanager::DiscoveredDevice_WifiVisibility& wifi_visibility() const;
  ::arsdk::devicemanager::DiscoveredDevice_WifiVisibility* release_wifi_visibility();
  ::arsdk::devicemanager::DiscoveredDevice_WifiVisibility* mutable_wifi_visibility();
  void set_allocated_wifi_visibility(::arsdk::devicemanager::DiscoveredDevice_WifiVisibility* wifi_visibility);

  // .arsdk.devicemanager.DiscoveredDevice.CellularVisibility cellular_visibility = 4;
  bool has_cellular_visibility() const;
  void clear_cellular_visibility();
  static const int kCellularVisibilityFieldNumber = 4;
  const ::arsdk::devicemanager::DiscoveredDevice_CellularVisibility& cellular_visibility() const;
  ::arsdk::devicemanager::DiscoveredDevice_CellularVisibility* release_cellular_visibility();
  ::arsdk::devicemanager::DiscoveredDevice_CellularVisibility* mutable_cellular_visibility();
  void set_allocated_cellular_visibility(::arsdk::devicemanager::DiscoveredDevice_CellularVisibility* cellular_visibility);

  // bool known = 2;
  void clear_known();
  static const int kKnownFieldNumber = 2;
  bool known() const;
  void set_known(bool value);

  // @@protoc_insertion_point(class_scope:arsdk.devicemanager.DiscoveredDevice)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::arsdk::devicemanager::DeviceInfo* info_;
  ::arsdk::devicemanager::DiscoveredDevice_WifiVisibility* wifi_visibility_;
  ::arsdk::devicemanager::DiscoveredDevice_CellularVisibility* cellular_visibility_;
  bool known_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_arsdk_2fdevice_5fmanager_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Command_GetState

// bool include_default_capabilities = 1;
inline void Command_GetState::clear_include_default_capabilities() {
  include_default_capabilities_ = false;
}
inline bool Command_GetState::include_default_capabilities() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Command.GetState.include_default_capabilities)
  return include_default_capabilities_;
}
inline void Command_GetState::set_include_default_capabilities(bool value) {
  
  include_default_capabilities_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.Command.GetState.include_default_capabilities)
}

// -------------------------------------------------------------------

// Command_ConnectDevice_Wifi

// string security_key = 1;
inline void Command_ConnectDevice_Wifi::clear_security_key() {
  security_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Command_ConnectDevice_Wifi::security_key() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Command.ConnectDevice.Wifi.security_key)
  return security_key_.GetNoArena();
}
inline void Command_ConnectDevice_Wifi::set_security_key(const ::std::string& value) {
  
  security_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.Command.ConnectDevice.Wifi.security_key)
}
#if LANG_CXX11
inline void Command_ConnectDevice_Wifi::set_security_key(::std::string&& value) {
  
  security_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arsdk.devicemanager.Command.ConnectDevice.Wifi.security_key)
}
#endif
inline void Command_ConnectDevice_Wifi::set_security_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  security_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arsdk.devicemanager.Command.ConnectDevice.Wifi.security_key)
}
inline void Command_ConnectDevice_Wifi::set_security_key(const char* value, size_t size) {
  
  security_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arsdk.devicemanager.Command.ConnectDevice.Wifi.security_key)
}
inline ::std::string* Command_ConnectDevice_Wifi::mutable_security_key() {
  
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Command.ConnectDevice.Wifi.security_key)
  return security_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command_ConnectDevice_Wifi::release_security_key() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Command.ConnectDevice.Wifi.security_key)
  
  return security_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Command_ConnectDevice_Wifi::set_allocated_security_key(::std::string* security_key) {
  if (security_key != nullptr) {
    
  } else {
    
  }
  security_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), security_key);
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.Command.ConnectDevice.Wifi.security_key)
}

// -------------------------------------------------------------------

// Command_ConnectDevice_Cellular

// -------------------------------------------------------------------

// Command_ConnectDevice_Microhard

// .google.protobuf.UInt32Value power = 1;
inline bool Command_ConnectDevice_Microhard::has_power() const {
  return this != internal_default_instance() && power_ != nullptr;
}
inline const ::google::protobuf::UInt32Value& Command_ConnectDevice_Microhard::power() const {
  const ::google::protobuf::UInt32Value* p = power_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Command.ConnectDevice.Microhard.power)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::UInt32Value*>(
      &::google::protobuf::_UInt32Value_default_instance_);
}
inline ::google::protobuf::UInt32Value* Command_ConnectDevice_Microhard::release_power() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Command.ConnectDevice.Microhard.power)
  
  ::google::protobuf::UInt32Value* temp = power_;
  power_ = nullptr;
  return temp;
}
inline ::google::protobuf::UInt32Value* Command_ConnectDevice_Microhard::mutable_power() {
  
  if (power_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::UInt32Value>(GetArenaNoVirtual());
    power_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Command.ConnectDevice.Microhard.power)
  return power_;
}
inline void Command_ConnectDevice_Microhard::set_allocated_power(::google::protobuf::UInt32Value* power) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(power_);
  }
  if (power) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(power)->GetArena();
    if (message_arena != submessage_arena) {
      power = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, power, submessage_arena);
    }
    
  } else {
    
  }
  power_ = power;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.Command.ConnectDevice.Microhard.power)
}

// -------------------------------------------------------------------

// Command_ConnectDevice

// string uid = 1;
inline void Command_ConnectDevice::clear_uid() {
  uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Command_ConnectDevice::uid() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Command.ConnectDevice.uid)
  return uid_.GetNoArena();
}
inline void Command_ConnectDevice::set_uid(const ::std::string& value) {
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.Command.ConnectDevice.uid)
}
#if LANG_CXX11
inline void Command_ConnectDevice::set_uid(::std::string&& value) {
  
  uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arsdk.devicemanager.Command.ConnectDevice.uid)
}
#endif
inline void Command_ConnectDevice::set_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arsdk.devicemanager.Command.ConnectDevice.uid)
}
inline void Command_ConnectDevice::set_uid(const char* value, size_t size) {
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arsdk.devicemanager.Command.ConnectDevice.uid)
}
inline ::std::string* Command_ConnectDevice::mutable_uid() {
  
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Command.ConnectDevice.uid)
  return uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command_ConnectDevice::release_uid() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Command.ConnectDevice.uid)
  
  return uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Command_ConnectDevice::set_allocated_uid(::std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid);
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.Command.ConnectDevice.uid)
}

// .arsdk.devicemanager.Command.ConnectDevice.Wifi wifi = 2;
inline bool Command_ConnectDevice::has_wifi() const {
  return transport_case() == kWifi;
}
inline void Command_ConnectDevice::set_has_wifi() {
  _oneof_case_[0] = kWifi;
}
inline void Command_ConnectDevice::clear_wifi() {
  if (has_wifi()) {
    delete transport_.wifi_;
    clear_has_transport();
  }
}
inline ::arsdk::devicemanager::Command_ConnectDevice_Wifi* Command_ConnectDevice::release_wifi() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Command.ConnectDevice.wifi)
  if (has_wifi()) {
    clear_has_transport();
      ::arsdk::devicemanager::Command_ConnectDevice_Wifi* temp = transport_.wifi_;
    transport_.wifi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::Command_ConnectDevice_Wifi& Command_ConnectDevice::wifi() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Command.ConnectDevice.wifi)
  return has_wifi()
      ? *transport_.wifi_
      : *reinterpret_cast< ::arsdk::devicemanager::Command_ConnectDevice_Wifi*>(&::arsdk::devicemanager::_Command_ConnectDevice_Wifi_default_instance_);
}
inline ::arsdk::devicemanager::Command_ConnectDevice_Wifi* Command_ConnectDevice::mutable_wifi() {
  if (!has_wifi()) {
    clear_transport();
    set_has_wifi();
    transport_.wifi_ = CreateMaybeMessage< ::arsdk::devicemanager::Command_ConnectDevice_Wifi >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Command.ConnectDevice.wifi)
  return transport_.wifi_;
}

// .arsdk.devicemanager.Command.ConnectDevice.Cellular cellular = 3;
inline bool Command_ConnectDevice::has_cellular() const {
  return transport_case() == kCellular;
}
inline void Command_ConnectDevice::set_has_cellular() {
  _oneof_case_[0] = kCellular;
}
inline void Command_ConnectDevice::clear_cellular() {
  if (has_cellular()) {
    delete transport_.cellular_;
    clear_has_transport();
  }
}
inline ::arsdk::devicemanager::Command_ConnectDevice_Cellular* Command_ConnectDevice::release_cellular() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Command.ConnectDevice.cellular)
  if (has_cellular()) {
    clear_has_transport();
      ::arsdk::devicemanager::Command_ConnectDevice_Cellular* temp = transport_.cellular_;
    transport_.cellular_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::Command_ConnectDevice_Cellular& Command_ConnectDevice::cellular() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Command.ConnectDevice.cellular)
  return has_cellular()
      ? *transport_.cellular_
      : *reinterpret_cast< ::arsdk::devicemanager::Command_ConnectDevice_Cellular*>(&::arsdk::devicemanager::_Command_ConnectDevice_Cellular_default_instance_);
}
inline ::arsdk::devicemanager::Command_ConnectDevice_Cellular* Command_ConnectDevice::mutable_cellular() {
  if (!has_cellular()) {
    clear_transport();
    set_has_cellular();
    transport_.cellular_ = CreateMaybeMessage< ::arsdk::devicemanager::Command_ConnectDevice_Cellular >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Command.ConnectDevice.cellular)
  return transport_.cellular_;
}

// .arsdk.devicemanager.Command.ConnectDevice.Microhard microhard = 4;
inline bool Command_ConnectDevice::has_microhard() const {
  return transport_case() == kMicrohard;
}
inline void Command_ConnectDevice::set_has_microhard() {
  _oneof_case_[0] = kMicrohard;
}
inline void Command_ConnectDevice::clear_microhard() {
  if (has_microhard()) {
    delete transport_.microhard_;
    clear_has_transport();
  }
}
inline ::arsdk::devicemanager::Command_ConnectDevice_Microhard* Command_ConnectDevice::release_microhard() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Command.ConnectDevice.microhard)
  if (has_microhard()) {
    clear_has_transport();
      ::arsdk::devicemanager::Command_ConnectDevice_Microhard* temp = transport_.microhard_;
    transport_.microhard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::Command_ConnectDevice_Microhard& Command_ConnectDevice::microhard() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Command.ConnectDevice.microhard)
  return has_microhard()
      ? *transport_.microhard_
      : *reinterpret_cast< ::arsdk::devicemanager::Command_ConnectDevice_Microhard*>(&::arsdk::devicemanager::_Command_ConnectDevice_Microhard_default_instance_);
}
inline ::arsdk::devicemanager::Command_ConnectDevice_Microhard* Command_ConnectDevice::mutable_microhard() {
  if (!has_microhard()) {
    clear_transport();
    set_has_microhard();
    transport_.microhard_ = CreateMaybeMessage< ::arsdk::devicemanager::Command_ConnectDevice_Microhard >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Command.ConnectDevice.microhard)
  return transport_.microhard_;
}

inline bool Command_ConnectDevice::has_transport() const {
  return transport_case() != TRANSPORT_NOT_SET;
}
inline void Command_ConnectDevice::clear_has_transport() {
  _oneof_case_[0] = TRANSPORT_NOT_SET;
}
inline Command_ConnectDevice::TransportCase Command_ConnectDevice::transport_case() const {
  return Command_ConnectDevice::TransportCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Command_ForgetDevice

// string uid = 1;
inline void Command_ForgetDevice::clear_uid() {
  uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Command_ForgetDevice::uid() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Command.ForgetDevice.uid)
  return uid_.GetNoArena();
}
inline void Command_ForgetDevice::set_uid(const ::std::string& value) {
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.Command.ForgetDevice.uid)
}
#if LANG_CXX11
inline void Command_ForgetDevice::set_uid(::std::string&& value) {
  
  uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arsdk.devicemanager.Command.ForgetDevice.uid)
}
#endif
inline void Command_ForgetDevice::set_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arsdk.devicemanager.Command.ForgetDevice.uid)
}
inline void Command_ForgetDevice::set_uid(const char* value, size_t size) {
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arsdk.devicemanager.Command.ForgetDevice.uid)
}
inline ::std::string* Command_ForgetDevice::mutable_uid() {
  
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Command.ForgetDevice.uid)
  return uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command_ForgetDevice::release_uid() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Command.ForgetDevice.uid)
  
  return uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Command_ForgetDevice::set_allocated_uid(::std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid);
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.Command.ForgetDevice.uid)
}

// -------------------------------------------------------------------

// Command_DiscoverDevices

// -------------------------------------------------------------------

// Command

// .arsdk.devicemanager.Command.GetState get_state = 16;
inline bool Command::has_get_state() const {
  return id_case() == kGetState;
}
inline void Command::set_has_get_state() {
  _oneof_case_[0] = kGetState;
}
inline void Command::clear_get_state() {
  if (has_get_state()) {
    delete id_.get_state_;
    clear_has_id();
  }
}
inline ::arsdk::devicemanager::Command_GetState* Command::release_get_state() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Command.get_state)
  if (has_get_state()) {
    clear_has_id();
      ::arsdk::devicemanager::Command_GetState* temp = id_.get_state_;
    id_.get_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::Command_GetState& Command::get_state() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Command.get_state)
  return has_get_state()
      ? *id_.get_state_
      : *reinterpret_cast< ::arsdk::devicemanager::Command_GetState*>(&::arsdk::devicemanager::_Command_GetState_default_instance_);
}
inline ::arsdk::devicemanager::Command_GetState* Command::mutable_get_state() {
  if (!has_get_state()) {
    clear_id();
    set_has_get_state();
    id_.get_state_ = CreateMaybeMessage< ::arsdk::devicemanager::Command_GetState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Command.get_state)
  return id_.get_state_;
}

// .arsdk.devicemanager.Command.ConnectDevice connect_device = 17;
inline bool Command::has_connect_device() const {
  return id_case() == kConnectDevice;
}
inline void Command::set_has_connect_device() {
  _oneof_case_[0] = kConnectDevice;
}
inline void Command::clear_connect_device() {
  if (has_connect_device()) {
    delete id_.connect_device_;
    clear_has_id();
  }
}
inline ::arsdk::devicemanager::Command_ConnectDevice* Command::release_connect_device() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Command.connect_device)
  if (has_connect_device()) {
    clear_has_id();
      ::arsdk::devicemanager::Command_ConnectDevice* temp = id_.connect_device_;
    id_.connect_device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::Command_ConnectDevice& Command::connect_device() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Command.connect_device)
  return has_connect_device()
      ? *id_.connect_device_
      : *reinterpret_cast< ::arsdk::devicemanager::Command_ConnectDevice*>(&::arsdk::devicemanager::_Command_ConnectDevice_default_instance_);
}
inline ::arsdk::devicemanager::Command_ConnectDevice* Command::mutable_connect_device() {
  if (!has_connect_device()) {
    clear_id();
    set_has_connect_device();
    id_.connect_device_ = CreateMaybeMessage< ::arsdk::devicemanager::Command_ConnectDevice >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Command.connect_device)
  return id_.connect_device_;
}

// .arsdk.devicemanager.Command.ForgetDevice forget_device = 18;
inline bool Command::has_forget_device() const {
  return id_case() == kForgetDevice;
}
inline void Command::set_has_forget_device() {
  _oneof_case_[0] = kForgetDevice;
}
inline void Command::clear_forget_device() {
  if (has_forget_device()) {
    delete id_.forget_device_;
    clear_has_id();
  }
}
inline ::arsdk::devicemanager::Command_ForgetDevice* Command::release_forget_device() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Command.forget_device)
  if (has_forget_device()) {
    clear_has_id();
      ::arsdk::devicemanager::Command_ForgetDevice* temp = id_.forget_device_;
    id_.forget_device_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::Command_ForgetDevice& Command::forget_device() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Command.forget_device)
  return has_forget_device()
      ? *id_.forget_device_
      : *reinterpret_cast< ::arsdk::devicemanager::Command_ForgetDevice*>(&::arsdk::devicemanager::_Command_ForgetDevice_default_instance_);
}
inline ::arsdk::devicemanager::Command_ForgetDevice* Command::mutable_forget_device() {
  if (!has_forget_device()) {
    clear_id();
    set_has_forget_device();
    id_.forget_device_ = CreateMaybeMessage< ::arsdk::devicemanager::Command_ForgetDevice >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Command.forget_device)
  return id_.forget_device_;
}

// .arsdk.devicemanager.Command.DiscoverDevices discover_devices = 19;
inline bool Command::has_discover_devices() const {
  return id_case() == kDiscoverDevices;
}
inline void Command::set_has_discover_devices() {
  _oneof_case_[0] = kDiscoverDevices;
}
inline void Command::clear_discover_devices() {
  if (has_discover_devices()) {
    delete id_.discover_devices_;
    clear_has_id();
  }
}
inline ::arsdk::devicemanager::Command_DiscoverDevices* Command::release_discover_devices() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Command.discover_devices)
  if (has_discover_devices()) {
    clear_has_id();
      ::arsdk::devicemanager::Command_DiscoverDevices* temp = id_.discover_devices_;
    id_.discover_devices_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::Command_DiscoverDevices& Command::discover_devices() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Command.discover_devices)
  return has_discover_devices()
      ? *id_.discover_devices_
      : *reinterpret_cast< ::arsdk::devicemanager::Command_DiscoverDevices*>(&::arsdk::devicemanager::_Command_DiscoverDevices_default_instance_);
}
inline ::arsdk::devicemanager::Command_DiscoverDevices* Command::mutable_discover_devices() {
  if (!has_discover_devices()) {
    clear_id();
    set_has_discover_devices();
    id_.discover_devices_ = CreateMaybeMessage< ::arsdk::devicemanager::Command_DiscoverDevices >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Command.discover_devices)
  return id_.discover_devices_;
}

inline bool Command::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void Command::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline Command::IdCase Command::id_case() const {
  return Command::IdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event_State_KnownDevices

// repeated .arsdk.devicemanager.KnownDevice devices = 2;
inline int Event_State_KnownDevices::devices_size() const {
  return devices_.size();
}
inline void Event_State_KnownDevices::clear_devices() {
  devices_.Clear();
}
inline ::arsdk::devicemanager::KnownDevice* Event_State_KnownDevices::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Event.State.KnownDevices.devices)
  return devices_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::arsdk::devicemanager::KnownDevice >*
Event_State_KnownDevices::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:arsdk.devicemanager.Event.State.KnownDevices.devices)
  return &devices_;
}
inline const ::arsdk::devicemanager::KnownDevice& Event_State_KnownDevices::devices(int index) const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.State.KnownDevices.devices)
  return devices_.Get(index);
}
inline ::arsdk::devicemanager::KnownDevice* Event_State_KnownDevices::add_devices() {
  // @@protoc_insertion_point(field_add:arsdk.devicemanager.Event.State.KnownDevices.devices)
  return devices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::arsdk::devicemanager::KnownDevice >&
Event_State_KnownDevices::devices() const {
  // @@protoc_insertion_point(field_list:arsdk.devicemanager.Event.State.KnownDevices.devices)
  return devices_;
}

// -------------------------------------------------------------------

// Event_State

// .arsdk.devicemanager.Capabilities default_capabilities = 1;
inline bool Event_State::has_default_capabilities() const {
  return this != internal_default_instance() && default_capabilities_ != nullptr;
}
inline void Event_State::clear_default_capabilities() {
  if (GetArenaNoVirtual() == nullptr && default_capabilities_ != nullptr) {
    delete default_capabilities_;
  }
  default_capabilities_ = nullptr;
}
inline const ::arsdk::devicemanager::Capabilities& Event_State::default_capabilities() const {
  const ::arsdk::devicemanager::Capabilities* p = default_capabilities_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.State.default_capabilities)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::Capabilities*>(
      &::arsdk::devicemanager::_Capabilities_default_instance_);
}
inline ::arsdk::devicemanager::Capabilities* Event_State::release_default_capabilities() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Event.State.default_capabilities)
  
  ::arsdk::devicemanager::Capabilities* temp = default_capabilities_;
  default_capabilities_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::Capabilities* Event_State::mutable_default_capabilities() {
  
  if (default_capabilities_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::Capabilities>(GetArenaNoVirtual());
    default_capabilities_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Event.State.default_capabilities)
  return default_capabilities_;
}
inline void Event_State::set_allocated_default_capabilities(::arsdk::devicemanager::Capabilities* default_capabilities) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete default_capabilities_;
  }
  if (default_capabilities) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      default_capabilities = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, default_capabilities, submessage_arena);
    }
    
  } else {
    
  }
  default_capabilities_ = default_capabilities;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.Event.State.default_capabilities)
}

// .arsdk.devicemanager.Event.State.KnownDevices known_devices = 3;
inline bool Event_State::has_known_devices() const {
  return this != internal_default_instance() && known_devices_ != nullptr;
}
inline void Event_State::clear_known_devices() {
  if (GetArenaNoVirtual() == nullptr && known_devices_ != nullptr) {
    delete known_devices_;
  }
  known_devices_ = nullptr;
}
inline const ::arsdk::devicemanager::Event_State_KnownDevices& Event_State::known_devices() const {
  const ::arsdk::devicemanager::Event_State_KnownDevices* p = known_devices_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.State.known_devices)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::Event_State_KnownDevices*>(
      &::arsdk::devicemanager::_Event_State_KnownDevices_default_instance_);
}
inline ::arsdk::devicemanager::Event_State_KnownDevices* Event_State::release_known_devices() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Event.State.known_devices)
  
  ::arsdk::devicemanager::Event_State_KnownDevices* temp = known_devices_;
  known_devices_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::Event_State_KnownDevices* Event_State::mutable_known_devices() {
  
  if (known_devices_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::Event_State_KnownDevices>(GetArenaNoVirtual());
    known_devices_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Event.State.known_devices)
  return known_devices_;
}
inline void Event_State::set_allocated_known_devices(::arsdk::devicemanager::Event_State_KnownDevices* known_devices) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete known_devices_;
  }
  if (known_devices) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      known_devices = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, known_devices, submessage_arena);
    }
    
  } else {
    
  }
  known_devices_ = known_devices;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.Event.State.known_devices)
}

// .arsdk.devicemanager.ConnectionState.Idle idle = 4;
inline bool Event_State::has_idle() const {
  return connection_state_case() == kIdle;
}
inline void Event_State::set_has_idle() {
  _oneof_case_[0] = kIdle;
}
inline void Event_State::clear_idle() {
  if (has_idle()) {
    delete connection_state_.idle_;
    clear_has_connection_state();
  }
}
inline ::arsdk::devicemanager::ConnectionState_Idle* Event_State::release_idle() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Event.State.idle)
  if (has_idle()) {
    clear_has_connection_state();
      ::arsdk::devicemanager::ConnectionState_Idle* temp = connection_state_.idle_;
    connection_state_.idle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::ConnectionState_Idle& Event_State::idle() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.State.idle)
  return has_idle()
      ? *connection_state_.idle_
      : *reinterpret_cast< ::arsdk::devicemanager::ConnectionState_Idle*>(&::arsdk::devicemanager::_ConnectionState_Idle_default_instance_);
}
inline ::arsdk::devicemanager::ConnectionState_Idle* Event_State::mutable_idle() {
  if (!has_idle()) {
    clear_connection_state();
    set_has_idle();
    connection_state_.idle_ = CreateMaybeMessage< ::arsdk::devicemanager::ConnectionState_Idle >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Event.State.idle)
  return connection_state_.idle_;
}

// .arsdk.devicemanager.ConnectionState.Searching searching = 5;
inline bool Event_State::has_searching() const {
  return connection_state_case() == kSearching;
}
inline void Event_State::set_has_searching() {
  _oneof_case_[0] = kSearching;
}
inline void Event_State::clear_searching() {
  if (has_searching()) {
    delete connection_state_.searching_;
    clear_has_connection_state();
  }
}
inline ::arsdk::devicemanager::ConnectionState_Searching* Event_State::release_searching() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Event.State.searching)
  if (has_searching()) {
    clear_has_connection_state();
      ::arsdk::devicemanager::ConnectionState_Searching* temp = connection_state_.searching_;
    connection_state_.searching_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::ConnectionState_Searching& Event_State::searching() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.State.searching)
  return has_searching()
      ? *connection_state_.searching_
      : *reinterpret_cast< ::arsdk::devicemanager::ConnectionState_Searching*>(&::arsdk::devicemanager::_ConnectionState_Searching_default_instance_);
}
inline ::arsdk::devicemanager::ConnectionState_Searching* Event_State::mutable_searching() {
  if (!has_searching()) {
    clear_connection_state();
    set_has_searching();
    connection_state_.searching_ = CreateMaybeMessage< ::arsdk::devicemanager::ConnectionState_Searching >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Event.State.searching)
  return connection_state_.searching_;
}

// .arsdk.devicemanager.ConnectionState.Connecting connecting = 6;
inline bool Event_State::has_connecting() const {
  return connection_state_case() == kConnecting;
}
inline void Event_State::set_has_connecting() {
  _oneof_case_[0] = kConnecting;
}
inline void Event_State::clear_connecting() {
  if (has_connecting()) {
    delete connection_state_.connecting_;
    clear_has_connection_state();
  }
}
inline ::arsdk::devicemanager::ConnectionState_Connecting* Event_State::release_connecting() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Event.State.connecting)
  if (has_connecting()) {
    clear_has_connection_state();
      ::arsdk::devicemanager::ConnectionState_Connecting* temp = connection_state_.connecting_;
    connection_state_.connecting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::ConnectionState_Connecting& Event_State::connecting() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.State.connecting)
  return has_connecting()
      ? *connection_state_.connecting_
      : *reinterpret_cast< ::arsdk::devicemanager::ConnectionState_Connecting*>(&::arsdk::devicemanager::_ConnectionState_Connecting_default_instance_);
}
inline ::arsdk::devicemanager::ConnectionState_Connecting* Event_State::mutable_connecting() {
  if (!has_connecting()) {
    clear_connection_state();
    set_has_connecting();
    connection_state_.connecting_ = CreateMaybeMessage< ::arsdk::devicemanager::ConnectionState_Connecting >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Event.State.connecting)
  return connection_state_.connecting_;
}

// .arsdk.devicemanager.ConnectionState.Connected connected = 7;
inline bool Event_State::has_connected() const {
  return connection_state_case() == kConnected;
}
inline void Event_State::set_has_connected() {
  _oneof_case_[0] = kConnected;
}
inline void Event_State::clear_connected() {
  if (has_connected()) {
    delete connection_state_.connected_;
    clear_has_connection_state();
  }
}
inline ::arsdk::devicemanager::ConnectionState_Connected* Event_State::release_connected() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Event.State.connected)
  if (has_connected()) {
    clear_has_connection_state();
      ::arsdk::devicemanager::ConnectionState_Connected* temp = connection_state_.connected_;
    connection_state_.connected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::ConnectionState_Connected& Event_State::connected() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.State.connected)
  return has_connected()
      ? *connection_state_.connected_
      : *reinterpret_cast< ::arsdk::devicemanager::ConnectionState_Connected*>(&::arsdk::devicemanager::_ConnectionState_Connected_default_instance_);
}
inline ::arsdk::devicemanager::ConnectionState_Connected* Event_State::mutable_connected() {
  if (!has_connected()) {
    clear_connection_state();
    set_has_connected();
    connection_state_.connected_ = CreateMaybeMessage< ::arsdk::devicemanager::ConnectionState_Connected >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Event.State.connected)
  return connection_state_.connected_;
}

// .arsdk.devicemanager.ConnectionState.Disconnecting disconnecting = 8;
inline bool Event_State::has_disconnecting() const {
  return connection_state_case() == kDisconnecting;
}
inline void Event_State::set_has_disconnecting() {
  _oneof_case_[0] = kDisconnecting;
}
inline void Event_State::clear_disconnecting() {
  if (has_disconnecting()) {
    delete connection_state_.disconnecting_;
    clear_has_connection_state();
  }
}
inline ::arsdk::devicemanager::ConnectionState_Disconnecting* Event_State::release_disconnecting() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Event.State.disconnecting)
  if (has_disconnecting()) {
    clear_has_connection_state();
      ::arsdk::devicemanager::ConnectionState_Disconnecting* temp = connection_state_.disconnecting_;
    connection_state_.disconnecting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::ConnectionState_Disconnecting& Event_State::disconnecting() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.State.disconnecting)
  return has_disconnecting()
      ? *connection_state_.disconnecting_
      : *reinterpret_cast< ::arsdk::devicemanager::ConnectionState_Disconnecting*>(&::arsdk::devicemanager::_ConnectionState_Disconnecting_default_instance_);
}
inline ::arsdk::devicemanager::ConnectionState_Disconnecting* Event_State::mutable_disconnecting() {
  if (!has_disconnecting()) {
    clear_connection_state();
    set_has_disconnecting();
    connection_state_.disconnecting_ = CreateMaybeMessage< ::arsdk::devicemanager::ConnectionState_Disconnecting >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Event.State.disconnecting)
  return connection_state_.disconnecting_;
}

inline bool Event_State::has_connection_state() const {
  return connection_state_case() != CONNECTION_STATE_NOT_SET;
}
inline void Event_State::clear_has_connection_state() {
  _oneof_case_[0] = CONNECTION_STATE_NOT_SET;
}
inline Event_State::ConnectionStateCase Event_State::connection_state_case() const {
  return Event_State::ConnectionStateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event_ConnectionFailure

// .arsdk.devicemanager.DeviceInfo device = 1;
inline bool Event_ConnectionFailure::has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline void Event_ConnectionFailure::clear_device() {
  if (GetArenaNoVirtual() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::arsdk::devicemanager::DeviceInfo& Event_ConnectionFailure::device() const {
  const ::arsdk::devicemanager::DeviceInfo* p = device_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.ConnectionFailure.device)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::DeviceInfo*>(
      &::arsdk::devicemanager::_DeviceInfo_default_instance_);
}
inline ::arsdk::devicemanager::DeviceInfo* Event_ConnectionFailure::release_device() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Event.ConnectionFailure.device)
  
  ::arsdk::devicemanager::DeviceInfo* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::DeviceInfo* Event_ConnectionFailure::mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::DeviceInfo>(GetArenaNoVirtual());
    device_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Event.ConnectionFailure.device)
  return device_;
}
inline void Event_ConnectionFailure::set_allocated_device(::arsdk::devicemanager::DeviceInfo* device) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.Event.ConnectionFailure.device)
}

// .arsdk.devicemanager.Transport transport = 2;
inline void Event_ConnectionFailure::clear_transport() {
  transport_ = 0;
}
inline ::arsdk::devicemanager::Transport Event_ConnectionFailure::transport() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.ConnectionFailure.transport)
  return static_cast< ::arsdk::devicemanager::Transport >(transport_);
}
inline void Event_ConnectionFailure::set_transport(::arsdk::devicemanager::Transport value) {
  
  transport_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.Event.ConnectionFailure.transport)
}

// .arsdk.devicemanager.ConnectionFailureReason reason = 3;
inline void Event_ConnectionFailure::clear_reason() {
  reason_ = 0;
}
inline ::arsdk::devicemanager::ConnectionFailureReason Event_ConnectionFailure::reason() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.ConnectionFailure.reason)
  return static_cast< ::arsdk::devicemanager::ConnectionFailureReason >(reason_);
}
inline void Event_ConnectionFailure::set_reason(::arsdk::devicemanager::ConnectionFailureReason value) {
  
  reason_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.Event.ConnectionFailure.reason)
}

// -------------------------------------------------------------------

// Event_DiscoveredDevices

// repeated .arsdk.devicemanager.DiscoveredDevice devices = 1;
inline int Event_DiscoveredDevices::devices_size() const {
  return devices_.size();
}
inline void Event_DiscoveredDevices::clear_devices() {
  devices_.Clear();
}
inline ::arsdk::devicemanager::DiscoveredDevice* Event_DiscoveredDevices::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Event.DiscoveredDevices.devices)
  return devices_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::arsdk::devicemanager::DiscoveredDevice >*
Event_DiscoveredDevices::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:arsdk.devicemanager.Event.DiscoveredDevices.devices)
  return &devices_;
}
inline const ::arsdk::devicemanager::DiscoveredDevice& Event_DiscoveredDevices::devices(int index) const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.DiscoveredDevices.devices)
  return devices_.Get(index);
}
inline ::arsdk::devicemanager::DiscoveredDevice* Event_DiscoveredDevices::add_devices() {
  // @@protoc_insertion_point(field_add:arsdk.devicemanager.Event.DiscoveredDevices.devices)
  return devices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::arsdk::devicemanager::DiscoveredDevice >&
Event_DiscoveredDevices::devices() const {
  // @@protoc_insertion_point(field_list:arsdk.devicemanager.Event.DiscoveredDevices.devices)
  return devices_;
}

// -------------------------------------------------------------------

// Event

// .arsdk.devicemanager.Event.State state = 16;
inline bool Event::has_state() const {
  return id_case() == kState;
}
inline void Event::set_has_state() {
  _oneof_case_[0] = kState;
}
inline void Event::clear_state() {
  if (has_state()) {
    delete id_.state_;
    clear_has_id();
  }
}
inline ::arsdk::devicemanager::Event_State* Event::release_state() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Event.state)
  if (has_state()) {
    clear_has_id();
      ::arsdk::devicemanager::Event_State* temp = id_.state_;
    id_.state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::Event_State& Event::state() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.state)
  return has_state()
      ? *id_.state_
      : *reinterpret_cast< ::arsdk::devicemanager::Event_State*>(&::arsdk::devicemanager::_Event_State_default_instance_);
}
inline ::arsdk::devicemanager::Event_State* Event::mutable_state() {
  if (!has_state()) {
    clear_id();
    set_has_state();
    id_.state_ = CreateMaybeMessage< ::arsdk::devicemanager::Event_State >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Event.state)
  return id_.state_;
}

// .arsdk.devicemanager.Event.ConnectionFailure connection_failure = 17;
inline bool Event::has_connection_failure() const {
  return id_case() == kConnectionFailure;
}
inline void Event::set_has_connection_failure() {
  _oneof_case_[0] = kConnectionFailure;
}
inline void Event::clear_connection_failure() {
  if (has_connection_failure()) {
    delete id_.connection_failure_;
    clear_has_id();
  }
}
inline ::arsdk::devicemanager::Event_ConnectionFailure* Event::release_connection_failure() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Event.connection_failure)
  if (has_connection_failure()) {
    clear_has_id();
      ::arsdk::devicemanager::Event_ConnectionFailure* temp = id_.connection_failure_;
    id_.connection_failure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::Event_ConnectionFailure& Event::connection_failure() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.connection_failure)
  return has_connection_failure()
      ? *id_.connection_failure_
      : *reinterpret_cast< ::arsdk::devicemanager::Event_ConnectionFailure*>(&::arsdk::devicemanager::_Event_ConnectionFailure_default_instance_);
}
inline ::arsdk::devicemanager::Event_ConnectionFailure* Event::mutable_connection_failure() {
  if (!has_connection_failure()) {
    clear_id();
    set_has_connection_failure();
    id_.connection_failure_ = CreateMaybeMessage< ::arsdk::devicemanager::Event_ConnectionFailure >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Event.connection_failure)
  return id_.connection_failure_;
}

// .arsdk.devicemanager.Event.DiscoveredDevices discovered_devices = 18;
inline bool Event::has_discovered_devices() const {
  return id_case() == kDiscoveredDevices;
}
inline void Event::set_has_discovered_devices() {
  _oneof_case_[0] = kDiscoveredDevices;
}
inline void Event::clear_discovered_devices() {
  if (has_discovered_devices()) {
    delete id_.discovered_devices_;
    clear_has_id();
  }
}
inline ::arsdk::devicemanager::Event_DiscoveredDevices* Event::release_discovered_devices() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Event.discovered_devices)
  if (has_discovered_devices()) {
    clear_has_id();
      ::arsdk::devicemanager::Event_DiscoveredDevices* temp = id_.discovered_devices_;
    id_.discovered_devices_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::arsdk::devicemanager::Event_DiscoveredDevices& Event::discovered_devices() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Event.discovered_devices)
  return has_discovered_devices()
      ? *id_.discovered_devices_
      : *reinterpret_cast< ::arsdk::devicemanager::Event_DiscoveredDevices*>(&::arsdk::devicemanager::_Event_DiscoveredDevices_default_instance_);
}
inline ::arsdk::devicemanager::Event_DiscoveredDevices* Event::mutable_discovered_devices() {
  if (!has_discovered_devices()) {
    clear_id();
    set_has_discovered_devices();
    id_.discovered_devices_ = CreateMaybeMessage< ::arsdk::devicemanager::Event_DiscoveredDevices >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Event.discovered_devices)
  return id_.discovered_devices_;
}

inline bool Event::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void Event::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline Event::IdCase Event::id_case() const {
  return Event::IdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Capabilities_Microhard

// uint32 power_min = 2;
inline void Capabilities_Microhard::clear_power_min() {
  power_min_ = 0u;
}
inline ::google::protobuf::uint32 Capabilities_Microhard::power_min() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Capabilities.Microhard.power_min)
  return power_min_;
}
inline void Capabilities_Microhard::set_power_min(::google::protobuf::uint32 value) {
  
  power_min_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.Capabilities.Microhard.power_min)
}

// uint32 power_max = 3;
inline void Capabilities_Microhard::clear_power_max() {
  power_max_ = 0u;
}
inline ::google::protobuf::uint32 Capabilities_Microhard::power_max() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Capabilities.Microhard.power_max)
  return power_max_;
}
inline void Capabilities_Microhard::set_power_max(::google::protobuf::uint32 value) {
  
  power_max_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.Capabilities.Microhard.power_max)
}

// -------------------------------------------------------------------

// Capabilities

// repeated .arsdk.devicemanager.Transport discovery_transports = 1;
inline int Capabilities::discovery_transports_size() const {
  return discovery_transports_.size();
}
inline void Capabilities::clear_discovery_transports() {
  discovery_transports_.Clear();
}
inline ::arsdk::devicemanager::Transport Capabilities::discovery_transports(int index) const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Capabilities.discovery_transports)
  return static_cast< ::arsdk::devicemanager::Transport >(discovery_transports_.Get(index));
}
inline void Capabilities::set_discovery_transports(int index, ::arsdk::devicemanager::Transport value) {
  discovery_transports_.Set(index, value);
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.Capabilities.discovery_transports)
}
inline void Capabilities::add_discovery_transports(::arsdk::devicemanager::Transport value) {
  discovery_transports_.Add(value);
  // @@protoc_insertion_point(field_add:arsdk.devicemanager.Capabilities.discovery_transports)
}
inline const ::google::protobuf::RepeatedField<int>&
Capabilities::discovery_transports() const {
  // @@protoc_insertion_point(field_list:arsdk.devicemanager.Capabilities.discovery_transports)
  return discovery_transports_;
}
inline ::google::protobuf::RepeatedField<int>*
Capabilities::mutable_discovery_transports() {
  // @@protoc_insertion_point(field_mutable_list:arsdk.devicemanager.Capabilities.discovery_transports)
  return &discovery_transports_;
}

// .arsdk.devicemanager.Capabilities.Microhard microhard = 2;
inline bool Capabilities::has_microhard() const {
  return this != internal_default_instance() && microhard_ != nullptr;
}
inline void Capabilities::clear_microhard() {
  if (GetArenaNoVirtual() == nullptr && microhard_ != nullptr) {
    delete microhard_;
  }
  microhard_ = nullptr;
}
inline const ::arsdk::devicemanager::Capabilities_Microhard& Capabilities::microhard() const {
  const ::arsdk::devicemanager::Capabilities_Microhard* p = microhard_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.Capabilities.microhard)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::Capabilities_Microhard*>(
      &::arsdk::devicemanager::_Capabilities_Microhard_default_instance_);
}
inline ::arsdk::devicemanager::Capabilities_Microhard* Capabilities::release_microhard() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.Capabilities.microhard)
  
  ::arsdk::devicemanager::Capabilities_Microhard* temp = microhard_;
  microhard_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::Capabilities_Microhard* Capabilities::mutable_microhard() {
  
  if (microhard_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::Capabilities_Microhard>(GetArenaNoVirtual());
    microhard_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.Capabilities.microhard)
  return microhard_;
}
inline void Capabilities::set_allocated_microhard(::arsdk::devicemanager::Capabilities_Microhard* microhard) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete microhard_;
  }
  if (microhard) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      microhard = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, microhard, submessage_arena);
    }
    
  } else {
    
  }
  microhard_ = microhard;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.Capabilities.microhard)
}

// -------------------------------------------------------------------

// ConnectionState_Idle

// -------------------------------------------------------------------

// ConnectionState_Searching

// -------------------------------------------------------------------

// ConnectionState_Connecting

// .arsdk.devicemanager.DeviceInfo device = 1;
inline bool ConnectionState_Connecting::has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline void ConnectionState_Connecting::clear_device() {
  if (GetArenaNoVirtual() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::arsdk::devicemanager::DeviceInfo& ConnectionState_Connecting::device() const {
  const ::arsdk::devicemanager::DeviceInfo* p = device_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.ConnectionState.Connecting.device)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::DeviceInfo*>(
      &::arsdk::devicemanager::_DeviceInfo_default_instance_);
}
inline ::arsdk::devicemanager::DeviceInfo* ConnectionState_Connecting::release_device() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.ConnectionState.Connecting.device)
  
  ::arsdk::devicemanager::DeviceInfo* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::DeviceInfo* ConnectionState_Connecting::mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::DeviceInfo>(GetArenaNoVirtual());
    device_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.ConnectionState.Connecting.device)
  return device_;
}
inline void ConnectionState_Connecting::set_allocated_device(::arsdk::devicemanager::DeviceInfo* device) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.ConnectionState.Connecting.device)
}

// .arsdk.devicemanager.Transport transport = 2;
inline void ConnectionState_Connecting::clear_transport() {
  transport_ = 0;
}
inline ::arsdk::devicemanager::Transport ConnectionState_Connecting::transport() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.ConnectionState.Connecting.transport)
  return static_cast< ::arsdk::devicemanager::Transport >(transport_);
}
inline void ConnectionState_Connecting::set_transport(::arsdk::devicemanager::Transport value) {
  
  transport_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.ConnectionState.Connecting.transport)
}

// -------------------------------------------------------------------

// ConnectionState_Connected

// .arsdk.devicemanager.DeviceInfo device = 1;
inline bool ConnectionState_Connected::has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline void ConnectionState_Connected::clear_device() {
  if (GetArenaNoVirtual() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::arsdk::devicemanager::DeviceInfo& ConnectionState_Connected::device() const {
  const ::arsdk::devicemanager::DeviceInfo* p = device_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.ConnectionState.Connected.device)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::DeviceInfo*>(
      &::arsdk::devicemanager::_DeviceInfo_default_instance_);
}
inline ::arsdk::devicemanager::DeviceInfo* ConnectionState_Connected::release_device() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.ConnectionState.Connected.device)
  
  ::arsdk::devicemanager::DeviceInfo* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::DeviceInfo* ConnectionState_Connected::mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::DeviceInfo>(GetArenaNoVirtual());
    device_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.ConnectionState.Connected.device)
  return device_;
}
inline void ConnectionState_Connected::set_allocated_device(::arsdk::devicemanager::DeviceInfo* device) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.ConnectionState.Connected.device)
}

// .arsdk.devicemanager.Transport transport = 2;
inline void ConnectionState_Connected::clear_transport() {
  transport_ = 0;
}
inline ::arsdk::devicemanager::Transport ConnectionState_Connected::transport() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.ConnectionState.Connected.transport)
  return static_cast< ::arsdk::devicemanager::Transport >(transport_);
}
inline void ConnectionState_Connected::set_transport(::arsdk::devicemanager::Transport value) {
  
  transport_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.ConnectionState.Connected.transport)
}

// -------------------------------------------------------------------

// ConnectionState_Disconnecting

// .arsdk.devicemanager.DeviceInfo device = 1;
inline bool ConnectionState_Disconnecting::has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline void ConnectionState_Disconnecting::clear_device() {
  if (GetArenaNoVirtual() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::arsdk::devicemanager::DeviceInfo& ConnectionState_Disconnecting::device() const {
  const ::arsdk::devicemanager::DeviceInfo* p = device_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.ConnectionState.Disconnecting.device)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::DeviceInfo*>(
      &::arsdk::devicemanager::_DeviceInfo_default_instance_);
}
inline ::arsdk::devicemanager::DeviceInfo* ConnectionState_Disconnecting::release_device() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.ConnectionState.Disconnecting.device)
  
  ::arsdk::devicemanager::DeviceInfo* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::DeviceInfo* ConnectionState_Disconnecting::mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::DeviceInfo>(GetArenaNoVirtual());
    device_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.ConnectionState.Disconnecting.device)
  return device_;
}
inline void ConnectionState_Disconnecting::set_allocated_device(::arsdk::devicemanager::DeviceInfo* device) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.ConnectionState.Disconnecting.device)
}

// .arsdk.devicemanager.Transport transport = 2;
inline void ConnectionState_Disconnecting::clear_transport() {
  transport_ = 0;
}
inline ::arsdk::devicemanager::Transport ConnectionState_Disconnecting::transport() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.ConnectionState.Disconnecting.transport)
  return static_cast< ::arsdk::devicemanager::Transport >(transport_);
}
inline void ConnectionState_Disconnecting::set_transport(::arsdk::devicemanager::Transport value) {
  
  transport_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.ConnectionState.Disconnecting.transport)
}

// -------------------------------------------------------------------

// ConnectionState

// -------------------------------------------------------------------

// DeviceInfo

// string uid = 1;
inline void DeviceInfo::clear_uid() {
  uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceInfo::uid() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.DeviceInfo.uid)
  return uid_.GetNoArena();
}
inline void DeviceInfo::set_uid(const ::std::string& value) {
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.DeviceInfo.uid)
}
#if LANG_CXX11
inline void DeviceInfo::set_uid(::std::string&& value) {
  
  uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arsdk.devicemanager.DeviceInfo.uid)
}
#endif
inline void DeviceInfo::set_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arsdk.devicemanager.DeviceInfo.uid)
}
inline void DeviceInfo::set_uid(const char* value, size_t size) {
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arsdk.devicemanager.DeviceInfo.uid)
}
inline ::std::string* DeviceInfo::mutable_uid() {
  
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.DeviceInfo.uid)
  return uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_uid() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.DeviceInfo.uid)
  
  return uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_uid(::std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid);
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.DeviceInfo.uid)
}

// uint32 model = 2;
inline void DeviceInfo::clear_model() {
  model_ = 0u;
}
inline ::google::protobuf::uint32 DeviceInfo::model() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.DeviceInfo.model)
  return model_;
}
inline void DeviceInfo::set_model(::google::protobuf::uint32 value) {
  
  model_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.DeviceInfo.model)
}

// string network_id = 3;
inline void DeviceInfo::clear_network_id() {
  network_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceInfo::network_id() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.DeviceInfo.network_id)
  return network_id_.GetNoArena();
}
inline void DeviceInfo::set_network_id(const ::std::string& value) {
  
  network_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.DeviceInfo.network_id)
}
#if LANG_CXX11
inline void DeviceInfo::set_network_id(::std::string&& value) {
  
  network_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:arsdk.devicemanager.DeviceInfo.network_id)
}
#endif
inline void DeviceInfo::set_network_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  network_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:arsdk.devicemanager.DeviceInfo.network_id)
}
inline void DeviceInfo::set_network_id(const char* value, size_t size) {
  
  network_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:arsdk.devicemanager.DeviceInfo.network_id)
}
inline ::std::string* DeviceInfo::mutable_network_id() {
  
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.DeviceInfo.network_id)
  return network_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceInfo::release_network_id() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.DeviceInfo.network_id)
  
  return network_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceInfo::set_allocated_network_id(::std::string* network_id) {
  if (network_id != nullptr) {
    
  } else {
    
  }
  network_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), network_id);
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.DeviceInfo.network_id)
}

// -------------------------------------------------------------------

// WifiInfo

// .arsdk.devicemanager.WifiSecurity security = 1;
inline void WifiInfo::clear_security() {
  security_ = 0;
}
inline ::arsdk::devicemanager::WifiSecurity WifiInfo::security() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.WifiInfo.security)
  return static_cast< ::arsdk::devicemanager::WifiSecurity >(security_);
}
inline void WifiInfo::set_security(::arsdk::devicemanager::WifiSecurity value) {
  
  security_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.WifiInfo.security)
}

// bool saved_key = 2;
inline void WifiInfo::clear_saved_key() {
  saved_key_ = false;
}
inline bool WifiInfo::saved_key() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.WifiInfo.saved_key)
  return saved_key_;
}
inline void WifiInfo::set_saved_key(bool value) {
  
  saved_key_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.WifiInfo.saved_key)
}

// -------------------------------------------------------------------

// CellularInfo

// -------------------------------------------------------------------

// MicrohardInfo

// uint32 power = 1;
inline void MicrohardInfo::clear_power() {
  power_ = 0u;
}
inline ::google::protobuf::uint32 MicrohardInfo::power() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.MicrohardInfo.power)
  return power_;
}
inline void MicrohardInfo::set_power(::google::protobuf::uint32 value) {
  
  power_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.MicrohardInfo.power)
}

// uint32 channel = 2;
inline void MicrohardInfo::clear_channel() {
  channel_ = 0u;
}
inline ::google::protobuf::uint32 MicrohardInfo::channel() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.MicrohardInfo.channel)
  return channel_;
}
inline void MicrohardInfo::set_channel(::google::protobuf::uint32 value) {
  
  channel_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.MicrohardInfo.channel)
}

// .arsdk.microhard.Bandwidth bandwidth = 3;
inline void MicrohardInfo::clear_bandwidth() {
  bandwidth_ = 0;
}
inline ::arsdk::microhard::Bandwidth MicrohardInfo::bandwidth() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.MicrohardInfo.bandwidth)
  return static_cast< ::arsdk::microhard::Bandwidth >(bandwidth_);
}
inline void MicrohardInfo::set_bandwidth(::arsdk::microhard::Bandwidth value) {
  
  bandwidth_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.MicrohardInfo.bandwidth)
}

// .arsdk.microhard.Encryption encryption_algorithm = 4;
inline void MicrohardInfo::clear_encryption_algorithm() {
  encryption_algorithm_ = 0;
}
inline ::arsdk::microhard::Encryption MicrohardInfo::encryption_algorithm() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.MicrohardInfo.encryption_algorithm)
  return static_cast< ::arsdk::microhard::Encryption >(encryption_algorithm_);
}
inline void MicrohardInfo::set_encryption_algorithm(::arsdk::microhard::Encryption value) {
  
  encryption_algorithm_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.MicrohardInfo.encryption_algorithm)
}

// -------------------------------------------------------------------

// KnownDevice

// .arsdk.devicemanager.DeviceInfo info = 1;
inline bool KnownDevice::has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline void KnownDevice::clear_info() {
  if (GetArenaNoVirtual() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::arsdk::devicemanager::DeviceInfo& KnownDevice::info() const {
  const ::arsdk::devicemanager::DeviceInfo* p = info_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.KnownDevice.info)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::DeviceInfo*>(
      &::arsdk::devicemanager::_DeviceInfo_default_instance_);
}
inline ::arsdk::devicemanager::DeviceInfo* KnownDevice::release_info() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.KnownDevice.info)
  
  ::arsdk::devicemanager::DeviceInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::DeviceInfo* KnownDevice::mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::DeviceInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.KnownDevice.info)
  return info_;
}
inline void KnownDevice::set_allocated_info(::arsdk::devicemanager::DeviceInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.KnownDevice.info)
}

// .arsdk.devicemanager.WifiInfo wifi = 2;
inline bool KnownDevice::has_wifi() const {
  return this != internal_default_instance() && wifi_ != nullptr;
}
inline void KnownDevice::clear_wifi() {
  if (GetArenaNoVirtual() == nullptr && wifi_ != nullptr) {
    delete wifi_;
  }
  wifi_ = nullptr;
}
inline const ::arsdk::devicemanager::WifiInfo& KnownDevice::wifi() const {
  const ::arsdk::devicemanager::WifiInfo* p = wifi_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.KnownDevice.wifi)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::WifiInfo*>(
      &::arsdk::devicemanager::_WifiInfo_default_instance_);
}
inline ::arsdk::devicemanager::WifiInfo* KnownDevice::release_wifi() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.KnownDevice.wifi)
  
  ::arsdk::devicemanager::WifiInfo* temp = wifi_;
  wifi_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::WifiInfo* KnownDevice::mutable_wifi() {
  
  if (wifi_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::WifiInfo>(GetArenaNoVirtual());
    wifi_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.KnownDevice.wifi)
  return wifi_;
}
inline void KnownDevice::set_allocated_wifi(::arsdk::devicemanager::WifiInfo* wifi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete wifi_;
  }
  if (wifi) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      wifi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wifi, submessage_arena);
    }
    
  } else {
    
  }
  wifi_ = wifi;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.KnownDevice.wifi)
}

// .arsdk.devicemanager.CellularInfo cellular = 3;
inline bool KnownDevice::has_cellular() const {
  return this != internal_default_instance() && cellular_ != nullptr;
}
inline void KnownDevice::clear_cellular() {
  if (GetArenaNoVirtual() == nullptr && cellular_ != nullptr) {
    delete cellular_;
  }
  cellular_ = nullptr;
}
inline const ::arsdk::devicemanager::CellularInfo& KnownDevice::cellular() const {
  const ::arsdk::devicemanager::CellularInfo* p = cellular_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.KnownDevice.cellular)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::CellularInfo*>(
      &::arsdk::devicemanager::_CellularInfo_default_instance_);
}
inline ::arsdk::devicemanager::CellularInfo* KnownDevice::release_cellular() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.KnownDevice.cellular)
  
  ::arsdk::devicemanager::CellularInfo* temp = cellular_;
  cellular_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::CellularInfo* KnownDevice::mutable_cellular() {
  
  if (cellular_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::CellularInfo>(GetArenaNoVirtual());
    cellular_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.KnownDevice.cellular)
  return cellular_;
}
inline void KnownDevice::set_allocated_cellular(::arsdk::devicemanager::CellularInfo* cellular) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cellular_;
  }
  if (cellular) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cellular = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cellular, submessage_arena);
    }
    
  } else {
    
  }
  cellular_ = cellular;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.KnownDevice.cellular)
}

// .arsdk.devicemanager.MicrohardInfo microhard = 4;
inline bool KnownDevice::has_microhard() const {
  return this != internal_default_instance() && microhard_ != nullptr;
}
inline void KnownDevice::clear_microhard() {
  if (GetArenaNoVirtual() == nullptr && microhard_ != nullptr) {
    delete microhard_;
  }
  microhard_ = nullptr;
}
inline const ::arsdk::devicemanager::MicrohardInfo& KnownDevice::microhard() const {
  const ::arsdk::devicemanager::MicrohardInfo* p = microhard_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.KnownDevice.microhard)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::MicrohardInfo*>(
      &::arsdk::devicemanager::_MicrohardInfo_default_instance_);
}
inline ::arsdk::devicemanager::MicrohardInfo* KnownDevice::release_microhard() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.KnownDevice.microhard)
  
  ::arsdk::devicemanager::MicrohardInfo* temp = microhard_;
  microhard_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::MicrohardInfo* KnownDevice::mutable_microhard() {
  
  if (microhard_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::MicrohardInfo>(GetArenaNoVirtual());
    microhard_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.KnownDevice.microhard)
  return microhard_;
}
inline void KnownDevice::set_allocated_microhard(::arsdk::devicemanager::MicrohardInfo* microhard) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete microhard_;
  }
  if (microhard) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      microhard = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, microhard, submessage_arena);
    }
    
  } else {
    
  }
  microhard_ = microhard;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.KnownDevice.microhard)
}

// -------------------------------------------------------------------

// DiscoveredDevice_WifiVisibility

// .arsdk.devicemanager.WifiInfo transport_info = 1;
inline bool DiscoveredDevice_WifiVisibility::has_transport_info() const {
  return this != internal_default_instance() && transport_info_ != nullptr;
}
inline void DiscoveredDevice_WifiVisibility::clear_transport_info() {
  if (GetArenaNoVirtual() == nullptr && transport_info_ != nullptr) {
    delete transport_info_;
  }
  transport_info_ = nullptr;
}
inline const ::arsdk::devicemanager::WifiInfo& DiscoveredDevice_WifiVisibility::transport_info() const {
  const ::arsdk::devicemanager::WifiInfo* p = transport_info_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.DiscoveredDevice.WifiVisibility.transport_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::WifiInfo*>(
      &::arsdk::devicemanager::_WifiInfo_default_instance_);
}
inline ::arsdk::devicemanager::WifiInfo* DiscoveredDevice_WifiVisibility::release_transport_info() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.DiscoveredDevice.WifiVisibility.transport_info)
  
  ::arsdk::devicemanager::WifiInfo* temp = transport_info_;
  transport_info_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::WifiInfo* DiscoveredDevice_WifiVisibility::mutable_transport_info() {
  
  if (transport_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::WifiInfo>(GetArenaNoVirtual());
    transport_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.DiscoveredDevice.WifiVisibility.transport_info)
  return transport_info_;
}
inline void DiscoveredDevice_WifiVisibility::set_allocated_transport_info(::arsdk::devicemanager::WifiInfo* transport_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete transport_info_;
  }
  if (transport_info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transport_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transport_info, submessage_arena);
    }
    
  } else {
    
  }
  transport_info_ = transport_info;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.DiscoveredDevice.WifiVisibility.transport_info)
}

// sint32 rssi = 2;
inline void DiscoveredDevice_WifiVisibility::clear_rssi() {
  rssi_ = 0;
}
inline ::google::protobuf::int32 DiscoveredDevice_WifiVisibility::rssi() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.DiscoveredDevice.WifiVisibility.rssi)
  return rssi_;
}
inline void DiscoveredDevice_WifiVisibility::set_rssi(::google::protobuf::int32 value) {
  
  rssi_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.DiscoveredDevice.WifiVisibility.rssi)
}

// -------------------------------------------------------------------

// DiscoveredDevice_CellularVisibility

// .arsdk.devicemanager.CellularInfo transport_info = 1;
inline bool DiscoveredDevice_CellularVisibility::has_transport_info() const {
  return this != internal_default_instance() && transport_info_ != nullptr;
}
inline void DiscoveredDevice_CellularVisibility::clear_transport_info() {
  if (GetArenaNoVirtual() == nullptr && transport_info_ != nullptr) {
    delete transport_info_;
  }
  transport_info_ = nullptr;
}
inline const ::arsdk::devicemanager::CellularInfo& DiscoveredDevice_CellularVisibility::transport_info() const {
  const ::arsdk::devicemanager::CellularInfo* p = transport_info_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.DiscoveredDevice.CellularVisibility.transport_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::CellularInfo*>(
      &::arsdk::devicemanager::_CellularInfo_default_instance_);
}
inline ::arsdk::devicemanager::CellularInfo* DiscoveredDevice_CellularVisibility::release_transport_info() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.DiscoveredDevice.CellularVisibility.transport_info)
  
  ::arsdk::devicemanager::CellularInfo* temp = transport_info_;
  transport_info_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::CellularInfo* DiscoveredDevice_CellularVisibility::mutable_transport_info() {
  
  if (transport_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::CellularInfo>(GetArenaNoVirtual());
    transport_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.DiscoveredDevice.CellularVisibility.transport_info)
  return transport_info_;
}
inline void DiscoveredDevice_CellularVisibility::set_allocated_transport_info(::arsdk::devicemanager::CellularInfo* transport_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete transport_info_;
  }
  if (transport_info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      transport_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transport_info, submessage_arena);
    }
    
  } else {
    
  }
  transport_info_ = transport_info;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.DiscoveredDevice.CellularVisibility.transport_info)
}

// -------------------------------------------------------------------

// DiscoveredDevice

// .arsdk.devicemanager.DeviceInfo info = 1;
inline bool DiscoveredDevice::has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline void DiscoveredDevice::clear_info() {
  if (GetArenaNoVirtual() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::arsdk::devicemanager::DeviceInfo& DiscoveredDevice::info() const {
  const ::arsdk::devicemanager::DeviceInfo* p = info_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.DiscoveredDevice.info)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::DeviceInfo*>(
      &::arsdk::devicemanager::_DeviceInfo_default_instance_);
}
inline ::arsdk::devicemanager::DeviceInfo* DiscoveredDevice::release_info() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.DiscoveredDevice.info)
  
  ::arsdk::devicemanager::DeviceInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::DeviceInfo* DiscoveredDevice::mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::DeviceInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.DiscoveredDevice.info)
  return info_;
}
inline void DiscoveredDevice::set_allocated_info(::arsdk::devicemanager::DeviceInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.DiscoveredDevice.info)
}

// bool known = 2;
inline void DiscoveredDevice::clear_known() {
  known_ = false;
}
inline bool DiscoveredDevice::known() const {
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.DiscoveredDevice.known)
  return known_;
}
inline void DiscoveredDevice::set_known(bool value) {
  
  known_ = value;
  // @@protoc_insertion_point(field_set:arsdk.devicemanager.DiscoveredDevice.known)
}

// .arsdk.devicemanager.DiscoveredDevice.WifiVisibility wifi_visibility = 3;
inline bool DiscoveredDevice::has_wifi_visibility() const {
  return this != internal_default_instance() && wifi_visibility_ != nullptr;
}
inline void DiscoveredDevice::clear_wifi_visibility() {
  if (GetArenaNoVirtual() == nullptr && wifi_visibility_ != nullptr) {
    delete wifi_visibility_;
  }
  wifi_visibility_ = nullptr;
}
inline const ::arsdk::devicemanager::DiscoveredDevice_WifiVisibility& DiscoveredDevice::wifi_visibility() const {
  const ::arsdk::devicemanager::DiscoveredDevice_WifiVisibility* p = wifi_visibility_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.DiscoveredDevice.wifi_visibility)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::DiscoveredDevice_WifiVisibility*>(
      &::arsdk::devicemanager::_DiscoveredDevice_WifiVisibility_default_instance_);
}
inline ::arsdk::devicemanager::DiscoveredDevice_WifiVisibility* DiscoveredDevice::release_wifi_visibility() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.DiscoveredDevice.wifi_visibility)
  
  ::arsdk::devicemanager::DiscoveredDevice_WifiVisibility* temp = wifi_visibility_;
  wifi_visibility_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::DiscoveredDevice_WifiVisibility* DiscoveredDevice::mutable_wifi_visibility() {
  
  if (wifi_visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::DiscoveredDevice_WifiVisibility>(GetArenaNoVirtual());
    wifi_visibility_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.DiscoveredDevice.wifi_visibility)
  return wifi_visibility_;
}
inline void DiscoveredDevice::set_allocated_wifi_visibility(::arsdk::devicemanager::DiscoveredDevice_WifiVisibility* wifi_visibility) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete wifi_visibility_;
  }
  if (wifi_visibility) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      wifi_visibility = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wifi_visibility, submessage_arena);
    }
    
  } else {
    
  }
  wifi_visibility_ = wifi_visibility;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.DiscoveredDevice.wifi_visibility)
}

// .arsdk.devicemanager.DiscoveredDevice.CellularVisibility cellular_visibility = 4;
inline bool DiscoveredDevice::has_cellular_visibility() const {
  return this != internal_default_instance() && cellular_visibility_ != nullptr;
}
inline void DiscoveredDevice::clear_cellular_visibility() {
  if (GetArenaNoVirtual() == nullptr && cellular_visibility_ != nullptr) {
    delete cellular_visibility_;
  }
  cellular_visibility_ = nullptr;
}
inline const ::arsdk::devicemanager::DiscoveredDevice_CellularVisibility& DiscoveredDevice::cellular_visibility() const {
  const ::arsdk::devicemanager::DiscoveredDevice_CellularVisibility* p = cellular_visibility_;
  // @@protoc_insertion_point(field_get:arsdk.devicemanager.DiscoveredDevice.cellular_visibility)
  return p != nullptr ? *p : *reinterpret_cast<const ::arsdk::devicemanager::DiscoveredDevice_CellularVisibility*>(
      &::arsdk::devicemanager::_DiscoveredDevice_CellularVisibility_default_instance_);
}
inline ::arsdk::devicemanager::DiscoveredDevice_CellularVisibility* DiscoveredDevice::release_cellular_visibility() {
  // @@protoc_insertion_point(field_release:arsdk.devicemanager.DiscoveredDevice.cellular_visibility)
  
  ::arsdk::devicemanager::DiscoveredDevice_CellularVisibility* temp = cellular_visibility_;
  cellular_visibility_ = nullptr;
  return temp;
}
inline ::arsdk::devicemanager::DiscoveredDevice_CellularVisibility* DiscoveredDevice::mutable_cellular_visibility() {
  
  if (cellular_visibility_ == nullptr) {
    auto* p = CreateMaybeMessage<::arsdk::devicemanager::DiscoveredDevice_CellularVisibility>(GetArenaNoVirtual());
    cellular_visibility_ = p;
  }
  // @@protoc_insertion_point(field_mutable:arsdk.devicemanager.DiscoveredDevice.cellular_visibility)
  return cellular_visibility_;
}
inline void DiscoveredDevice::set_allocated_cellular_visibility(::arsdk::devicemanager::DiscoveredDevice_CellularVisibility* cellular_visibility) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cellular_visibility_;
  }
  if (cellular_visibility) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cellular_visibility = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cellular_visibility, submessage_arena);
    }
    
  } else {
    
  }
  cellular_visibility_ = cellular_visibility;
  // @@protoc_insertion_point(field_set_allocated:arsdk.devicemanager.DiscoveredDevice.cellular_visibility)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace devicemanager
}  // namespace arsdk

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::arsdk::devicemanager::ConnectionFailureReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::arsdk::devicemanager::ConnectionFailureReason>() {
  return ::arsdk::devicemanager::ConnectionFailureReason_descriptor();
}
template <> struct is_proto_enum< ::arsdk::devicemanager::Transport> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::arsdk::devicemanager::Transport>() {
  return ::arsdk::devicemanager::Transport_descriptor();
}
template <> struct is_proto_enum< ::arsdk::devicemanager::WifiSecurity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::arsdk::devicemanager::WifiSecurity>() {
  return ::arsdk::devicemanager::WifiSecurity_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_arsdk_2fdevice_5fmanager_2eproto
