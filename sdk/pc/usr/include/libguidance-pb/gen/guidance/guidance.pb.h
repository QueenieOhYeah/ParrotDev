// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: guidance/guidance.proto

#ifndef PROTOBUF_INCLUDED_guidance_2fguidance_2eproto
#define PROTOBUF_INCLUDED_guidance_2fguidance_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "guidance/axes_cam_controller.pb.h"
#include "guidance/magic_carpet.pb.h"
#include <google/protobuf/any.pb.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_guidance_2fguidance_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_guidance_2fguidance_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_guidance_2fguidance_2eproto();
namespace Guidance {
namespace Messages {
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class GeofenceCenter;
class GeofenceCenterDefaultTypeInternal;
extern GeofenceCenterDefaultTypeInternal _GeofenceCenter_default_instance_;
class Mission;
class MissionDefaultTypeInternal;
extern MissionDefaultTypeInternal _Mission_default_instance_;
class ModeChanged;
class ModeChangedDefaultTypeInternal;
extern ModeChangedDefaultTypeInternal _ModeChanged_default_instance_;
class ModeList;
class ModeListDefaultTypeInternal;
extern ModeListDefaultTypeInternal _ModeList_default_instance_;
class Pcmd;
class PcmdDefaultTypeInternal;
extern PcmdDefaultTypeInternal _Pcmd_default_instance_;
class SetMode;
class SetModeDefaultTypeInternal;
extern SetModeDefaultTypeInternal _SetMode_default_instance_;
}  // namespace Messages
}  // namespace Guidance
namespace google {
namespace protobuf {
template<> ::Guidance::Messages::Command* Arena::CreateMaybeMessage<::Guidance::Messages::Command>(Arena*);
template<> ::Guidance::Messages::Error* Arena::CreateMaybeMessage<::Guidance::Messages::Error>(Arena*);
template<> ::Guidance::Messages::Event* Arena::CreateMaybeMessage<::Guidance::Messages::Event>(Arena*);
template<> ::Guidance::Messages::GeofenceCenter* Arena::CreateMaybeMessage<::Guidance::Messages::GeofenceCenter>(Arena*);
template<> ::Guidance::Messages::Mission* Arena::CreateMaybeMessage<::Guidance::Messages::Mission>(Arena*);
template<> ::Guidance::Messages::ModeChanged* Arena::CreateMaybeMessage<::Guidance::Messages::ModeChanged>(Arena*);
template<> ::Guidance::Messages::ModeList* Arena::CreateMaybeMessage<::Guidance::Messages::ModeList>(Arena*);
template<> ::Guidance::Messages::Pcmd* Arena::CreateMaybeMessage<::Guidance::Messages::Pcmd>(Arena*);
template<> ::Guidance::Messages::SetMode* Arena::CreateMaybeMessage<::Guidance::Messages::SetMode>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Guidance {
namespace Messages {

// ===================================================================

class SetMode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Messages.SetMode) */ {
 public:
  SetMode();
  virtual ~SetMode();

  SetMode(const SetMode& from);

  inline SetMode& operator=(const SetMode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetMode(SetMode&& from) noexcept
    : SetMode() {
    *this = ::std::move(from);
  }

  inline SetMode& operator=(SetMode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SetMode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetMode* internal_default_instance() {
    return reinterpret_cast<const SetMode*>(
               &_SetMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SetMode* other);
  friend void swap(SetMode& a, SetMode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetMode* New() const final {
    return CreateMaybeMessage<SetMode>(nullptr);
  }

  SetMode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetMode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetMode& from);
  void MergeFrom(const SetMode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetMode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Guidance.AxesCamController.Messages.Config cam_config_override = 4;
  int cam_config_override_size() const;
  void clear_cam_config_override();
  static const int kCamConfigOverrideFieldNumber = 4;
  ::Guidance::AxesCamController::Messages::Config* mutable_cam_config_override(int index);
  ::google::protobuf::RepeatedPtrField< ::Guidance::AxesCamController::Messages::Config >*
      mutable_cam_config_override();
  const ::Guidance::AxesCamController::Messages::Config& cam_config_override(int index) const;
  ::Guidance::AxesCamController::Messages::Config* add_cam_config_override();
  const ::google::protobuf::RepeatedPtrField< ::Guidance::AxesCamController::Messages::Config >&
      cam_config_override() const;

  // string mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  const ::std::string& mode() const;
  void set_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_mode(::std::string&& value);
  #endif
  void set_mode(const char* value);
  void set_mode(const char* value, size_t size);
  ::std::string* mutable_mode();
  ::std::string* release_mode();
  void set_allocated_mode(::std::string* mode);

  // .google.protobuf.Any config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::google::protobuf::Any& config() const;
  ::google::protobuf::Any* release_config();
  ::google::protobuf::Any* mutable_config();
  void set_allocated_config(::google::protobuf::Any* config);

  // @@protoc_insertion_point(class_scope:Guidance.Messages.SetMode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Guidance::AxesCamController::Messages::Config > cam_config_override_;
  ::google::protobuf::internal::ArenaStringPtr mode_;
  ::google::protobuf::Any* config_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2fguidance_2eproto;
};
// -------------------------------------------------------------------

class Pcmd :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Messages.Pcmd) */ {
 public:
  Pcmd();
  virtual ~Pcmd();

  Pcmd(const Pcmd& from);

  inline Pcmd& operator=(const Pcmd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pcmd(Pcmd&& from) noexcept
    : Pcmd() {
    *this = ::std::move(from);
  }

  inline Pcmd& operator=(Pcmd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Pcmd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pcmd* internal_default_instance() {
    return reinterpret_cast<const Pcmd*>(
               &_Pcmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Pcmd* other);
  friend void swap(Pcmd& a, Pcmd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pcmd* New() const final {
    return CreateMaybeMessage<Pcmd>(nullptr);
  }

  Pcmd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pcmd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pcmd& from);
  void MergeFrom(const Pcmd& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pcmd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float roll = 1;
  void clear_roll();
  static const int kRollFieldNumber = 1;
  float roll() const;
  void set_roll(float value);

  // float pitch = 2;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  float pitch() const;
  void set_pitch(float value);

  // float yaw = 3;
  void clear_yaw();
  static const int kYawFieldNumber = 3;
  float yaw() const;
  void set_yaw(float value);

  // float vertical = 4;
  void clear_vertical();
  static const int kVerticalFieldNumber = 4;
  float vertical() const;
  void set_vertical(float value);

  // bool gotofix = 5;
  void clear_gotofix();
  static const int kGotofixFieldNumber = 5;
  bool gotofix() const;
  void set_gotofix(bool value);

  // uint32 seqnum = 6;
  void clear_seqnum();
  static const int kSeqnumFieldNumber = 6;
  ::google::protobuf::uint32 seqnum() const;
  void set_seqnum(::google::protobuf::uint32 value);

  // uint32 ts = 7;
  void clear_ts();
  static const int kTsFieldNumber = 7;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Guidance.Messages.Pcmd)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float roll_;
  float pitch_;
  float yaw_;
  float vertical_;
  bool gotofix_;
  ::google::protobuf::uint32 seqnum_;
  ::google::protobuf::uint32 ts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2fguidance_2eproto;
};
// -------------------------------------------------------------------

class GeofenceCenter :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Messages.GeofenceCenter) */ {
 public:
  GeofenceCenter();
  virtual ~GeofenceCenter();

  GeofenceCenter(const GeofenceCenter& from);

  inline GeofenceCenter& operator=(const GeofenceCenter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GeofenceCenter(GeofenceCenter&& from) noexcept
    : GeofenceCenter() {
    *this = ::std::move(from);
  }

  inline GeofenceCenter& operator=(GeofenceCenter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GeofenceCenter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeofenceCenter* internal_default_instance() {
    return reinterpret_cast<const GeofenceCenter*>(
               &_GeofenceCenter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GeofenceCenter* other);
  friend void swap(GeofenceCenter& a, GeofenceCenter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GeofenceCenter* New() const final {
    return CreateMaybeMessage<GeofenceCenter>(nullptr);
  }

  GeofenceCenter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GeofenceCenter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GeofenceCenter& from);
  void MergeFrom(const GeofenceCenter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeofenceCenter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float latitude = 1;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  float latitude() const;
  void set_latitude(float value);

  // float longitude = 2;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  float longitude() const;
  void set_longitude(float value);

  // @@protoc_insertion_point(class_scope:Guidance.Messages.GeofenceCenter)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float latitude_;
  float longitude_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2fguidance_2eproto;
};
// -------------------------------------------------------------------

class ModeChanged :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Messages.ModeChanged) */ {
 public:
  ModeChanged();
  virtual ~ModeChanged();

  ModeChanged(const ModeChanged& from);

  inline ModeChanged& operator=(const ModeChanged& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModeChanged(ModeChanged&& from) noexcept
    : ModeChanged() {
    *this = ::std::move(from);
  }

  inline ModeChanged& operator=(ModeChanged&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ModeChanged& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModeChanged* internal_default_instance() {
    return reinterpret_cast<const ModeChanged*>(
               &_ModeChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ModeChanged* other);
  friend void swap(ModeChanged& a, ModeChanged& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModeChanged* New() const final {
    return CreateMaybeMessage<ModeChanged>(nullptr);
  }

  ModeChanged* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModeChanged>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModeChanged& from);
  void MergeFrom(const ModeChanged& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModeChanged* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string mode = 2;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  const ::std::string& mode() const;
  void set_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_mode(::std::string&& value);
  #endif
  void set_mode(const char* value);
  void set_mode(const char* value, size_t size);
  ::std::string* mutable_mode();
  ::std::string* release_mode();
  void set_allocated_mode(::std::string* mode);

  // bool ok = 1;
  void clear_ok();
  static const int kOkFieldNumber = 1;
  bool ok() const;
  void set_ok(bool value);

  // bool obstacle_avoidance_available = 3;
  void clear_obstacle_avoidance_available();
  static const int kObstacleAvoidanceAvailableFieldNumber = 3;
  bool obstacle_avoidance_available() const;
  void set_obstacle_avoidance_available(bool value);

  // bool geofence_available = 4;
  void clear_geofence_available();
  static const int kGeofenceAvailableFieldNumber = 4;
  bool geofence_available() const;
  void set_geofence_available(bool value);

  // @@protoc_insertion_point(class_scope:Guidance.Messages.ModeChanged)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr mode_;
  bool ok_;
  bool obstacle_avoidance_available_;
  bool geofence_available_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2fguidance_2eproto;
};
// -------------------------------------------------------------------

class Mission :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Messages.Mission) */ {
 public:
  Mission();
  virtual ~Mission();

  Mission(const Mission& from);

  inline Mission& operator=(const Mission& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mission(Mission&& from) noexcept
    : Mission() {
    *this = ::std::move(from);
  }

  inline Mission& operator=(Mission&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Mission& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mission* internal_default_instance() {
    return reinterpret_cast<const Mission*>(
               &_Mission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Mission* other);
  friend void swap(Mission& a, Mission& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mission* New() const final {
    return CreateMaybeMessage<Mission>(nullptr);
  }

  Mission* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Mission>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Mission& from);
  void MergeFrom(const Mission& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mission* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uid = 1;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_uid(::std::string&& value);
  #endif
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:Guidance.Messages.Mission)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2fguidance_2eproto;
};
// -------------------------------------------------------------------

class Command :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Messages.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command& default_instance();

  enum IdCase {
    kSetMode = 1,
    kSetPcmd = 2,
    kLoadMission = 10,
    kUnloadMission = 11,
    kSetObstacleAvoidance = 30,
    kSetGeofence = 40,
    kSetGeofenceCenter = 41,
    ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Guidance.Messages.SetMode set_mode = 1;
  bool has_set_mode() const;
  void clear_set_mode();
  static const int kSetModeFieldNumber = 1;
  const ::Guidance::Messages::SetMode& set_mode() const;
  ::Guidance::Messages::SetMode* release_set_mode();
  ::Guidance::Messages::SetMode* mutable_set_mode();
  void set_allocated_set_mode(::Guidance::Messages::SetMode* set_mode);

  // .Guidance.Messages.Pcmd set_pcmd = 2;
  bool has_set_pcmd() const;
  void clear_set_pcmd();
  static const int kSetPcmdFieldNumber = 2;
  const ::Guidance::Messages::Pcmd& set_pcmd() const;
  ::Guidance::Messages::Pcmd* release_set_pcmd();
  ::Guidance::Messages::Pcmd* mutable_set_pcmd();
  void set_allocated_set_pcmd(::Guidance::Messages::Pcmd* set_pcmd);

  // .Guidance.Messages.Mission load_mission = 10;
  bool has_load_mission() const;
  void clear_load_mission();
  static const int kLoadMissionFieldNumber = 10;
  const ::Guidance::Messages::Mission& load_mission() const;
  ::Guidance::Messages::Mission* release_load_mission();
  ::Guidance::Messages::Mission* mutable_load_mission();
  void set_allocated_load_mission(::Guidance::Messages::Mission* load_mission);

  // .Guidance.Messages.Mission unload_mission = 11;
  bool has_unload_mission() const;
  void clear_unload_mission();
  static const int kUnloadMissionFieldNumber = 11;
  const ::Guidance::Messages::Mission& unload_mission() const;
  ::Guidance::Messages::Mission* release_unload_mission();
  ::Guidance::Messages::Mission* mutable_unload_mission();
  void set_allocated_unload_mission(::Guidance::Messages::Mission* unload_mission);

  // bool set_obstacle_avoidance = 30;
  private:
  bool has_set_obstacle_avoidance() const;
  public:
  void clear_set_obstacle_avoidance();
  static const int kSetObstacleAvoidanceFieldNumber = 30;
  bool set_obstacle_avoidance() const;
  void set_set_obstacle_avoidance(bool value);

  // bool set_geofence = 40;
  private:
  bool has_set_geofence() const;
  public:
  void clear_set_geofence();
  static const int kSetGeofenceFieldNumber = 40;
  bool set_geofence() const;
  void set_set_geofence(bool value);

  // .Guidance.Messages.GeofenceCenter set_geofence_center = 41;
  bool has_set_geofence_center() const;
  void clear_set_geofence_center();
  static const int kSetGeofenceCenterFieldNumber = 41;
  const ::Guidance::Messages::GeofenceCenter& set_geofence_center() const;
  ::Guidance::Messages::GeofenceCenter* release_set_geofence_center();
  ::Guidance::Messages::GeofenceCenter* mutable_set_geofence_center();
  void set_allocated_set_geofence_center(::Guidance::Messages::GeofenceCenter* set_geofence_center);

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:Guidance.Messages.Command)
 private:
  class HasBitSetters;
  void set_has_set_mode();
  void set_has_set_pcmd();
  void set_has_load_mission();
  void set_has_unload_mission();
  void set_has_set_obstacle_avoidance();
  void set_has_set_geofence();
  void set_has_set_geofence_center();

  inline bool has_id() const;
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    ::Guidance::Messages::SetMode* set_mode_;
    ::Guidance::Messages::Pcmd* set_pcmd_;
    ::Guidance::Messages::Mission* load_mission_;
    ::Guidance::Messages::Mission* unload_mission_;
    bool set_obstacle_avoidance_;
    bool set_geofence_;
    ::Guidance::Messages::GeofenceCenter* set_geofence_center_;
  } id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_guidance_2fguidance_2eproto;
};
// -------------------------------------------------------------------

class ModeList :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Messages.ModeList) */ {
 public:
  ModeList();
  virtual ~ModeList();

  ModeList(const ModeList& from);

  inline ModeList& operator=(const ModeList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModeList(ModeList&& from) noexcept
    : ModeList() {
    *this = ::std::move(from);
  }

  inline ModeList& operator=(ModeList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ModeList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModeList* internal_default_instance() {
    return reinterpret_cast<const ModeList*>(
               &_ModeList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ModeList* other);
  friend void swap(ModeList& a, ModeList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModeList* New() const final {
    return CreateMaybeMessage<ModeList>(nullptr);
  }

  ModeList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModeList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModeList& from);
  void MergeFrom(const ModeList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModeList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string loaded_modes = 1;
  int loaded_modes_size() const;
  void clear_loaded_modes();
  static const int kLoadedModesFieldNumber = 1;
  const ::std::string& loaded_modes(int index) const;
  ::std::string* mutable_loaded_modes(int index);
  void set_loaded_modes(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_loaded_modes(int index, ::std::string&& value);
  #endif
  void set_loaded_modes(int index, const char* value);
  void set_loaded_modes(int index, const char* value, size_t size);
  ::std::string* add_loaded_modes();
  void add_loaded_modes(const ::std::string& value);
  #if LANG_CXX11
  void add_loaded_modes(::std::string&& value);
  #endif
  void add_loaded_modes(const char* value);
  void add_loaded_modes(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& loaded_modes() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_loaded_modes();

  // @@protoc_insertion_point(class_scope:Guidance.Messages.ModeList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> loaded_modes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2fguidance_2eproto;
};
// -------------------------------------------------------------------

class Error :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Messages.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return CreateMaybeMessage<Error>(nullptr);
  }

  Error* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // string mode = 2;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  const ::std::string& mode() const;
  void set_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_mode(::std::string&& value);
  #endif
  void set_mode(const char* value);
  void set_mode(const char* value, size_t size);
  ::std::string* mutable_mode();
  ::std::string* release_mode();
  void set_allocated_mode(::std::string* mode);

  // @@protoc_insertion_point(class_scope:Guidance.Messages.Error)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr mode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_guidance_2fguidance_2eproto;
};
// -------------------------------------------------------------------

class Event :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Guidance.Messages.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Event& default_instance();

  enum IdCase {
    kInitOk = 1,
    kModeChanged = 2,
    kError = 3,
    kModeListChanged = 4,
    kHighTrajectoryDeviation = 30,
    kObstacleAvoidanceStuck = 31,
    kObstacleAvoidanceFailure = 32,
    kObstacleAvoidanceBlindMotionDirection = 33,
    kGotofixDone = 40,
    kGotofreezeDone = 41,
    kHorizontalGeofenceReached = 100,
    kVerticalGeofenceReached = 101,
    kGeofenceCenterChanged = 102,
    ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(nullptr);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Guidance.Messages.ModeList init_ok = 1;
  bool has_init_ok() const;
  void clear_init_ok();
  static const int kInitOkFieldNumber = 1;
  const ::Guidance::Messages::ModeList& init_ok() const;
  ::Guidance::Messages::ModeList* release_init_ok();
  ::Guidance::Messages::ModeList* mutable_init_ok();
  void set_allocated_init_ok(::Guidance::Messages::ModeList* init_ok);

  // .Guidance.Messages.ModeChanged mode_changed = 2;
  bool has_mode_changed() const;
  void clear_mode_changed();
  static const int kModeChangedFieldNumber = 2;
  const ::Guidance::Messages::ModeChanged& mode_changed() const;
  ::Guidance::Messages::ModeChanged* release_mode_changed();
  ::Guidance::Messages::ModeChanged* mutable_mode_changed();
  void set_allocated_mode_changed(::Guidance::Messages::ModeChanged* mode_changed);

  // .Guidance.Messages.Error error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::Guidance::Messages::Error& error() const;
  ::Guidance::Messages::Error* release_error();
  ::Guidance::Messages::Error* mutable_error();
  void set_allocated_error(::Guidance::Messages::Error* error);

  // .Guidance.Messages.ModeList mode_list_changed = 4;
  bool has_mode_list_changed() const;
  void clear_mode_list_changed();
  static const int kModeListChangedFieldNumber = 4;
  const ::Guidance::Messages::ModeList& mode_list_changed() const;
  ::Guidance::Messages::ModeList* release_mode_list_changed();
  ::Guidance::Messages::ModeList* mutable_mode_list_changed();
  void set_allocated_mode_list_changed(::Guidance::Messages::ModeList* mode_list_changed);

  // bool high_trajectory_deviation = 30;
  private:
  bool has_high_trajectory_deviation() const;
  public:
  void clear_high_trajectory_deviation();
  static const int kHighTrajectoryDeviationFieldNumber = 30;
  bool high_trajectory_deviation() const;
  void set_high_trajectory_deviation(bool value);

  // bool obstacle_avoidance_stuck = 31;
  private:
  bool has_obstacle_avoidance_stuck() const;
  public:
  void clear_obstacle_avoidance_stuck();
  static const int kObstacleAvoidanceStuckFieldNumber = 31;
  bool obstacle_avoidance_stuck() const;
  void set_obstacle_avoidance_stuck(bool value);

  // bool obstacle_avoidance_failure = 32;
  private:
  bool has_obstacle_avoidance_failure() const;
  public:
  void clear_obstacle_avoidance_failure();
  static const int kObstacleAvoidanceFailureFieldNumber = 32;
  bool obstacle_avoidance_failure() const;
  void set_obstacle_avoidance_failure(bool value);

  // bool obstacle_avoidance_blind_motion_direction = 33;
  private:
  bool has_obstacle_avoidance_blind_motion_direction() const;
  public:
  void clear_obstacle_avoidance_blind_motion_direction();
  static const int kObstacleAvoidanceBlindMotionDirectionFieldNumber = 33;
  bool obstacle_avoidance_blind_motion_direction() const;
  void set_obstacle_avoidance_blind_motion_direction(bool value);

  // .google.protobuf.Empty gotofix_done = 40;
  bool has_gotofix_done() const;
  void clear_gotofix_done();
  static const int kGotofixDoneFieldNumber = 40;
  const ::google::protobuf::Empty& gotofix_done() const;
  ::google::protobuf::Empty* release_gotofix_done();
  ::google::protobuf::Empty* mutable_gotofix_done();
  void set_allocated_gotofix_done(::google::protobuf::Empty* gotofix_done);

  // .google.protobuf.Empty gotofreeze_done = 41;
  bool has_gotofreeze_done() const;
  void clear_gotofreeze_done();
  static const int kGotofreezeDoneFieldNumber = 41;
  const ::google::protobuf::Empty& gotofreeze_done() const;
  ::google::protobuf::Empty* release_gotofreeze_done();
  ::google::protobuf::Empty* mutable_gotofreeze_done();
  void set_allocated_gotofreeze_done(::google::protobuf::Empty* gotofreeze_done);

  // bool horizontal_geofence_reached = 100;
  private:
  bool has_horizontal_geofence_reached() const;
  public:
  void clear_horizontal_geofence_reached();
  static const int kHorizontalGeofenceReachedFieldNumber = 100;
  bool horizontal_geofence_reached() const;
  void set_horizontal_geofence_reached(bool value);

  // bool vertical_geofence_reached = 101;
  private:
  bool has_vertical_geofence_reached() const;
  public:
  void clear_vertical_geofence_reached();
  static const int kVerticalGeofenceReachedFieldNumber = 101;
  bool vertical_geofence_reached() const;
  void set_vertical_geofence_reached(bool value);

  // .Guidance.Messages.GeofenceCenter geofence_center_changed = 102;
  bool has_geofence_center_changed() const;
  void clear_geofence_center_changed();
  static const int kGeofenceCenterChangedFieldNumber = 102;
  const ::Guidance::Messages::GeofenceCenter& geofence_center_changed() const;
  ::Guidance::Messages::GeofenceCenter* release_geofence_center_changed();
  ::Guidance::Messages::GeofenceCenter* mutable_geofence_center_changed();
  void set_allocated_geofence_center_changed(::Guidance::Messages::GeofenceCenter* geofence_center_changed);

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:Guidance.Messages.Event)
 private:
  class HasBitSetters;
  void set_has_init_ok();
  void set_has_mode_changed();
  void set_has_error();
  void set_has_mode_list_changed();
  void set_has_high_trajectory_deviation();
  void set_has_obstacle_avoidance_stuck();
  void set_has_obstacle_avoidance_failure();
  void set_has_obstacle_avoidance_blind_motion_direction();
  void set_has_gotofix_done();
  void set_has_gotofreeze_done();
  void set_has_horizontal_geofence_reached();
  void set_has_vertical_geofence_reached();
  void set_has_geofence_center_changed();

  inline bool has_id() const;
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    ::Guidance::Messages::ModeList* init_ok_;
    ::Guidance::Messages::ModeChanged* mode_changed_;
    ::Guidance::Messages::Error* error_;
    ::Guidance::Messages::ModeList* mode_list_changed_;
    bool high_trajectory_deviation_;
    bool obstacle_avoidance_stuck_;
    bool obstacle_avoidance_failure_;
    bool obstacle_avoidance_blind_motion_direction_;
    ::google::protobuf::Empty* gotofix_done_;
    ::google::protobuf::Empty* gotofreeze_done_;
    bool horizontal_geofence_reached_;
    bool vertical_geofence_reached_;
    ::Guidance::Messages::GeofenceCenter* geofence_center_changed_;
  } id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_guidance_2fguidance_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SetMode

// string mode = 1;
inline void SetMode::clear_mode() {
  mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetMode::mode() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.SetMode.mode)
  return mode_.GetNoArena();
}
inline void SetMode::set_mode(const ::std::string& value) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Guidance.Messages.SetMode.mode)
}
#if LANG_CXX11
inline void SetMode::set_mode(::std::string&& value) {
  
  mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Guidance.Messages.SetMode.mode)
}
#endif
inline void SetMode::set_mode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Guidance.Messages.SetMode.mode)
}
inline void SetMode::set_mode(const char* value, size_t size) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Guidance.Messages.SetMode.mode)
}
inline ::std::string* SetMode::mutable_mode() {
  
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.SetMode.mode)
  return mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetMode::release_mode() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.SetMode.mode)
  
  return mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetMode::set_allocated_mode(::std::string* mode) {
  if (mode != nullptr) {
    
  } else {
    
  }
  mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mode);
  // @@protoc_insertion_point(field_set_allocated:Guidance.Messages.SetMode.mode)
}

// .google.protobuf.Any config = 2;
inline bool SetMode::has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline const ::google::protobuf::Any& SetMode::config() const {
  const ::google::protobuf::Any* p = config_;
  // @@protoc_insertion_point(field_get:Guidance.Messages.SetMode.config)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* SetMode::release_config() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.SetMode.config)
  
  ::google::protobuf::Any* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* SetMode::mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.SetMode.config)
  return config_;
}
inline void SetMode::set_allocated_config(::google::protobuf::Any* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(config_);
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:Guidance.Messages.SetMode.config)
}

// repeated .Guidance.AxesCamController.Messages.Config cam_config_override = 4;
inline int SetMode::cam_config_override_size() const {
  return cam_config_override_.size();
}
inline ::Guidance::AxesCamController::Messages::Config* SetMode::mutable_cam_config_override(int index) {
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.SetMode.cam_config_override)
  return cam_config_override_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Guidance::AxesCamController::Messages::Config >*
SetMode::mutable_cam_config_override() {
  // @@protoc_insertion_point(field_mutable_list:Guidance.Messages.SetMode.cam_config_override)
  return &cam_config_override_;
}
inline const ::Guidance::AxesCamController::Messages::Config& SetMode::cam_config_override(int index) const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.SetMode.cam_config_override)
  return cam_config_override_.Get(index);
}
inline ::Guidance::AxesCamController::Messages::Config* SetMode::add_cam_config_override() {
  // @@protoc_insertion_point(field_add:Guidance.Messages.SetMode.cam_config_override)
  return cam_config_override_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Guidance::AxesCamController::Messages::Config >&
SetMode::cam_config_override() const {
  // @@protoc_insertion_point(field_list:Guidance.Messages.SetMode.cam_config_override)
  return cam_config_override_;
}

// -------------------------------------------------------------------

// Pcmd

// float roll = 1;
inline void Pcmd::clear_roll() {
  roll_ = 0;
}
inline float Pcmd::roll() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Pcmd.roll)
  return roll_;
}
inline void Pcmd::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Pcmd.roll)
}

// float pitch = 2;
inline void Pcmd::clear_pitch() {
  pitch_ = 0;
}
inline float Pcmd::pitch() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Pcmd.pitch)
  return pitch_;
}
inline void Pcmd::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Pcmd.pitch)
}

// float yaw = 3;
inline void Pcmd::clear_yaw() {
  yaw_ = 0;
}
inline float Pcmd::yaw() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Pcmd.yaw)
  return yaw_;
}
inline void Pcmd::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Pcmd.yaw)
}

// float vertical = 4;
inline void Pcmd::clear_vertical() {
  vertical_ = 0;
}
inline float Pcmd::vertical() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Pcmd.vertical)
  return vertical_;
}
inline void Pcmd::set_vertical(float value) {
  
  vertical_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Pcmd.vertical)
}

// bool gotofix = 5;
inline void Pcmd::clear_gotofix() {
  gotofix_ = false;
}
inline bool Pcmd::gotofix() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Pcmd.gotofix)
  return gotofix_;
}
inline void Pcmd::set_gotofix(bool value) {
  
  gotofix_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Pcmd.gotofix)
}

// uint32 seqnum = 6;
inline void Pcmd::clear_seqnum() {
  seqnum_ = 0u;
}
inline ::google::protobuf::uint32 Pcmd::seqnum() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Pcmd.seqnum)
  return seqnum_;
}
inline void Pcmd::set_seqnum(::google::protobuf::uint32 value) {
  
  seqnum_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Pcmd.seqnum)
}

// uint32 ts = 7;
inline void Pcmd::clear_ts() {
  ts_ = 0u;
}
inline ::google::protobuf::uint32 Pcmd::ts() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Pcmd.ts)
  return ts_;
}
inline void Pcmd::set_ts(::google::protobuf::uint32 value) {
  
  ts_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Pcmd.ts)
}

// -------------------------------------------------------------------

// GeofenceCenter

// float latitude = 1;
inline void GeofenceCenter::clear_latitude() {
  latitude_ = 0;
}
inline float GeofenceCenter::latitude() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.GeofenceCenter.latitude)
  return latitude_;
}
inline void GeofenceCenter::set_latitude(float value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.GeofenceCenter.latitude)
}

// float longitude = 2;
inline void GeofenceCenter::clear_longitude() {
  longitude_ = 0;
}
inline float GeofenceCenter::longitude() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.GeofenceCenter.longitude)
  return longitude_;
}
inline void GeofenceCenter::set_longitude(float value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.GeofenceCenter.longitude)
}

// -------------------------------------------------------------------

// ModeChanged

// bool ok = 1;
inline void ModeChanged::clear_ok() {
  ok_ = false;
}
inline bool ModeChanged::ok() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.ModeChanged.ok)
  return ok_;
}
inline void ModeChanged::set_ok(bool value) {
  
  ok_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.ModeChanged.ok)
}

// string mode = 2;
inline void ModeChanged::clear_mode() {
  mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModeChanged::mode() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.ModeChanged.mode)
  return mode_.GetNoArena();
}
inline void ModeChanged::set_mode(const ::std::string& value) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Guidance.Messages.ModeChanged.mode)
}
#if LANG_CXX11
inline void ModeChanged::set_mode(::std::string&& value) {
  
  mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Guidance.Messages.ModeChanged.mode)
}
#endif
inline void ModeChanged::set_mode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Guidance.Messages.ModeChanged.mode)
}
inline void ModeChanged::set_mode(const char* value, size_t size) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Guidance.Messages.ModeChanged.mode)
}
inline ::std::string* ModeChanged::mutable_mode() {
  
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.ModeChanged.mode)
  return mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModeChanged::release_mode() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.ModeChanged.mode)
  
  return mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModeChanged::set_allocated_mode(::std::string* mode) {
  if (mode != nullptr) {
    
  } else {
    
  }
  mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mode);
  // @@protoc_insertion_point(field_set_allocated:Guidance.Messages.ModeChanged.mode)
}

// bool obstacle_avoidance_available = 3;
inline void ModeChanged::clear_obstacle_avoidance_available() {
  obstacle_avoidance_available_ = false;
}
inline bool ModeChanged::obstacle_avoidance_available() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.ModeChanged.obstacle_avoidance_available)
  return obstacle_avoidance_available_;
}
inline void ModeChanged::set_obstacle_avoidance_available(bool value) {
  
  obstacle_avoidance_available_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.ModeChanged.obstacle_avoidance_available)
}

// bool geofence_available = 4;
inline void ModeChanged::clear_geofence_available() {
  geofence_available_ = false;
}
inline bool ModeChanged::geofence_available() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.ModeChanged.geofence_available)
  return geofence_available_;
}
inline void ModeChanged::set_geofence_available(bool value) {
  
  geofence_available_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.ModeChanged.geofence_available)
}

// -------------------------------------------------------------------

// Mission

// string uid = 1;
inline void Mission::clear_uid() {
  uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mission::uid() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Mission.uid)
  return uid_.GetNoArena();
}
inline void Mission::set_uid(const ::std::string& value) {
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Guidance.Messages.Mission.uid)
}
#if LANG_CXX11
inline void Mission::set_uid(::std::string&& value) {
  
  uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Guidance.Messages.Mission.uid)
}
#endif
inline void Mission::set_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Guidance.Messages.Mission.uid)
}
inline void Mission::set_uid(const char* value, size_t size) {
  
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Guidance.Messages.Mission.uid)
}
inline ::std::string* Mission::mutable_uid() {
  
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Mission.uid)
  return uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mission::release_uid() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Mission.uid)
  
  return uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mission::set_allocated_uid(::std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid);
  // @@protoc_insertion_point(field_set_allocated:Guidance.Messages.Mission.uid)
}

// -------------------------------------------------------------------

// Command

// .Guidance.Messages.SetMode set_mode = 1;
inline bool Command::has_set_mode() const {
  return id_case() == kSetMode;
}
inline void Command::set_has_set_mode() {
  _oneof_case_[0] = kSetMode;
}
inline void Command::clear_set_mode() {
  if (has_set_mode()) {
    delete id_.set_mode_;
    clear_has_id();
  }
}
inline ::Guidance::Messages::SetMode* Command::release_set_mode() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Command.set_mode)
  if (has_set_mode()) {
    clear_has_id();
      ::Guidance::Messages::SetMode* temp = id_.set_mode_;
    id_.set_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::Messages::SetMode& Command::set_mode() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Command.set_mode)
  return has_set_mode()
      ? *id_.set_mode_
      : *reinterpret_cast< ::Guidance::Messages::SetMode*>(&::Guidance::Messages::_SetMode_default_instance_);
}
inline ::Guidance::Messages::SetMode* Command::mutable_set_mode() {
  if (!has_set_mode()) {
    clear_id();
    set_has_set_mode();
    id_.set_mode_ = CreateMaybeMessage< ::Guidance::Messages::SetMode >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Command.set_mode)
  return id_.set_mode_;
}

// .Guidance.Messages.Pcmd set_pcmd = 2;
inline bool Command::has_set_pcmd() const {
  return id_case() == kSetPcmd;
}
inline void Command::set_has_set_pcmd() {
  _oneof_case_[0] = kSetPcmd;
}
inline void Command::clear_set_pcmd() {
  if (has_set_pcmd()) {
    delete id_.set_pcmd_;
    clear_has_id();
  }
}
inline ::Guidance::Messages::Pcmd* Command::release_set_pcmd() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Command.set_pcmd)
  if (has_set_pcmd()) {
    clear_has_id();
      ::Guidance::Messages::Pcmd* temp = id_.set_pcmd_;
    id_.set_pcmd_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::Messages::Pcmd& Command::set_pcmd() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Command.set_pcmd)
  return has_set_pcmd()
      ? *id_.set_pcmd_
      : *reinterpret_cast< ::Guidance::Messages::Pcmd*>(&::Guidance::Messages::_Pcmd_default_instance_);
}
inline ::Guidance::Messages::Pcmd* Command::mutable_set_pcmd() {
  if (!has_set_pcmd()) {
    clear_id();
    set_has_set_pcmd();
    id_.set_pcmd_ = CreateMaybeMessage< ::Guidance::Messages::Pcmd >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Command.set_pcmd)
  return id_.set_pcmd_;
}

// .Guidance.Messages.Mission load_mission = 10;
inline bool Command::has_load_mission() const {
  return id_case() == kLoadMission;
}
inline void Command::set_has_load_mission() {
  _oneof_case_[0] = kLoadMission;
}
inline void Command::clear_load_mission() {
  if (has_load_mission()) {
    delete id_.load_mission_;
    clear_has_id();
  }
}
inline ::Guidance::Messages::Mission* Command::release_load_mission() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Command.load_mission)
  if (has_load_mission()) {
    clear_has_id();
      ::Guidance::Messages::Mission* temp = id_.load_mission_;
    id_.load_mission_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::Messages::Mission& Command::load_mission() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Command.load_mission)
  return has_load_mission()
      ? *id_.load_mission_
      : *reinterpret_cast< ::Guidance::Messages::Mission*>(&::Guidance::Messages::_Mission_default_instance_);
}
inline ::Guidance::Messages::Mission* Command::mutable_load_mission() {
  if (!has_load_mission()) {
    clear_id();
    set_has_load_mission();
    id_.load_mission_ = CreateMaybeMessage< ::Guidance::Messages::Mission >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Command.load_mission)
  return id_.load_mission_;
}

// .Guidance.Messages.Mission unload_mission = 11;
inline bool Command::has_unload_mission() const {
  return id_case() == kUnloadMission;
}
inline void Command::set_has_unload_mission() {
  _oneof_case_[0] = kUnloadMission;
}
inline void Command::clear_unload_mission() {
  if (has_unload_mission()) {
    delete id_.unload_mission_;
    clear_has_id();
  }
}
inline ::Guidance::Messages::Mission* Command::release_unload_mission() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Command.unload_mission)
  if (has_unload_mission()) {
    clear_has_id();
      ::Guidance::Messages::Mission* temp = id_.unload_mission_;
    id_.unload_mission_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::Messages::Mission& Command::unload_mission() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Command.unload_mission)
  return has_unload_mission()
      ? *id_.unload_mission_
      : *reinterpret_cast< ::Guidance::Messages::Mission*>(&::Guidance::Messages::_Mission_default_instance_);
}
inline ::Guidance::Messages::Mission* Command::mutable_unload_mission() {
  if (!has_unload_mission()) {
    clear_id();
    set_has_unload_mission();
    id_.unload_mission_ = CreateMaybeMessage< ::Guidance::Messages::Mission >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Command.unload_mission)
  return id_.unload_mission_;
}

// bool set_obstacle_avoidance = 30;
inline bool Command::has_set_obstacle_avoidance() const {
  return id_case() == kSetObstacleAvoidance;
}
inline void Command::set_has_set_obstacle_avoidance() {
  _oneof_case_[0] = kSetObstacleAvoidance;
}
inline void Command::clear_set_obstacle_avoidance() {
  if (has_set_obstacle_avoidance()) {
    id_.set_obstacle_avoidance_ = false;
    clear_has_id();
  }
}
inline bool Command::set_obstacle_avoidance() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Command.set_obstacle_avoidance)
  if (has_set_obstacle_avoidance()) {
    return id_.set_obstacle_avoidance_;
  }
  return false;
}
inline void Command::set_set_obstacle_avoidance(bool value) {
  if (!has_set_obstacle_avoidance()) {
    clear_id();
    set_has_set_obstacle_avoidance();
  }
  id_.set_obstacle_avoidance_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Command.set_obstacle_avoidance)
}

// bool set_geofence = 40;
inline bool Command::has_set_geofence() const {
  return id_case() == kSetGeofence;
}
inline void Command::set_has_set_geofence() {
  _oneof_case_[0] = kSetGeofence;
}
inline void Command::clear_set_geofence() {
  if (has_set_geofence()) {
    id_.set_geofence_ = false;
    clear_has_id();
  }
}
inline bool Command::set_geofence() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Command.set_geofence)
  if (has_set_geofence()) {
    return id_.set_geofence_;
  }
  return false;
}
inline void Command::set_set_geofence(bool value) {
  if (!has_set_geofence()) {
    clear_id();
    set_has_set_geofence();
  }
  id_.set_geofence_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Command.set_geofence)
}

// .Guidance.Messages.GeofenceCenter set_geofence_center = 41;
inline bool Command::has_set_geofence_center() const {
  return id_case() == kSetGeofenceCenter;
}
inline void Command::set_has_set_geofence_center() {
  _oneof_case_[0] = kSetGeofenceCenter;
}
inline void Command::clear_set_geofence_center() {
  if (has_set_geofence_center()) {
    delete id_.set_geofence_center_;
    clear_has_id();
  }
}
inline ::Guidance::Messages::GeofenceCenter* Command::release_set_geofence_center() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Command.set_geofence_center)
  if (has_set_geofence_center()) {
    clear_has_id();
      ::Guidance::Messages::GeofenceCenter* temp = id_.set_geofence_center_;
    id_.set_geofence_center_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::Messages::GeofenceCenter& Command::set_geofence_center() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Command.set_geofence_center)
  return has_set_geofence_center()
      ? *id_.set_geofence_center_
      : *reinterpret_cast< ::Guidance::Messages::GeofenceCenter*>(&::Guidance::Messages::_GeofenceCenter_default_instance_);
}
inline ::Guidance::Messages::GeofenceCenter* Command::mutable_set_geofence_center() {
  if (!has_set_geofence_center()) {
    clear_id();
    set_has_set_geofence_center();
    id_.set_geofence_center_ = CreateMaybeMessage< ::Guidance::Messages::GeofenceCenter >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Command.set_geofence_center)
  return id_.set_geofence_center_;
}

inline bool Command::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void Command::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline Command::IdCase Command::id_case() const {
  return Command::IdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ModeList

// repeated string loaded_modes = 1;
inline int ModeList::loaded_modes_size() const {
  return loaded_modes_.size();
}
inline void ModeList::clear_loaded_modes() {
  loaded_modes_.Clear();
}
inline const ::std::string& ModeList::loaded_modes(int index) const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.ModeList.loaded_modes)
  return loaded_modes_.Get(index);
}
inline ::std::string* ModeList::mutable_loaded_modes(int index) {
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.ModeList.loaded_modes)
  return loaded_modes_.Mutable(index);
}
inline void ModeList::set_loaded_modes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Guidance.Messages.ModeList.loaded_modes)
  loaded_modes_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ModeList::set_loaded_modes(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Guidance.Messages.ModeList.loaded_modes)
  loaded_modes_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ModeList::set_loaded_modes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  loaded_modes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Guidance.Messages.ModeList.loaded_modes)
}
inline void ModeList::set_loaded_modes(int index, const char* value, size_t size) {
  loaded_modes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Guidance.Messages.ModeList.loaded_modes)
}
inline ::std::string* ModeList::add_loaded_modes() {
  // @@protoc_insertion_point(field_add_mutable:Guidance.Messages.ModeList.loaded_modes)
  return loaded_modes_.Add();
}
inline void ModeList::add_loaded_modes(const ::std::string& value) {
  loaded_modes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Guidance.Messages.ModeList.loaded_modes)
}
#if LANG_CXX11
inline void ModeList::add_loaded_modes(::std::string&& value) {
  loaded_modes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Guidance.Messages.ModeList.loaded_modes)
}
#endif
inline void ModeList::add_loaded_modes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  loaded_modes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Guidance.Messages.ModeList.loaded_modes)
}
inline void ModeList::add_loaded_modes(const char* value, size_t size) {
  loaded_modes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Guidance.Messages.ModeList.loaded_modes)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ModeList::loaded_modes() const {
  // @@protoc_insertion_point(field_list:Guidance.Messages.ModeList.loaded_modes)
  return loaded_modes_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
ModeList::mutable_loaded_modes() {
  // @@protoc_insertion_point(field_mutable_list:Guidance.Messages.ModeList.loaded_modes)
  return &loaded_modes_;
}

// -------------------------------------------------------------------

// Error

// string message = 1;
inline void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Error.message)
  return message_.GetNoArena();
}
inline void Error::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Guidance.Messages.Error.message)
}
#if LANG_CXX11
inline void Error::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Guidance.Messages.Error.message)
}
#endif
inline void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Guidance.Messages.Error.message)
}
inline void Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Guidance.Messages.Error.message)
}
inline ::std::string* Error::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Error.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:Guidance.Messages.Error.message)
}

// string mode = 2;
inline void Error::clear_mode() {
  mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::mode() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Error.mode)
  return mode_.GetNoArena();
}
inline void Error::set_mode(const ::std::string& value) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Guidance.Messages.Error.mode)
}
#if LANG_CXX11
inline void Error::set_mode(::std::string&& value) {
  
  mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Guidance.Messages.Error.mode)
}
#endif
inline void Error::set_mode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Guidance.Messages.Error.mode)
}
inline void Error::set_mode(const char* value, size_t size) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Guidance.Messages.Error.mode)
}
inline ::std::string* Error::mutable_mode() {
  
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Error.mode)
  return mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_mode() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Error.mode)
  
  return mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_mode(::std::string* mode) {
  if (mode != nullptr) {
    
  } else {
    
  }
  mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mode);
  // @@protoc_insertion_point(field_set_allocated:Guidance.Messages.Error.mode)
}

// -------------------------------------------------------------------

// Event

// .Guidance.Messages.ModeList init_ok = 1;
inline bool Event::has_init_ok() const {
  return id_case() == kInitOk;
}
inline void Event::set_has_init_ok() {
  _oneof_case_[0] = kInitOk;
}
inline void Event::clear_init_ok() {
  if (has_init_ok()) {
    delete id_.init_ok_;
    clear_has_id();
  }
}
inline ::Guidance::Messages::ModeList* Event::release_init_ok() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Event.init_ok)
  if (has_init_ok()) {
    clear_has_id();
      ::Guidance::Messages::ModeList* temp = id_.init_ok_;
    id_.init_ok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::Messages::ModeList& Event::init_ok() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Event.init_ok)
  return has_init_ok()
      ? *id_.init_ok_
      : *reinterpret_cast< ::Guidance::Messages::ModeList*>(&::Guidance::Messages::_ModeList_default_instance_);
}
inline ::Guidance::Messages::ModeList* Event::mutable_init_ok() {
  if (!has_init_ok()) {
    clear_id();
    set_has_init_ok();
    id_.init_ok_ = CreateMaybeMessage< ::Guidance::Messages::ModeList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Event.init_ok)
  return id_.init_ok_;
}

// .Guidance.Messages.ModeChanged mode_changed = 2;
inline bool Event::has_mode_changed() const {
  return id_case() == kModeChanged;
}
inline void Event::set_has_mode_changed() {
  _oneof_case_[0] = kModeChanged;
}
inline void Event::clear_mode_changed() {
  if (has_mode_changed()) {
    delete id_.mode_changed_;
    clear_has_id();
  }
}
inline ::Guidance::Messages::ModeChanged* Event::release_mode_changed() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Event.mode_changed)
  if (has_mode_changed()) {
    clear_has_id();
      ::Guidance::Messages::ModeChanged* temp = id_.mode_changed_;
    id_.mode_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::Messages::ModeChanged& Event::mode_changed() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Event.mode_changed)
  return has_mode_changed()
      ? *id_.mode_changed_
      : *reinterpret_cast< ::Guidance::Messages::ModeChanged*>(&::Guidance::Messages::_ModeChanged_default_instance_);
}
inline ::Guidance::Messages::ModeChanged* Event::mutable_mode_changed() {
  if (!has_mode_changed()) {
    clear_id();
    set_has_mode_changed();
    id_.mode_changed_ = CreateMaybeMessage< ::Guidance::Messages::ModeChanged >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Event.mode_changed)
  return id_.mode_changed_;
}

// .Guidance.Messages.Error error = 3;
inline bool Event::has_error() const {
  return id_case() == kError;
}
inline void Event::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void Event::clear_error() {
  if (has_error()) {
    delete id_.error_;
    clear_has_id();
  }
}
inline ::Guidance::Messages::Error* Event::release_error() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Event.error)
  if (has_error()) {
    clear_has_id();
      ::Guidance::Messages::Error* temp = id_.error_;
    id_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::Messages::Error& Event::error() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Event.error)
  return has_error()
      ? *id_.error_
      : *reinterpret_cast< ::Guidance::Messages::Error*>(&::Guidance::Messages::_Error_default_instance_);
}
inline ::Guidance::Messages::Error* Event::mutable_error() {
  if (!has_error()) {
    clear_id();
    set_has_error();
    id_.error_ = CreateMaybeMessage< ::Guidance::Messages::Error >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Event.error)
  return id_.error_;
}

// .Guidance.Messages.ModeList mode_list_changed = 4;
inline bool Event::has_mode_list_changed() const {
  return id_case() == kModeListChanged;
}
inline void Event::set_has_mode_list_changed() {
  _oneof_case_[0] = kModeListChanged;
}
inline void Event::clear_mode_list_changed() {
  if (has_mode_list_changed()) {
    delete id_.mode_list_changed_;
    clear_has_id();
  }
}
inline ::Guidance::Messages::ModeList* Event::release_mode_list_changed() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Event.mode_list_changed)
  if (has_mode_list_changed()) {
    clear_has_id();
      ::Guidance::Messages::ModeList* temp = id_.mode_list_changed_;
    id_.mode_list_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::Messages::ModeList& Event::mode_list_changed() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Event.mode_list_changed)
  return has_mode_list_changed()
      ? *id_.mode_list_changed_
      : *reinterpret_cast< ::Guidance::Messages::ModeList*>(&::Guidance::Messages::_ModeList_default_instance_);
}
inline ::Guidance::Messages::ModeList* Event::mutable_mode_list_changed() {
  if (!has_mode_list_changed()) {
    clear_id();
    set_has_mode_list_changed();
    id_.mode_list_changed_ = CreateMaybeMessage< ::Guidance::Messages::ModeList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Event.mode_list_changed)
  return id_.mode_list_changed_;
}

// bool high_trajectory_deviation = 30;
inline bool Event::has_high_trajectory_deviation() const {
  return id_case() == kHighTrajectoryDeviation;
}
inline void Event::set_has_high_trajectory_deviation() {
  _oneof_case_[0] = kHighTrajectoryDeviation;
}
inline void Event::clear_high_trajectory_deviation() {
  if (has_high_trajectory_deviation()) {
    id_.high_trajectory_deviation_ = false;
    clear_has_id();
  }
}
inline bool Event::high_trajectory_deviation() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Event.high_trajectory_deviation)
  if (has_high_trajectory_deviation()) {
    return id_.high_trajectory_deviation_;
  }
  return false;
}
inline void Event::set_high_trajectory_deviation(bool value) {
  if (!has_high_trajectory_deviation()) {
    clear_id();
    set_has_high_trajectory_deviation();
  }
  id_.high_trajectory_deviation_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Event.high_trajectory_deviation)
}

// bool obstacle_avoidance_stuck = 31;
inline bool Event::has_obstacle_avoidance_stuck() const {
  return id_case() == kObstacleAvoidanceStuck;
}
inline void Event::set_has_obstacle_avoidance_stuck() {
  _oneof_case_[0] = kObstacleAvoidanceStuck;
}
inline void Event::clear_obstacle_avoidance_stuck() {
  if (has_obstacle_avoidance_stuck()) {
    id_.obstacle_avoidance_stuck_ = false;
    clear_has_id();
  }
}
inline bool Event::obstacle_avoidance_stuck() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Event.obstacle_avoidance_stuck)
  if (has_obstacle_avoidance_stuck()) {
    return id_.obstacle_avoidance_stuck_;
  }
  return false;
}
inline void Event::set_obstacle_avoidance_stuck(bool value) {
  if (!has_obstacle_avoidance_stuck()) {
    clear_id();
    set_has_obstacle_avoidance_stuck();
  }
  id_.obstacle_avoidance_stuck_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Event.obstacle_avoidance_stuck)
}

// bool obstacle_avoidance_failure = 32;
inline bool Event::has_obstacle_avoidance_failure() const {
  return id_case() == kObstacleAvoidanceFailure;
}
inline void Event::set_has_obstacle_avoidance_failure() {
  _oneof_case_[0] = kObstacleAvoidanceFailure;
}
inline void Event::clear_obstacle_avoidance_failure() {
  if (has_obstacle_avoidance_failure()) {
    id_.obstacle_avoidance_failure_ = false;
    clear_has_id();
  }
}
inline bool Event::obstacle_avoidance_failure() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Event.obstacle_avoidance_failure)
  if (has_obstacle_avoidance_failure()) {
    return id_.obstacle_avoidance_failure_;
  }
  return false;
}
inline void Event::set_obstacle_avoidance_failure(bool value) {
  if (!has_obstacle_avoidance_failure()) {
    clear_id();
    set_has_obstacle_avoidance_failure();
  }
  id_.obstacle_avoidance_failure_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Event.obstacle_avoidance_failure)
}

// bool obstacle_avoidance_blind_motion_direction = 33;
inline bool Event::has_obstacle_avoidance_blind_motion_direction() const {
  return id_case() == kObstacleAvoidanceBlindMotionDirection;
}
inline void Event::set_has_obstacle_avoidance_blind_motion_direction() {
  _oneof_case_[0] = kObstacleAvoidanceBlindMotionDirection;
}
inline void Event::clear_obstacle_avoidance_blind_motion_direction() {
  if (has_obstacle_avoidance_blind_motion_direction()) {
    id_.obstacle_avoidance_blind_motion_direction_ = false;
    clear_has_id();
  }
}
inline bool Event::obstacle_avoidance_blind_motion_direction() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Event.obstacle_avoidance_blind_motion_direction)
  if (has_obstacle_avoidance_blind_motion_direction()) {
    return id_.obstacle_avoidance_blind_motion_direction_;
  }
  return false;
}
inline void Event::set_obstacle_avoidance_blind_motion_direction(bool value) {
  if (!has_obstacle_avoidance_blind_motion_direction()) {
    clear_id();
    set_has_obstacle_avoidance_blind_motion_direction();
  }
  id_.obstacle_avoidance_blind_motion_direction_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Event.obstacle_avoidance_blind_motion_direction)
}

// .google.protobuf.Empty gotofix_done = 40;
inline bool Event::has_gotofix_done() const {
  return id_case() == kGotofixDone;
}
inline void Event::set_has_gotofix_done() {
  _oneof_case_[0] = kGotofixDone;
}
inline ::google::protobuf::Empty* Event::release_gotofix_done() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Event.gotofix_done)
  if (has_gotofix_done()) {
    clear_has_id();
      ::google::protobuf::Empty* temp = id_.gotofix_done_;
    id_.gotofix_done_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Empty& Event::gotofix_done() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Event.gotofix_done)
  return has_gotofix_done()
      ? *id_.gotofix_done_
      : *reinterpret_cast< ::google::protobuf::Empty*>(&::google::protobuf::_Empty_default_instance_);
}
inline ::google::protobuf::Empty* Event::mutable_gotofix_done() {
  if (!has_gotofix_done()) {
    clear_id();
    set_has_gotofix_done();
    id_.gotofix_done_ = CreateMaybeMessage< ::google::protobuf::Empty >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Event.gotofix_done)
  return id_.gotofix_done_;
}

// .google.protobuf.Empty gotofreeze_done = 41;
inline bool Event::has_gotofreeze_done() const {
  return id_case() == kGotofreezeDone;
}
inline void Event::set_has_gotofreeze_done() {
  _oneof_case_[0] = kGotofreezeDone;
}
inline ::google::protobuf::Empty* Event::release_gotofreeze_done() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Event.gotofreeze_done)
  if (has_gotofreeze_done()) {
    clear_has_id();
      ::google::protobuf::Empty* temp = id_.gotofreeze_done_;
    id_.gotofreeze_done_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Empty& Event::gotofreeze_done() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Event.gotofreeze_done)
  return has_gotofreeze_done()
      ? *id_.gotofreeze_done_
      : *reinterpret_cast< ::google::protobuf::Empty*>(&::google::protobuf::_Empty_default_instance_);
}
inline ::google::protobuf::Empty* Event::mutable_gotofreeze_done() {
  if (!has_gotofreeze_done()) {
    clear_id();
    set_has_gotofreeze_done();
    id_.gotofreeze_done_ = CreateMaybeMessage< ::google::protobuf::Empty >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Event.gotofreeze_done)
  return id_.gotofreeze_done_;
}

// bool horizontal_geofence_reached = 100;
inline bool Event::has_horizontal_geofence_reached() const {
  return id_case() == kHorizontalGeofenceReached;
}
inline void Event::set_has_horizontal_geofence_reached() {
  _oneof_case_[0] = kHorizontalGeofenceReached;
}
inline void Event::clear_horizontal_geofence_reached() {
  if (has_horizontal_geofence_reached()) {
    id_.horizontal_geofence_reached_ = false;
    clear_has_id();
  }
}
inline bool Event::horizontal_geofence_reached() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Event.horizontal_geofence_reached)
  if (has_horizontal_geofence_reached()) {
    return id_.horizontal_geofence_reached_;
  }
  return false;
}
inline void Event::set_horizontal_geofence_reached(bool value) {
  if (!has_horizontal_geofence_reached()) {
    clear_id();
    set_has_horizontal_geofence_reached();
  }
  id_.horizontal_geofence_reached_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Event.horizontal_geofence_reached)
}

// bool vertical_geofence_reached = 101;
inline bool Event::has_vertical_geofence_reached() const {
  return id_case() == kVerticalGeofenceReached;
}
inline void Event::set_has_vertical_geofence_reached() {
  _oneof_case_[0] = kVerticalGeofenceReached;
}
inline void Event::clear_vertical_geofence_reached() {
  if (has_vertical_geofence_reached()) {
    id_.vertical_geofence_reached_ = false;
    clear_has_id();
  }
}
inline bool Event::vertical_geofence_reached() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Event.vertical_geofence_reached)
  if (has_vertical_geofence_reached()) {
    return id_.vertical_geofence_reached_;
  }
  return false;
}
inline void Event::set_vertical_geofence_reached(bool value) {
  if (!has_vertical_geofence_reached()) {
    clear_id();
    set_has_vertical_geofence_reached();
  }
  id_.vertical_geofence_reached_ = value;
  // @@protoc_insertion_point(field_set:Guidance.Messages.Event.vertical_geofence_reached)
}

// .Guidance.Messages.GeofenceCenter geofence_center_changed = 102;
inline bool Event::has_geofence_center_changed() const {
  return id_case() == kGeofenceCenterChanged;
}
inline void Event::set_has_geofence_center_changed() {
  _oneof_case_[0] = kGeofenceCenterChanged;
}
inline void Event::clear_geofence_center_changed() {
  if (has_geofence_center_changed()) {
    delete id_.geofence_center_changed_;
    clear_has_id();
  }
}
inline ::Guidance::Messages::GeofenceCenter* Event::release_geofence_center_changed() {
  // @@protoc_insertion_point(field_release:Guidance.Messages.Event.geofence_center_changed)
  if (has_geofence_center_changed()) {
    clear_has_id();
      ::Guidance::Messages::GeofenceCenter* temp = id_.geofence_center_changed_;
    id_.geofence_center_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Guidance::Messages::GeofenceCenter& Event::geofence_center_changed() const {
  // @@protoc_insertion_point(field_get:Guidance.Messages.Event.geofence_center_changed)
  return has_geofence_center_changed()
      ? *id_.geofence_center_changed_
      : *reinterpret_cast< ::Guidance::Messages::GeofenceCenter*>(&::Guidance::Messages::_GeofenceCenter_default_instance_);
}
inline ::Guidance::Messages::GeofenceCenter* Event::mutable_geofence_center_changed() {
  if (!has_geofence_center_changed()) {
    clear_id();
    set_has_geofence_center_changed();
    id_.geofence_center_changed_ = CreateMaybeMessage< ::Guidance::Messages::GeofenceCenter >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Guidance.Messages.Event.geofence_center_changed)
  return id_.geofence_center_changed_;
}

inline bool Event::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void Event::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline Event::IdCase Event::id_case() const {
  return Event::IdCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Messages
}  // namespace Guidance

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_guidance_2fguidance_2eproto
