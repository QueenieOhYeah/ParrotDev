// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: axes_cam_controller/axes_cam_controller.proto

#ifndef PROTOBUF_INCLUDED_axes_5fcam_5fcontroller_2faxes_5fcam_5fcontroller_2eproto
#define PROTOBUF_INCLUDED_axes_5fcam_5fcontroller_2faxes_5fcam_5fcontroller_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "cam_controller/cam_controller.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_axes_5fcam_5fcontroller_2faxes_5fcam_5fcontroller_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_axes_5fcam_5fcontroller_2faxes_5fcam_5fcontroller_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_axes_5fcam_5fcontroller_2faxes_5fcam_5fcontroller_2eproto();
namespace AxesCamController {
namespace Messages {
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class Reference;
class ReferenceDefaultTypeInternal;
extern ReferenceDefaultTypeInternal _Reference_default_instance_;
class ReferenceStatus;
class ReferenceStatusDefaultTypeInternal;
extern ReferenceStatusDefaultTypeInternal _ReferenceStatus_default_instance_;
}  // namespace Messages
}  // namespace AxesCamController
namespace google {
namespace protobuf {
template<> ::AxesCamController::Messages::Command* Arena::CreateMaybeMessage<::AxesCamController::Messages::Command>(Arena*);
template<> ::AxesCamController::Messages::Config* Arena::CreateMaybeMessage<::AxesCamController::Messages::Config>(Arena*);
template<> ::AxesCamController::Messages::Reference* Arena::CreateMaybeMessage<::AxesCamController::Messages::Reference>(Arena*);
template<> ::AxesCamController::Messages::ReferenceStatus* Arena::CreateMaybeMessage<::AxesCamController::Messages::ReferenceStatus>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace AxesCamController {
namespace Messages {

// ===================================================================

class Config :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AxesCamController.Messages.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Config* other);
  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const final {
    return CreateMaybeMessage<Config>(nullptr);
  }

  Config* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CamController.Messages.AxisConfig yaw = 1;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 1;
  const ::CamController::Messages::AxisConfig& yaw() const;
  ::CamController::Messages::AxisConfig* release_yaw();
  ::CamController::Messages::AxisConfig* mutable_yaw();
  void set_allocated_yaw(::CamController::Messages::AxisConfig* yaw);

  // .CamController.Messages.AxisConfig pitch = 2;
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  const ::CamController::Messages::AxisConfig& pitch() const;
  ::CamController::Messages::AxisConfig* release_pitch();
  ::CamController::Messages::AxisConfig* mutable_pitch();
  void set_allocated_pitch(::CamController::Messages::AxisConfig* pitch);

  // .CamController.Messages.AxisConfig roll = 3;
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 3;
  const ::CamController::Messages::AxisConfig& roll() const;
  ::CamController::Messages::AxisConfig* release_roll();
  ::CamController::Messages::AxisConfig* mutable_roll();
  void set_allocated_roll(::CamController::Messages::AxisConfig* roll);

  // @@protoc_insertion_point(class_scope:AxesCamController.Messages.Config)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CamController::Messages::AxisConfig* yaw_;
  ::CamController::Messages::AxisConfig* pitch_;
  ::CamController::Messages::AxisConfig* roll_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_axes_5fcam_5fcontroller_2faxes_5fcam_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class Reference :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AxesCamController.Messages.Reference) */ {
 public:
  Reference();
  virtual ~Reference();

  Reference(const Reference& from);

  inline Reference& operator=(const Reference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Reference(Reference&& from) noexcept
    : Reference() {
    *this = ::std::move(from);
  }

  inline Reference& operator=(Reference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Reference& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reference* internal_default_instance() {
    return reinterpret_cast<const Reference*>(
               &_Reference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Reference* other);
  friend void swap(Reference& a, Reference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Reference* New() const final {
    return CreateMaybeMessage<Reference>(nullptr);
  }

  Reference* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Reference>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Reference& from);
  void MergeFrom(const Reference& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CamController.Messages.AxisReference yaw = 1;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 1;
  const ::CamController::Messages::AxisReference& yaw() const;
  ::CamController::Messages::AxisReference* release_yaw();
  ::CamController::Messages::AxisReference* mutable_yaw();
  void set_allocated_yaw(::CamController::Messages::AxisReference* yaw);

  // .CamController.Messages.AxisReference pitch = 2;
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  const ::CamController::Messages::AxisReference& pitch() const;
  ::CamController::Messages::AxisReference* release_pitch();
  ::CamController::Messages::AxisReference* mutable_pitch();
  void set_allocated_pitch(::CamController::Messages::AxisReference* pitch);

  // .CamController.Messages.AxisReference roll = 3;
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 3;
  const ::CamController::Messages::AxisReference& roll() const;
  ::CamController::Messages::AxisReference* release_roll();
  ::CamController::Messages::AxisReference* mutable_roll();
  void set_allocated_roll(::CamController::Messages::AxisReference* roll);

  // @@protoc_insertion_point(class_scope:AxesCamController.Messages.Reference)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CamController::Messages::AxisReference* yaw_;
  ::CamController::Messages::AxisReference* pitch_;
  ::CamController::Messages::AxisReference* roll_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_axes_5fcam_5fcontroller_2faxes_5fcam_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class ReferenceStatus :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AxesCamController.Messages.ReferenceStatus) */ {
 public:
  ReferenceStatus();
  virtual ~ReferenceStatus();

  ReferenceStatus(const ReferenceStatus& from);

  inline ReferenceStatus& operator=(const ReferenceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReferenceStatus(ReferenceStatus&& from) noexcept
    : ReferenceStatus() {
    *this = ::std::move(from);
  }

  inline ReferenceStatus& operator=(ReferenceStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ReferenceStatus& default_instance();

  enum IdCase {
    kYaw = 1,
    kPitch = 2,
    kRoll = 3,
    ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReferenceStatus* internal_default_instance() {
    return reinterpret_cast<const ReferenceStatus*>(
               &_ReferenceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ReferenceStatus* other);
  friend void swap(ReferenceStatus& a, ReferenceStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReferenceStatus* New() const final {
    return CreateMaybeMessage<ReferenceStatus>(nullptr);
  }

  ReferenceStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReferenceStatus& from);
  void MergeFrom(const ReferenceStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CamController.Messages.ReferenceStatus.Enum yaw = 1;
  private:
  bool has_yaw() const;
  public:
  void clear_yaw();
  static const int kYawFieldNumber = 1;
  ::CamController::Messages::ReferenceStatus::Enum yaw() const;
  void set_yaw(::CamController::Messages::ReferenceStatus::Enum value);

  // .CamController.Messages.ReferenceStatus.Enum pitch = 2;
  private:
  bool has_pitch() const;
  public:
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  ::CamController::Messages::ReferenceStatus::Enum pitch() const;
  void set_pitch(::CamController::Messages::ReferenceStatus::Enum value);

  // .CamController.Messages.ReferenceStatus.Enum roll = 3;
  private:
  bool has_roll() const;
  public:
  void clear_roll();
  static const int kRollFieldNumber = 3;
  ::CamController::Messages::ReferenceStatus::Enum roll() const;
  void set_roll(::CamController::Messages::ReferenceStatus::Enum value);

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:AxesCamController.Messages.ReferenceStatus)
 private:
  class HasBitSetters;
  void set_has_yaw();
  void set_has_pitch();
  void set_has_roll();

  inline bool has_id() const;
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    int yaw_;
    int pitch_;
    int roll_;
  } id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_axes_5fcam_5fcontroller_2faxes_5fcam_5fcontroller_2eproto;
};
// -------------------------------------------------------------------

class Command :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AxesCamController.Messages.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Command& default_instance();

  enum IdCase {
    kSetConfig = 1,
    kSetReference = 2,
    ID_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .AxesCamController.Messages.Config set_config = 1;
  bool has_set_config() const;
  void clear_set_config();
  static const int kSetConfigFieldNumber = 1;
  const ::AxesCamController::Messages::Config& set_config() const;
  ::AxesCamController::Messages::Config* release_set_config();
  ::AxesCamController::Messages::Config* mutable_set_config();
  void set_allocated_set_config(::AxesCamController::Messages::Config* set_config);

  // .AxesCamController.Messages.Reference set_reference = 2;
  bool has_set_reference() const;
  void clear_set_reference();
  static const int kSetReferenceFieldNumber = 2;
  const ::AxesCamController::Messages::Reference& set_reference() const;
  ::AxesCamController::Messages::Reference* release_set_reference();
  ::AxesCamController::Messages::Reference* mutable_set_reference();
  void set_allocated_set_reference(::AxesCamController::Messages::Reference* set_reference);

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:AxesCamController.Messages.Command)
 private:
  class HasBitSetters;
  void set_has_set_config();
  void set_has_set_reference();

  inline bool has_id() const;
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdUnion {
    IdUnion() {}
    ::AxesCamController::Messages::Config* set_config_;
    ::AxesCamController::Messages::Reference* set_reference_;
  } id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_axes_5fcam_5fcontroller_2faxes_5fcam_5fcontroller_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Config

// .CamController.Messages.AxisConfig yaw = 1;
inline bool Config::has_yaw() const {
  return this != internal_default_instance() && yaw_ != nullptr;
}
inline const ::CamController::Messages::AxisConfig& Config::yaw() const {
  const ::CamController::Messages::AxisConfig* p = yaw_;
  // @@protoc_insertion_point(field_get:AxesCamController.Messages.Config.yaw)
  return p != nullptr ? *p : *reinterpret_cast<const ::CamController::Messages::AxisConfig*>(
      &::CamController::Messages::_AxisConfig_default_instance_);
}
inline ::CamController::Messages::AxisConfig* Config::release_yaw() {
  // @@protoc_insertion_point(field_release:AxesCamController.Messages.Config.yaw)
  
  ::CamController::Messages::AxisConfig* temp = yaw_;
  yaw_ = nullptr;
  return temp;
}
inline ::CamController::Messages::AxisConfig* Config::mutable_yaw() {
  
  if (yaw_ == nullptr) {
    auto* p = CreateMaybeMessage<::CamController::Messages::AxisConfig>(GetArenaNoVirtual());
    yaw_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AxesCamController.Messages.Config.yaw)
  return yaw_;
}
inline void Config::set_allocated_yaw(::CamController::Messages::AxisConfig* yaw) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(yaw_);
  }
  if (yaw) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      yaw = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yaw, submessage_arena);
    }
    
  } else {
    
  }
  yaw_ = yaw;
  // @@protoc_insertion_point(field_set_allocated:AxesCamController.Messages.Config.yaw)
}

// .CamController.Messages.AxisConfig pitch = 2;
inline bool Config::has_pitch() const {
  return this != internal_default_instance() && pitch_ != nullptr;
}
inline const ::CamController::Messages::AxisConfig& Config::pitch() const {
  const ::CamController::Messages::AxisConfig* p = pitch_;
  // @@protoc_insertion_point(field_get:AxesCamController.Messages.Config.pitch)
  return p != nullptr ? *p : *reinterpret_cast<const ::CamController::Messages::AxisConfig*>(
      &::CamController::Messages::_AxisConfig_default_instance_);
}
inline ::CamController::Messages::AxisConfig* Config::release_pitch() {
  // @@protoc_insertion_point(field_release:AxesCamController.Messages.Config.pitch)
  
  ::CamController::Messages::AxisConfig* temp = pitch_;
  pitch_ = nullptr;
  return temp;
}
inline ::CamController::Messages::AxisConfig* Config::mutable_pitch() {
  
  if (pitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::CamController::Messages::AxisConfig>(GetArenaNoVirtual());
    pitch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AxesCamController.Messages.Config.pitch)
  return pitch_;
}
inline void Config::set_allocated_pitch(::CamController::Messages::AxisConfig* pitch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pitch_);
  }
  if (pitch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pitch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pitch, submessage_arena);
    }
    
  } else {
    
  }
  pitch_ = pitch;
  // @@protoc_insertion_point(field_set_allocated:AxesCamController.Messages.Config.pitch)
}

// .CamController.Messages.AxisConfig roll = 3;
inline bool Config::has_roll() const {
  return this != internal_default_instance() && roll_ != nullptr;
}
inline const ::CamController::Messages::AxisConfig& Config::roll() const {
  const ::CamController::Messages::AxisConfig* p = roll_;
  // @@protoc_insertion_point(field_get:AxesCamController.Messages.Config.roll)
  return p != nullptr ? *p : *reinterpret_cast<const ::CamController::Messages::AxisConfig*>(
      &::CamController::Messages::_AxisConfig_default_instance_);
}
inline ::CamController::Messages::AxisConfig* Config::release_roll() {
  // @@protoc_insertion_point(field_release:AxesCamController.Messages.Config.roll)
  
  ::CamController::Messages::AxisConfig* temp = roll_;
  roll_ = nullptr;
  return temp;
}
inline ::CamController::Messages::AxisConfig* Config::mutable_roll() {
  
  if (roll_ == nullptr) {
    auto* p = CreateMaybeMessage<::CamController::Messages::AxisConfig>(GetArenaNoVirtual());
    roll_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AxesCamController.Messages.Config.roll)
  return roll_;
}
inline void Config::set_allocated_roll(::CamController::Messages::AxisConfig* roll) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(roll_);
  }
  if (roll) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      roll = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roll, submessage_arena);
    }
    
  } else {
    
  }
  roll_ = roll;
  // @@protoc_insertion_point(field_set_allocated:AxesCamController.Messages.Config.roll)
}

// -------------------------------------------------------------------

// Reference

// .CamController.Messages.AxisReference yaw = 1;
inline bool Reference::has_yaw() const {
  return this != internal_default_instance() && yaw_ != nullptr;
}
inline const ::CamController::Messages::AxisReference& Reference::yaw() const {
  const ::CamController::Messages::AxisReference* p = yaw_;
  // @@protoc_insertion_point(field_get:AxesCamController.Messages.Reference.yaw)
  return p != nullptr ? *p : *reinterpret_cast<const ::CamController::Messages::AxisReference*>(
      &::CamController::Messages::_AxisReference_default_instance_);
}
inline ::CamController::Messages::AxisReference* Reference::release_yaw() {
  // @@protoc_insertion_point(field_release:AxesCamController.Messages.Reference.yaw)
  
  ::CamController::Messages::AxisReference* temp = yaw_;
  yaw_ = nullptr;
  return temp;
}
inline ::CamController::Messages::AxisReference* Reference::mutable_yaw() {
  
  if (yaw_ == nullptr) {
    auto* p = CreateMaybeMessage<::CamController::Messages::AxisReference>(GetArenaNoVirtual());
    yaw_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AxesCamController.Messages.Reference.yaw)
  return yaw_;
}
inline void Reference::set_allocated_yaw(::CamController::Messages::AxisReference* yaw) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(yaw_);
  }
  if (yaw) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      yaw = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yaw, submessage_arena);
    }
    
  } else {
    
  }
  yaw_ = yaw;
  // @@protoc_insertion_point(field_set_allocated:AxesCamController.Messages.Reference.yaw)
}

// .CamController.Messages.AxisReference pitch = 2;
inline bool Reference::has_pitch() const {
  return this != internal_default_instance() && pitch_ != nullptr;
}
inline const ::CamController::Messages::AxisReference& Reference::pitch() const {
  const ::CamController::Messages::AxisReference* p = pitch_;
  // @@protoc_insertion_point(field_get:AxesCamController.Messages.Reference.pitch)
  return p != nullptr ? *p : *reinterpret_cast<const ::CamController::Messages::AxisReference*>(
      &::CamController::Messages::_AxisReference_default_instance_);
}
inline ::CamController::Messages::AxisReference* Reference::release_pitch() {
  // @@protoc_insertion_point(field_release:AxesCamController.Messages.Reference.pitch)
  
  ::CamController::Messages::AxisReference* temp = pitch_;
  pitch_ = nullptr;
  return temp;
}
inline ::CamController::Messages::AxisReference* Reference::mutable_pitch() {
  
  if (pitch_ == nullptr) {
    auto* p = CreateMaybeMessage<::CamController::Messages::AxisReference>(GetArenaNoVirtual());
    pitch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AxesCamController.Messages.Reference.pitch)
  return pitch_;
}
inline void Reference::set_allocated_pitch(::CamController::Messages::AxisReference* pitch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pitch_);
  }
  if (pitch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pitch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pitch, submessage_arena);
    }
    
  } else {
    
  }
  pitch_ = pitch;
  // @@protoc_insertion_point(field_set_allocated:AxesCamController.Messages.Reference.pitch)
}

// .CamController.Messages.AxisReference roll = 3;
inline bool Reference::has_roll() const {
  return this != internal_default_instance() && roll_ != nullptr;
}
inline const ::CamController::Messages::AxisReference& Reference::roll() const {
  const ::CamController::Messages::AxisReference* p = roll_;
  // @@protoc_insertion_point(field_get:AxesCamController.Messages.Reference.roll)
  return p != nullptr ? *p : *reinterpret_cast<const ::CamController::Messages::AxisReference*>(
      &::CamController::Messages::_AxisReference_default_instance_);
}
inline ::CamController::Messages::AxisReference* Reference::release_roll() {
  // @@protoc_insertion_point(field_release:AxesCamController.Messages.Reference.roll)
  
  ::CamController::Messages::AxisReference* temp = roll_;
  roll_ = nullptr;
  return temp;
}
inline ::CamController::Messages::AxisReference* Reference::mutable_roll() {
  
  if (roll_ == nullptr) {
    auto* p = CreateMaybeMessage<::CamController::Messages::AxisReference>(GetArenaNoVirtual());
    roll_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AxesCamController.Messages.Reference.roll)
  return roll_;
}
inline void Reference::set_allocated_roll(::CamController::Messages::AxisReference* roll) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(roll_);
  }
  if (roll) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      roll = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roll, submessage_arena);
    }
    
  } else {
    
  }
  roll_ = roll;
  // @@protoc_insertion_point(field_set_allocated:AxesCamController.Messages.Reference.roll)
}

// -------------------------------------------------------------------

// ReferenceStatus

// .CamController.Messages.ReferenceStatus.Enum yaw = 1;
inline bool ReferenceStatus::has_yaw() const {
  return id_case() == kYaw;
}
inline void ReferenceStatus::set_has_yaw() {
  _oneof_case_[0] = kYaw;
}
inline void ReferenceStatus::clear_yaw() {
  if (has_yaw()) {
    id_.yaw_ = 0;
    clear_has_id();
  }
}
inline ::CamController::Messages::ReferenceStatus::Enum ReferenceStatus::yaw() const {
  // @@protoc_insertion_point(field_get:AxesCamController.Messages.ReferenceStatus.yaw)
  if (has_yaw()) {
    return static_cast< ::CamController::Messages::ReferenceStatus::Enum >(id_.yaw_);
  }
  return static_cast< ::CamController::Messages::ReferenceStatus::Enum >(0);
}
inline void ReferenceStatus::set_yaw(::CamController::Messages::ReferenceStatus::Enum value) {
  if (!has_yaw()) {
    clear_id();
    set_has_yaw();
  }
  id_.yaw_ = value;
  // @@protoc_insertion_point(field_set:AxesCamController.Messages.ReferenceStatus.yaw)
}

// .CamController.Messages.ReferenceStatus.Enum pitch = 2;
inline bool ReferenceStatus::has_pitch() const {
  return id_case() == kPitch;
}
inline void ReferenceStatus::set_has_pitch() {
  _oneof_case_[0] = kPitch;
}
inline void ReferenceStatus::clear_pitch() {
  if (has_pitch()) {
    id_.pitch_ = 0;
    clear_has_id();
  }
}
inline ::CamController::Messages::ReferenceStatus::Enum ReferenceStatus::pitch() const {
  // @@protoc_insertion_point(field_get:AxesCamController.Messages.ReferenceStatus.pitch)
  if (has_pitch()) {
    return static_cast< ::CamController::Messages::ReferenceStatus::Enum >(id_.pitch_);
  }
  return static_cast< ::CamController::Messages::ReferenceStatus::Enum >(0);
}
inline void ReferenceStatus::set_pitch(::CamController::Messages::ReferenceStatus::Enum value) {
  if (!has_pitch()) {
    clear_id();
    set_has_pitch();
  }
  id_.pitch_ = value;
  // @@protoc_insertion_point(field_set:AxesCamController.Messages.ReferenceStatus.pitch)
}

// .CamController.Messages.ReferenceStatus.Enum roll = 3;
inline bool ReferenceStatus::has_roll() const {
  return id_case() == kRoll;
}
inline void ReferenceStatus::set_has_roll() {
  _oneof_case_[0] = kRoll;
}
inline void ReferenceStatus::clear_roll() {
  if (has_roll()) {
    id_.roll_ = 0;
    clear_has_id();
  }
}
inline ::CamController::Messages::ReferenceStatus::Enum ReferenceStatus::roll() const {
  // @@protoc_insertion_point(field_get:AxesCamController.Messages.ReferenceStatus.roll)
  if (has_roll()) {
    return static_cast< ::CamController::Messages::ReferenceStatus::Enum >(id_.roll_);
  }
  return static_cast< ::CamController::Messages::ReferenceStatus::Enum >(0);
}
inline void ReferenceStatus::set_roll(::CamController::Messages::ReferenceStatus::Enum value) {
  if (!has_roll()) {
    clear_id();
    set_has_roll();
  }
  id_.roll_ = value;
  // @@protoc_insertion_point(field_set:AxesCamController.Messages.ReferenceStatus.roll)
}

inline bool ReferenceStatus::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void ReferenceStatus::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline ReferenceStatus::IdCase ReferenceStatus::id_case() const {
  return ReferenceStatus::IdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Command

// .AxesCamController.Messages.Config set_config = 1;
inline bool Command::has_set_config() const {
  return id_case() == kSetConfig;
}
inline void Command::set_has_set_config() {
  _oneof_case_[0] = kSetConfig;
}
inline void Command::clear_set_config() {
  if (has_set_config()) {
    delete id_.set_config_;
    clear_has_id();
  }
}
inline ::AxesCamController::Messages::Config* Command::release_set_config() {
  // @@protoc_insertion_point(field_release:AxesCamController.Messages.Command.set_config)
  if (has_set_config()) {
    clear_has_id();
      ::AxesCamController::Messages::Config* temp = id_.set_config_;
    id_.set_config_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::AxesCamController::Messages::Config& Command::set_config() const {
  // @@protoc_insertion_point(field_get:AxesCamController.Messages.Command.set_config)
  return has_set_config()
      ? *id_.set_config_
      : *reinterpret_cast< ::AxesCamController::Messages::Config*>(&::AxesCamController::Messages::_Config_default_instance_);
}
inline ::AxesCamController::Messages::Config* Command::mutable_set_config() {
  if (!has_set_config()) {
    clear_id();
    set_has_set_config();
    id_.set_config_ = CreateMaybeMessage< ::AxesCamController::Messages::Config >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:AxesCamController.Messages.Command.set_config)
  return id_.set_config_;
}

// .AxesCamController.Messages.Reference set_reference = 2;
inline bool Command::has_set_reference() const {
  return id_case() == kSetReference;
}
inline void Command::set_has_set_reference() {
  _oneof_case_[0] = kSetReference;
}
inline void Command::clear_set_reference() {
  if (has_set_reference()) {
    delete id_.set_reference_;
    clear_has_id();
  }
}
inline ::AxesCamController::Messages::Reference* Command::release_set_reference() {
  // @@protoc_insertion_point(field_release:AxesCamController.Messages.Command.set_reference)
  if (has_set_reference()) {
    clear_has_id();
      ::AxesCamController::Messages::Reference* temp = id_.set_reference_;
    id_.set_reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::AxesCamController::Messages::Reference& Command::set_reference() const {
  // @@protoc_insertion_point(field_get:AxesCamController.Messages.Command.set_reference)
  return has_set_reference()
      ? *id_.set_reference_
      : *reinterpret_cast< ::AxesCamController::Messages::Reference*>(&::AxesCamController::Messages::_Reference_default_instance_);
}
inline ::AxesCamController::Messages::Reference* Command::mutable_set_reference() {
  if (!has_set_reference()) {
    clear_id();
    set_has_set_reference();
    id_.set_reference_ = CreateMaybeMessage< ::AxesCamController::Messages::Reference >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:AxesCamController.Messages.Command.set_reference)
  return id_.set_reference_;
}

inline bool Command::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void Command::clear_has_id() {
  _oneof_case_[0] = ID_NOT_SET;
}
inline Command::IdCase Command::id_case() const {
  return Command::IdCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Messages
}  // namespace AxesCamController

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_axes_5fcam_5fcontroller_2faxes_5fcam_5fcontroller_2eproto
