# Copyright (C) 2019 Parrot Drones SAS
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  * Redistributions of source code must retain the above copyright
#  notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#  notice, this list of conditions and the following disclaimer in
#  the documentation and/or other materials provided with the
#  distribution.
#  * Neither the name of Parrot nor the names
#  of its contributors may be used to endorse or promote products
#  derived from this software without specific prior written
#  permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
#  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
#  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
#  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
#  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
#  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
#  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
#  SUCH DAMAGE.


import ctypes
import errno
import logging
import os

import libpomp
import msghub_utils


class Message(object):
    def __init__(self):
        self.msg_id = 0
        self.pbuf_msg = None
        self.data = None

    def get_service_id(self):
        return (self.msg_id >> 16) & 0xffff

    @staticmethod
    def from_pbuf_msg(service_id, pbuf_msg):
        msg = Message()
        msg_num = msghub_utils.get_pbuf_msg_num(pbuf_msg)
        msg.msg_id = ((service_id << 16) + msg_num) & 0xffffffff
        msg.pbuf_msg = pbuf_msg
        return msg

    @staticmethod
    def from_data(msg_id, data):
        msg = Message()
        msg.msg_id = msg_id
        msg.data = data
        return msg


class MessageSender(object):
    def __init__(self, service_name):
        self.service_name = service_name
        self.service_id = 0
        self.message_hub = None
        self.channel = None

    def send(self, msg):
        if self.message_hub is None or self.channel is None:
            return -errno.ENOTCONN
        # If not an encapsulated Message, assume it is a protobuf one
        if not isinstance(msg, Message):
            msg = Message.from_pbuf_msg(self.service_id, msg)
        return self.message_hub.send_message(self.channel, msg)


class MessageHandler(object):
    def __init__(self, service_name=''):
        self.service_name = service_name
        self.service_id = 0

    def handle(self, msg):
        raise NotImplementedError()


class Channel(object):
    def __init__(self):
        pass

    def send_message(self, msg):
        raise NotImplementedError()

    def stop(self):
        raise NotImplementedError()

    def cleanup(self):
        pass

class ConnectionHandler(object):
    def on_connected(self, channel, conn):
        pass

    def on_disconnected(self, channel, conn):
        pass


class MessageHub(object):
    def __init__(self, loop, connection_handler=None):
        self.loop = loop
        self.connection_handler = connection_handler
        self.channels = set()
        self.reusable_channels = dict()
        self.message_senders = dict()
        self.message_handlers = dict()
        self.generic_message_handlers = dict()

    def __del__(self):
        assert not self.channels
        assert not self.reusable_channels
        assert not any(self.message_senders.values())
        assert not any(self.message_handlers.values())
        assert not any(self.generic_message_handlers.values())

    def start_server_channel(self, addr_str, mode=0):
        channel = _PompChannel(self, addr_str, mode, self.loop)
        channel.listen()
        self.channels.add(channel)
        return channel

    def start_client_channel(self, addr_str, reuse_channel=False):
        if reuse_channel:
            reusable_channel = self.reusable_channels.get(addr_str, None)
            if reusable_channel:
                # Channel found, simply increase its usage
                reusable_channel.usage += 1
                return reusable_channel.channel
            # Fallback to create a new channel

        channel = _PompChannel(self, addr_str, 0, self.loop)
        channel.connect()

        if reuse_channel:
            reusable_channel = _ReusableChannel(channel)
            self.reusable_channels[addr_str] = reusable_channel
        else:
            self.channels.add(channel)

        return channel

    def register_channel(self, channel):
        self.channels.add(channel)

    def stop_channel(self, channel):
        # Look for regular channels
        if channel in self.channels:
            channel.stop()
            channel.cleanup()
            self.channels.remove(channel)
            return

        # Look for reusable channels
        for addr_str, reusable_channel in self.reusable_channels.items():
            if reusable_channel.channel == channel:
                # Decrease usage and stop/destroy it when no more used
                reusable_channel.usage -= 1
                if reusable_channel.usage == 0:
                    reusable_channel.channel.stop()
                    reusable_channel.channel.cleanup()
                    del self.reusable_channels[addr_str]
                    return

    def stop(self):
        # Stop and destroy regular channels
        for channel in self.channels:
            channel.stop()
            channel.cleanup()
        self.channels.clear()

        # Stop and destroy reusable channels
        for reusable_channel in self.reusable_channels:
            reusable_channel.channel.stop()
            reusable_channel.channel.cleanup()
        self.reusable_channels.clear()

    def attach_message_sender(self, msg_sender, channel):
        service_id = self.get_service_id(msg_sender.service_name)
        msg_sender.service_id = service_id
        msg_sender.message_hub = self
        msg_sender.channel = channel
        if service_id not in self.message_senders:
            self.message_senders[service_id] = set()
        self.message_senders[service_id].add(msg_sender)

    def detach_message_sender(self, msg_sender):
        self.message_senders[msg_sender.service_id].remove(msg_sender)
        msg_sender.service_id = 0
        msg_sender.message_hub = None
        msg_sender.channel = None

    def attach_message_handler(self, msg_handler):
        service_id = self.get_service_id(msg_handler.service_name)
        msg_handler.service_id = service_id
        if msg_handler.service_name:
            if service_id not in self.message_handlers:
                self.message_handlers[service_id] = set()
            self.message_handlers[service_id].add(msg_handler)
        else:
            self.generic_message_handlers.add(msg_handler)

    def detach_message_handler(self, msg_handler):
        if msg_handler.service_name:
            self.message_handlers[msg_handler.service_id].remove(msg_handler)
            msg_handler.service_id = 0
        else:
            self.generic_message_handlers.remove(msg_handler)

    def forward_message(self, msg):
        service_id = msg.get_service_id()
        if service_id in self.message_senders:
            for sender in self.message_senders[service_id]:
                sender.send(msg)

    def send_message(self, channel, msg):
        return channel.send_message(msg)

    def recv_message(self, channel, msg):
        handlers = self.message_handlers.get(msg.get_service_id())
        if handlers is not None:
            for handler in handlers:
                handler.handle(msg)
        for handler in self.generic_message_handlers:
            handler.handle(msg)

    def channel_connected(self, channel, conn):
        if self.connection_handler:
            self.connection_handler.on_connected(channel, conn)

    def channel_disconnected(self, channel, conn):
        if self.connection_handler:
            self.connection_handler.on_disconnected(channel, conn)

    def get_service_id(self, name):
        return msghub_utils.service_id(name)

    def enable_dump(self, channel):
        # TODO
        pass

def make_sockaddr(addr_str):
    sockaddr_buf = libpomp.struct_pomp_sockaddr_storage()
    socklen = ctypes.c_uint32(ctypes.sizeof(
            libpomp.struct_pomp_sockaddr_storage))
    sockaddr_p = libpomp.POINTER_T(libpomp.struct_sockaddr)(sockaddr_buf)
    ret = libpomp.pomp_addr_parse(bytes(addr_str, 'utf8'), sockaddr_p,
                                    ctypes.byref(socklen))
    if ret < 0:
        raise RuntimeError('failed to parse socket addr for %s (%s)' % (
                addr_str, os.strerror(-ret)))
    return sockaddr_p, socklen

class _ReusableChannel(object):
    def __init__(self, channel):
        self.channel = channel
        self.usage = 1

class _PompChannel(Channel):
    def __init__(self, hub, addr_str, mode, loop):
        self.hub = hub
        self.log = logging.getLogger("msghub")
        self._event_cb = libpomp.pomp_event_cb_t(self._on_event)
        self.addr_str = addr_str
        self.mode = mode
        self.sockaddr, self.socklen = make_sockaddr(addr_str)
        self.pomp_ctx = libpomp.pomp_ctx_new_with_loop(
                self._event_cb, None, loop)
        self.is_client = False

    def cleanup(self):
        self.log.info("%s: cleanup", self)
        libpomp.pomp_ctx_destroy(self.pomp_ctx)
        self.pomp_ctx = None
        self._event_cb = None

    def connect(self):
        self.is_client = True
        self.log.info("%s: connect", self)
        libpomp.pomp_ctx_connect(self.pomp_ctx, self.sockaddr, self.socklen)

    def listen(self):
        self.is_client = False
        self.log.info("%s: listen", self)
        if self.mode == 0:
            libpomp.pomp_ctx_listen(self.pomp_ctx,
                    self.sockaddr, self.socklen)
        else:
            libpomp.pomp_ctx_listen_with_access_mode(self.pomp_ctx,
                    self.sockaddr, self.socklen, self.mode)

    def send_message(self, msg):
        data = msg.data or msg.pbuf_msg.SerializeToString()
        dptr = ctypes.c_char_p(data)
        dlen = ctypes.c_uint32(len(data))
        return libpomp.pomp_ctx_send(self.pomp_ctx, msg.msg_id,
                b"%p%u", dptr, dlen)

    def stop(self):
        self.log.info("%s: stop", self)
        libpomp.pomp_ctx_stop(self.pomp_ctx)

    def _on_event(self, ctx, event, conn, msg, userdata):
        if event == libpomp.POMP_EVENT_CONNECTED:
            self.hub.channel_connected(self, conn)
        elif event == libpomp.POMP_EVENT_DISCONNECTED:
            self.hub.channel_disconnected(self, conn)
        elif event == libpomp.POMP_EVENT_MSG:
            msg_id = libpomp.pomp_msg_get_id(msg)
            dptr = ctypes.c_void_p()
            dlen = ctypes.c_uint32(0)
            libpomp.pomp_msg_read(msg,
                    b"%p%u", ctypes.byref(dptr), ctypes.byref(dlen))
            data = ctypes.cast(dptr, ctypes.POINTER(ctypes.c_char * dlen.value))
            data = bytes(data.contents[:])
            msg = Message.from_data(msg_id, data)
            self.hub.recv_message(self, msg)

    def _role_str(self):
        return "client" if self.is_client else "server"

    def __str__(self):
        return "PompChannel: %s at '%s'" % (self._role_str(), self.addr_str)
